<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Title</title>
    <style>
        #panorama {
            position: fixed;
            left: 0;
            right: 0;
            top:0;
            bottom: 0;
            /*padding: 0;*/
        }
    </style>
</head>
<body>
<div id="container">

</div>
</body>
</html>
<script>
    /**Copyright (c) 2019 BaiduVR
     hydreigon project is licensed under the  license
     hydreigon JavaScript library
     https://vr.baidu.com/vrtech/hydreigon/index/
     @version 3.0.0*/
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
            typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (global = global || self, factory(global.Hydreigon = {}));
    }(this, (function (exports) { 'use strict';

        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

        function commonjsRequire () {
            throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
        }

        function createCommonjsModule(fn, module) {
            return module = { exports: {} }, fn(module, module.exports), module.exports;
        }

        var es6Promise = createCommonjsModule(function (module, exports) {
            /*!
	   * @overview es6-promise - a tiny implementation of Promises/A+.
	   * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	   * @license   Licensed under MIT license
	   *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	   * @version   v4.2.8+1e68dce6
	   */
            (function (global, factory) {
                module.exports = factory() ;
            })(commonjsGlobal, function () {

                function objectOrFunction(x) {
                    var type = typeof x;
                    return x !== null && (type === 'object' || type === 'function');
                }

                function isFunction(x) {
                    return typeof x === 'function';
                }

                var _isArray = void 0;

                if (Array.isArray) {
                    _isArray = Array.isArray;
                } else {
                    _isArray = function (x) {
                        return Object.prototype.toString.call(x) === '[object Array]';
                    };
                }

                var isArray = _isArray;
                var len = 0;
                var vertxNext = void 0;
                var customSchedulerFn = void 0;

                var asap = function asap(callback, arg) {
                    queue[len] = callback;
                    queue[len + 1] = arg;
                    len += 2;

                    if (len === 2) {
                        // If len is 2, that means that we need to schedule an async flush.
                        // If additional callbacks are queued before the queue is flushed, they
                        // will be processed by this flush that we are scheduling.
                        if (customSchedulerFn) {
                            customSchedulerFn(flush);
                        } else {
                            scheduleFlush();
                        }
                    }
                };

                function setScheduler(scheduleFn) {
                    customSchedulerFn = scheduleFn;
                }

                function setAsap(asapFn) {
                    asap = asapFn;
                }

                var browserWindow = typeof window !== 'undefined' ? window : undefined;
                var browserGlobal = browserWindow || {};
                var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
                var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10

                var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node

                function useNextTick() {
                    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
                    // see https://github.com/cujojs/when/issues/410 for details
                    return function () {
                        return process.nextTick(flush);
                    };
                } // vertx


                function useVertxTimer() {
                    if (typeof vertxNext !== 'undefined') {
                        return function () {
                            vertxNext(flush);
                        };
                    }

                    return useSetTimeout();
                }

                function useMutationObserver() {
                    var iterations = 0;
                    var observer = new BrowserMutationObserver(flush);
                    var node = document.createTextNode('');
                    observer.observe(node, {
                        characterData: true
                    });
                    return function () {
                        node.data = iterations = ++iterations % 2;
                    };
                } // web worker


                function useMessageChannel() {
                    var channel = new MessageChannel();
                    channel.port1.onmessage = flush;
                    return function () {
                        return channel.port2.postMessage(0);
                    };
                }

                function useSetTimeout() {
                    // Store setTimeout reference so es6-promise will be unaffected by
                    // other code modifying setTimeout (like sinon.useFakeTimers())
                    var globalSetTimeout = setTimeout;
                    return function () {
                        return globalSetTimeout(flush, 1);
                    };
                }

                var queue = new Array(1000);

                function flush() {
                    for (var i = 0; i < len; i += 2) {
                        var callback = queue[i];
                        var arg = queue[i + 1];
                        callback(arg);
                        queue[i] = undefined;
                        queue[i + 1] = undefined;
                    }

                    len = 0;
                }

                function attemptVertx() {
                    try {
                        var vertx = Function('return this')().require('vertx');

                        vertxNext = vertx.runOnLoop || vertx.runOnContext;
                        return useVertxTimer();
                    } catch (e) {
                        return useSetTimeout();
                    }
                }

                var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks:

                if (isNode) {
                    scheduleFlush = useNextTick();
                } else if (BrowserMutationObserver) {
                    scheduleFlush = useMutationObserver();
                } else if (isWorker) {
                    scheduleFlush = useMessageChannel();
                } else if (browserWindow === undefined && typeof commonjsRequire === 'function') {
                    scheduleFlush = attemptVertx();
                } else {
                    scheduleFlush = useSetTimeout();
                }

                function then(onFulfillment, onRejection) {
                    var parent = this;
                    var child = new this.constructor(noop);

                    if (child[PROMISE_ID] === undefined) {
                        makePromise(child);
                    }

                    var _state = parent._state;

                    if (_state) {
                        var callback = arguments[_state - 1];
                        asap(function () {
                            return invokeCallback(_state, child, callback, parent._result);
                        });
                    } else {
                        subscribe(parent, child, onFulfillment, onRejection);
                    }

                    return child;
                }
                /**
                 `Promise.resolve` returns a promise that will become resolved with the
                 passed `value`. It is shorthand for the following:

                 ```javascript
                 let promise = new Promise(function(resolve, reject){
	        resolve(1);
	      });

                 promise.then(function(value){
	        // value === 1
	      });
                 ```

                 Instead of writing the above, your code now simply becomes the following:

                 ```javascript
                 let promise = Promise.resolve(1);

                 promise.then(function(value){
	        // value === 1
	      });
                 ```

                 @method resolve
                 @static
                 @param {Any} value value that the returned promise will be resolved with
                 Useful for tooling.
                 @return {Promise} a promise that will become fulfilled with the given
                 `value`
                 */


                function resolve$1(object) {
                    /*jshint validthis:true */
                    var Constructor = this;

                    if (object && typeof object === 'object' && object.constructor === Constructor) {
                        return object;
                    }

                    var promise = new Constructor(noop);
                    resolve(promise, object);
                    return promise;
                }

                var PROMISE_ID = Math.random().toString(36).substring(2);

                function noop() {}

                var PENDING = void 0;
                var FULFILLED = 1;
                var REJECTED = 2;

                function selfFulfillment() {
                    return new TypeError("You cannot resolve a promise with itself");
                }

                function cannotReturnOwn() {
                    return new TypeError('A promises callback cannot return that same promise.');
                }

                function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
                    try {
                        then$$1.call(value, fulfillmentHandler, rejectionHandler);
                    } catch (e) {
                        return e;
                    }
                }

                function handleForeignThenable(promise, thenable, then$$1) {
                    asap(function (promise) {
                        var sealed = false;
                        var error = tryThen(then$$1, thenable, function (value) {
                            if (sealed) {
                                return;
                            }

                            sealed = true;

                            if (thenable !== value) {
                                resolve(promise, value);
                            } else {
                                fulfill(promise, value);
                            }
                        }, function (reason) {
                            if (sealed) {
                                return;
                            }

                            sealed = true;
                            reject(promise, reason);
                        }, 'Settle: ' + (promise._label || ' unknown promise'));

                        if (!sealed && error) {
                            sealed = true;
                            reject(promise, error);
                        }
                    }, promise);
                }

                function handleOwnThenable(promise, thenable) {
                    if (thenable._state === FULFILLED) {
                        fulfill(promise, thenable._result);
                    } else if (thenable._state === REJECTED) {
                        reject(promise, thenable._result);
                    } else {
                        subscribe(thenable, undefined, function (value) {
                            return resolve(promise, value);
                        }, function (reason) {
                            return reject(promise, reason);
                        });
                    }
                }

                function handleMaybeThenable(promise, maybeThenable, then$$1) {
                    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
                        handleOwnThenable(promise, maybeThenable);
                    } else {
                        if (then$$1 === undefined) {
                            fulfill(promise, maybeThenable);
                        } else if (isFunction(then$$1)) {
                            handleForeignThenable(promise, maybeThenable, then$$1);
                        } else {
                            fulfill(promise, maybeThenable);
                        }
                    }
                }

                function resolve(promise, value) {
                    if (promise === value) {
                        reject(promise, selfFulfillment());
                    } else if (objectOrFunction(value)) {
                        var then$$1 = void 0;

                        try {
                            then$$1 = value.then;
                        } catch (error) {
                            reject(promise, error);
                            return;
                        }

                        handleMaybeThenable(promise, value, then$$1);
                    } else {
                        fulfill(promise, value);
                    }
                }

                function publishRejection(promise) {
                    if (promise._onerror) {
                        promise._onerror(promise._result);
                    }

                    publish(promise);
                }

                function fulfill(promise, value) {
                    if (promise._state !== PENDING) {
                        return;
                    }

                    promise._result = value;
                    promise._state = FULFILLED;

                    if (promise._subscribers.length !== 0) {
                        asap(publish, promise);
                    }
                }

                function reject(promise, reason) {
                    if (promise._state !== PENDING) {
                        return;
                    }

                    promise._state = REJECTED;
                    promise._result = reason;
                    asap(publishRejection, promise);
                }

                function subscribe(parent, child, onFulfillment, onRejection) {
                    var _subscribers = parent._subscribers;
                    var length = _subscribers.length;
                    parent._onerror = null;
                    _subscribers[length] = child;
                    _subscribers[length + FULFILLED] = onFulfillment;
                    _subscribers[length + REJECTED] = onRejection;

                    if (length === 0 && parent._state) {
                        asap(publish, parent);
                    }
                }

                function publish(promise) {
                    var subscribers = promise._subscribers;
                    var settled = promise._state;

                    if (subscribers.length === 0) {
                        return;
                    }

                    var child = void 0,
                        callback = void 0,
                        detail = promise._result;

                    for (var i = 0; i < subscribers.length; i += 3) {
                        child = subscribers[i];
                        callback = subscribers[i + settled];

                        if (child) {
                            invokeCallback(settled, child, callback, detail);
                        } else {
                            callback(detail);
                        }
                    }

                    promise._subscribers.length = 0;
                }

                function invokeCallback(settled, promise, callback, detail) {
                    var hasCallback = isFunction(callback),
                        value = void 0,
                        error = void 0,
                        succeeded = true;

                    if (hasCallback) {
                        try {
                            value = callback(detail);
                        } catch (e) {
                            succeeded = false;
                            error = e;
                        }

                        if (promise === value) {
                            reject(promise, cannotReturnOwn());
                            return;
                        }
                    } else {
                        value = detail;
                    }

                    if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
                        resolve(promise, value);
                    } else if (succeeded === false) {
                        reject(promise, error);
                    } else if (settled === FULFILLED) {
                        fulfill(promise, value);
                    } else if (settled === REJECTED) {
                        reject(promise, value);
                    }
                }

                function initializePromise(promise, resolver) {
                    try {
                        resolver(function resolvePromise(value) {
                            resolve(promise, value);
                        }, function rejectPromise(reason) {
                            reject(promise, reason);
                        });
                    } catch (e) {
                        reject(promise, e);
                    }
                }

                var id = 0;

                function nextId() {
                    return id++;
                }

                function makePromise(promise) {
                    promise[PROMISE_ID] = id++;
                    promise._state = undefined;
                    promise._result = undefined;
                    promise._subscribers = [];
                }

                function validationError() {
                    return new Error('Array Methods must be provided an Array');
                }

                var Enumerator = function () {
                    function Enumerator(Constructor, input) {
                        this._instanceConstructor = Constructor;
                        this.promise = new Constructor(noop);

                        if (!this.promise[PROMISE_ID]) {
                            makePromise(this.promise);
                        }

                        if (isArray(input)) {
                            this.length = input.length;
                            this._remaining = input.length;
                            this._result = new Array(this.length);

                            if (this.length === 0) {
                                fulfill(this.promise, this._result);
                            } else {
                                this.length = this.length || 0;

                                this._enumerate(input);

                                if (this._remaining === 0) {
                                    fulfill(this.promise, this._result);
                                }
                            }
                        } else {
                            reject(this.promise, validationError());
                        }
                    }

                    Enumerator.prototype._enumerate = function _enumerate(input) {
                        for (var i = 0; this._state === PENDING && i < input.length; i++) {
                            this._eachEntry(input[i], i);
                        }
                    };

                    Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
                        var c = this._instanceConstructor;
                        var resolve$$1 = c.resolve;

                        if (resolve$$1 === resolve$1) {
                            var _then = void 0;

                            var error = void 0;
                            var didError = false;

                            try {
                                _then = entry.then;
                            } catch (e) {
                                didError = true;
                                error = e;
                            }

                            if (_then === then && entry._state !== PENDING) {
                                this._settledAt(entry._state, i, entry._result);
                            } else if (typeof _then !== 'function') {
                                this._remaining--;
                                this._result[i] = entry;
                            } else if (c === Promise$1) {
                                var promise = new c(noop);

                                if (didError) {
                                    reject(promise, error);
                                } else {
                                    handleMaybeThenable(promise, entry, _then);
                                }

                                this._willSettleAt(promise, i);
                            } else {
                                this._willSettleAt(new c(function (resolve$$1) {
                                    return resolve$$1(entry);
                                }), i);
                            }
                        } else {
                            this._willSettleAt(resolve$$1(entry), i);
                        }
                    };

                    Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
                        var promise = this.promise;

                        if (promise._state === PENDING) {
                            this._remaining--;

                            if (state === REJECTED) {
                                reject(promise, value);
                            } else {
                                this._result[i] = value;
                            }
                        }

                        if (this._remaining === 0) {
                            fulfill(promise, this._result);
                        }
                    };

                    Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
                        var enumerator = this;
                        subscribe(promise, undefined, function (value) {
                            return enumerator._settledAt(FULFILLED, i, value);
                        }, function (reason) {
                            return enumerator._settledAt(REJECTED, i, reason);
                        });
                    };

                    return Enumerator;
                }();
                /**
                 `Promise.all` accepts an array of promises, and returns a new promise which
                 is fulfilled with an array of fulfillment values for the passed promises, or
                 rejected with the reason of the first passed promise to be rejected. It casts all
                 elements of the passed iterable to promises as it runs this algorithm.

                 Example:

                 ```javascript
                 let promise1 = resolve(1);
                 let promise2 = resolve(2);
                 let promise3 = resolve(3);
                 let promises = [ promise1, promise2, promise3 ];

                 Promise.all(promises).then(function(array){
	        // The array here would be [ 1, 2, 3 ];
	      });
                 ```

                 If any of the `promises` given to `all` are rejected, the first promise
                 that is rejected will be given as an argument to the returned promises's
                 rejection handler. For example:

                 Example:

                 ```javascript
                 let promise1 = resolve(1);
                 let promise2 = reject(new Error("2"));
                 let promise3 = reject(new Error("3"));
                 let promises = [ promise1, promise2, promise3 ];

                 Promise.all(promises).then(function(array){
	        // Code here never runs because there are rejected promises!
	      }, function(error) {
	        // error.message === "2"
	      });
                 ```

                 @method all
                 @static
                 @param {Array} entries array of promises
                 @param {String} label optional string for labeling the promise.
                 Useful for tooling.
                 @return {Promise} promise that is fulfilled when all `promises` have been
                 fulfilled, or rejected if any of them become rejected.
                 @static
                 */


                function all(entries) {
                    return new Enumerator(this, entries).promise;
                }
                /**
                 `Promise.race` returns a new promise which is settled in the same way as the
                 first passed promise to settle.

                 Example:

                 ```javascript
                 let promise1 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 1');
	        }, 200);
	      });

                 let promise2 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 2');
	        }, 100);
	      });

                 Promise.race([promise1, promise2]).then(function(result){
	        // result === 'promise 2' because it was resolved before promise1
	        // was resolved.
	      });
                 ```

                 `Promise.race` is deterministic in that only the state of the first
                 settled promise matters. For example, even if other promises given to the
                 `promises` array argument are resolved, but the first settled promise has
                 become rejected before the other promises became fulfilled, the returned
                 promise will become rejected:

                 ```javascript
                 let promise1 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 1');
	        }, 200);
	      });

                 let promise2 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          reject(new Error('promise 2'));
	        }, 100);
	      });

                 Promise.race([promise1, promise2]).then(function(result){
	        // Code here never runs
	      }, function(reason){
	        // reason.message === 'promise 2' because promise 2 became rejected before
	        // promise 1 became fulfilled
	      });
                 ```

                 An example real-world use case is implementing timeouts:

                 ```javascript
                 Promise.race([ajax('foo.json'), timeout(5000)])
                 ```

                 @method race
                 @static
                 @param {Array} promises array of promises to observe
                 Useful for tooling.
                 @return {Promise} a promise which settles in the same way as the first passed
                 promise to settle.
                 */


                function race(entries) {
                    /*jshint validthis:true */
                    var Constructor = this;

                    if (!isArray(entries)) {
                        return new Constructor(function (_, reject) {
                            return reject(new TypeError('You must pass an array to race.'));
                        });
                    } else {
                        return new Constructor(function (resolve, reject) {
                            var length = entries.length;

                            for (var i = 0; i < length; i++) {
                                Constructor.resolve(entries[i]).then(resolve, reject);
                            }
                        });
                    }
                }
                /**
                 `Promise.reject` returns a promise rejected with the passed `reason`.
                 It is shorthand for the following:

                 ```javascript
                 let promise = new Promise(function(resolve, reject){
	        reject(new Error('WHOOPS'));
	      });

                 promise.then(function(value){
	        // Code here doesn't run because the promise is rejected!
	      }, function(reason){
	        // reason.message === 'WHOOPS'
	      });
                 ```

                 Instead of writing the above, your code now simply becomes the following:

                 ```javascript
                 let promise = Promise.reject(new Error('WHOOPS'));

                 promise.then(function(value){
	        // Code here doesn't run because the promise is rejected!
	      }, function(reason){
	        // reason.message === 'WHOOPS'
	      });
                 ```

                 @method reject
                 @static
                 @param {Any} reason value that the returned promise will be rejected with.
                 Useful for tooling.
                 @return {Promise} a promise rejected with the given `reason`.
                 */


                function reject$1(reason) {
                    /*jshint validthis:true */
                    var Constructor = this;
                    var promise = new Constructor(noop);
                    reject(promise, reason);
                    return promise;
                }

                function needsResolver() {
                    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
                }

                function needsNew() {
                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                /**
                 Promise objects represent the eventual result of an asynchronous operation. The
                 primary way of interacting with a promise is through its `then` method, which
                 registers callbacks to receive either a promise's eventual value or the reason
                 why the promise cannot be fulfilled.

                 Terminology
                 -----------

                 - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
                 - `thenable` is an object or function that defines a `then` method.
                 - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
                 - `exception` is a value that is thrown using the throw statement.
                 - `reason` is a value that indicates why a promise was rejected.
                 - `settled` the final resting state of a promise, fulfilled or rejected.

                 A promise can be in one of three states: pending, fulfilled, or rejected.

                 Promises that are fulfilled have a fulfillment value and are in the fulfilled
                 state.  Promises that are rejected have a rejection reason and are in the
                 rejected state.  A fulfillment value is never a thenable.

                 Promises can also be said to *resolve* a value.  If this value is also a
                 promise, then the original promise's settled state will match the value's
                 settled state.  So a promise that *resolves* a promise that rejects will
                 itself reject, and a promise that *resolves* a promise that fulfills will
                 itself fulfill.


                 Basic Usage:
                 ------------

                 ```js
                 let promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);

	        // on failure
	        reject(reason);
	      });

                 promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
                 ```

                 Advanced Usage:
                 ---------------

                 Promises shine when abstracting away asynchronous interactions such as
                 `XMLHttpRequest`s.

                 ```js
                 function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          let xhr = new XMLHttpRequest();

	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();

	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }

                 getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
                 ```

                 Unlike callbacks, promises are great composable primitives.

                 ```js
                 Promise.all([
                 getJSON('/posts'),
                 getJSON('/comments')
                 ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON

	        return values;
	      });
                 ```

                 @class Promise
                 @param {Function} resolver
                 Useful for tooling.
                 @constructor
                 */


                var Promise$1 = function () {
                    function Promise(resolver) {
                        this[PROMISE_ID] = nextId();
                        this._result = this._state = undefined;
                        this._subscribers = [];

                        if (noop !== resolver) {
                            typeof resolver !== 'function' && needsResolver();
                            this instanceof Promise ? initializePromise(this, resolver) : needsNew();
                        }
                    }
                    /**
                     The primary way of interacting with a promise is through its `then` method,
                     which registers callbacks to receive either a promise's eventual value or the
                     reason why the promise cannot be fulfilled.
                     ```js
                     findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
                     ```
                     Chaining
                     --------
                     The return value of `then` is itself a promise.  This second, 'downstream'
                     promise is resolved with the return value of the first promise's fulfillment
                     or rejection handler, or rejected if the handler throws an exception.
                     ```js
                     findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
                     findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
                     ```
                     If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
                     ```js
                     findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
                     ```
                     Assimilation
                     ------------
                     Sometimes the value you want to propagate to a downstream promise can only be
                     retrieved asynchronously. This can be achieved by returning a promise in the
                     fulfillment or rejection handler. The downstream promise will then be pending
                     until the returned promise is settled. This is called *assimilation*.
                     ```js
                     findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
                     ```
                     If the assimliated promise rejects, then the downstream promise will also reject.
                     ```js
                     findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
                     ```
                     Simple Example
                     --------------
                     Synchronous Example
                     ```javascript
                     let result;
                     try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
                     ```
                     Errback Example
                     ```js
                     findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
                     ```
                     Promise Example;
                     ```javascript
                     findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
                     ```
                     Advanced Example
                     --------------
                     Synchronous Example
                     ```javascript
                     let author, books;
                     try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
                     ```
                     Errback Example
                     ```js
                     function foundBooks(books) {
	       }
                     function failure(reason) {
	       }
                     findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
                     ```
                     Promise Example;
                     ```javascript
                     findAuthor().
                     then(findBooksByAuthor).
                     then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
                     ```
                     @method then
                     @param {Function} onFulfilled
                     @param {Function} onRejected
                     Useful for tooling.
                     @return {Promise}
                     */

                    /**
                     `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
                     as the catch block of a try/catch statement.
                     ```js
                     function findAuthor(){
	      throw new Error('couldn't find that author');
	      }
                     // synchronous
                     try {
	      findAuthor();
	      } catch(reason) {
	      // something went wrong
	      }
                     // async with promises
                     findAuthor().catch(function(reason){
	      // something went wrong
	      });
                     ```
                     @method catch
                     @param {Function} onRejection
                     Useful for tooling.
                     @return {Promise}
                     */


                    Promise.prototype.catch = function _catch(onRejection) {
                        return this.then(null, onRejection);
                    };
                    /**
                     `finally` will be invoked regardless of the promise's fate just as native
                     try/catch/finally behaves

                     Synchronous example:

                     ```js
                     findAuthor() {
	          if (Math.random() > 0.5) {
	            throw new Error();
	          }
	          return new Author();
	        }

                     try {
	          return findAuthor(); // succeed or fail
	        } catch(error) {
	          return findOtherAuther();
	        } finally {
	          // always runs
	          // doesn't affect the return value
	        }
                     ```

                     Asynchronous example:

                     ```js
                     findAuthor().catch(function(reason){
	          return findOtherAuther();
	        }).finally(function(){
	          // author was either found, or not
	        });
                     ```

                     @method finally
                     @param {Function} callback
                     @return {Promise}
                     */


                    Promise.prototype.finally = function _finally(callback) {
                        var promise = this;
                        var constructor = promise.constructor;

                        if (isFunction(callback)) {
                            return promise.then(function (value) {
                                return constructor.resolve(callback()).then(function () {
                                    return value;
                                });
                            }, function (reason) {
                                return constructor.resolve(callback()).then(function () {
                                    throw reason;
                                });
                            });
                        }

                        return promise.then(callback, callback);
                    };

                    return Promise;
                }();

                Promise$1.prototype.then = then;
                Promise$1.all = all;
                Promise$1.race = race;
                Promise$1.resolve = resolve$1;
                Promise$1.reject = reject$1;
                Promise$1._setScheduler = setScheduler;
                Promise$1._setAsap = setAsap;
                Promise$1._asap = asap;
                /*global self*/

                function polyfill() {
                    var local = void 0;

                    if (typeof commonjsGlobal !== 'undefined') {
                        local = commonjsGlobal;
                    } else if (typeof self !== 'undefined') {
                        local = self;
                    } else {
                        try {
                            local = Function('return this')();
                        } catch (e) {
                            throw new Error('polyfill failed because global object is unavailable in this environment');
                        }
                    }

                    var P = local.Promise;

                    if (P) {
                        var promiseToString = null;

                        try {
                            promiseToString = Object.prototype.toString.call(P.resolve());
                        } catch (e) {// silently ignored
                        }

                        if (promiseToString === '[object Promise]' && !P.cast) {
                            return;
                        }
                    }

                    local.Promise = Promise$1;
                } // Strange compat..


                Promise$1.polyfill = polyfill;
                Promise$1.Promise = Promise$1;
                return Promise$1;
            });
        });

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }

            return obj;
        }

        function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);

            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function (sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
            }

            return keys;
        }

        function _objectSpread2(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};

                if (i % 2) {
                    ownKeys(Object(source), true).forEach(function (key) {
                        _defineProperty(target, key, source[key]);
                    });
                } else if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                    ownKeys(Object(source)).forEach(function (key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
            }

            return target;
        }

        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
        }

        function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
            };

            return _setPrototypeOf(o, p);
        }

        function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === "function") return true;

            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
                return true;
            } catch (e) {
                return false;
            }
        }

        function _construct(Parent, args, Class) {
            if (_isNativeReflectConstruct()) {
                _construct = Reflect.construct;
            } else {
                _construct = function _construct(Parent, args, Class) {
                    var a = [null];
                    a.push.apply(a, args);
                    var Constructor = Function.bind.apply(Parent, a);
                    var instance = new Constructor();
                    if (Class) _setPrototypeOf(instance, Class.prototype);
                    return instance;
                };
            }

            return _construct.apply(null, arguments);
        }

        function _assertThisInitialized(self) {
            if (self === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return self;
        }

        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;

            for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

            return arr2;
        }

        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
            var it;

            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    return function () {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    };
                }

                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }

            it = o[Symbol.iterator]();
            return it.next.bind(it);
        }

        var CullFaceNone = 0;
        var CullFaceBack = 1;
        var CullFaceFront = 2;
        var PCFShadowMap = 1;
        var PCFSoftShadowMap = 2;
        var VSMShadowMap = 3;
        var FrontSide = 0;
        var BackSide = 1;
        var DoubleSide = 2;
        var FlatShading = 1;
        var NoBlending = 0;
        var NormalBlending = 1;
        var AdditiveBlending = 2;
        var SubtractiveBlending = 3;
        var MultiplyBlending = 4;
        var CustomBlending = 5;
        var AddEquation = 100;
        var SubtractEquation = 101;
        var ReverseSubtractEquation = 102;
        var MinEquation = 103;
        var MaxEquation = 104;
        var ZeroFactor = 200;
        var OneFactor = 201;
        var SrcColorFactor = 202;
        var OneMinusSrcColorFactor = 203;
        var SrcAlphaFactor = 204;
        var OneMinusSrcAlphaFactor = 205;
        var DstAlphaFactor = 206;
        var OneMinusDstAlphaFactor = 207;
        var DstColorFactor = 208;
        var OneMinusDstColorFactor = 209;
        var SrcAlphaSaturateFactor = 210;
        var NeverDepth = 0;
        var AlwaysDepth = 1;
        var LessDepth = 2;
        var LessEqualDepth = 3;
        var EqualDepth = 4;
        var GreaterEqualDepth = 5;
        var GreaterDepth = 6;
        var NotEqualDepth = 7;
        var MultiplyOperation = 0;
        var MixOperation = 1;
        var AddOperation = 2;
        var NoToneMapping = 0;
        var LinearToneMapping = 1;
        var ReinhardToneMapping = 2;
        var Uncharted2ToneMapping = 3;
        var CineonToneMapping = 4;
        var ACESFilmicToneMapping = 5;
        var UVMapping = 300;
        var CubeReflectionMapping = 301;
        var CubeRefractionMapping = 302;
        var EquirectangularReflectionMapping = 303;
        var EquirectangularRefractionMapping = 304;
        var SphericalReflectionMapping = 305;
        var CubeUVReflectionMapping = 306;
        var CubeUVRefractionMapping = 307;
        var RepeatWrapping = 1000;
        var ClampToEdgeWrapping = 1001;
        var MirroredRepeatWrapping = 1002;
        var NearestFilter = 1003;
        var NearestMipmapNearestFilter = 1004;
        var NearestMipmapLinearFilter = 1005;
        var NearestMipMapLinearFilter = 1005;
        var LinearFilter = 1006;
        var LinearMipmapNearestFilter = 1007;
        var LinearMipmapLinearFilter = 1008;
        var UnsignedByteType = 1009;
        var ByteType = 1010;
        var ShortType = 1011;
        var UnsignedShortType = 1012;
        var IntType = 1013;
        var UnsignedIntType = 1014;
        var FloatType = 1015;
        var HalfFloatType = 1016;
        var UnsignedShort4444Type = 1017;
        var UnsignedShort5551Type = 1018;
        var UnsignedShort565Type = 1019;
        var UnsignedInt248Type = 1020;
        var AlphaFormat = 1021;
        var RGBFormat = 1022;
        var RGBAFormat = 1023;
        var LuminanceFormat = 1024;
        var LuminanceAlphaFormat = 1025;
        var DepthFormat = 1026;
        var DepthStencilFormat = 1027;
        var RedFormat = 1028;
        var RedIntegerFormat = 1029;
        var RGFormat = 1030;
        var RGIntegerFormat = 1031;
        var RGBIntegerFormat = 1032;
        var RGBAIntegerFormat = 1033;
        var RGB_S3TC_DXT1_Format = 33776;
        var RGBA_S3TC_DXT1_Format = 33777;
        var RGBA_S3TC_DXT3_Format = 33778;
        var RGBA_S3TC_DXT5_Format = 33779;
        var RGB_PVRTC_4BPPV1_Format = 35840;
        var RGB_PVRTC_2BPPV1_Format = 35841;
        var RGBA_PVRTC_4BPPV1_Format = 35842;
        var RGBA_PVRTC_2BPPV1_Format = 35843;
        var RGB_ETC1_Format = 36196;
        var RGB_ETC2_Format = 37492;
        var RGBA_ETC2_EAC_Format = 37496;
        var RGBA_ASTC_4x4_Format = 37808;
        var RGBA_ASTC_5x4_Format = 37809;
        var RGBA_ASTC_5x5_Format = 37810;
        var RGBA_ASTC_6x5_Format = 37811;
        var RGBA_ASTC_6x6_Format = 37812;
        var RGBA_ASTC_8x5_Format = 37813;
        var RGBA_ASTC_8x6_Format = 37814;
        var RGBA_ASTC_8x8_Format = 37815;
        var RGBA_ASTC_10x5_Format = 37816;
        var RGBA_ASTC_10x6_Format = 37817;
        var RGBA_ASTC_10x8_Format = 37818;
        var RGBA_ASTC_10x10_Format = 37819;
        var RGBA_ASTC_12x10_Format = 37820;
        var RGBA_ASTC_12x12_Format = 37821;
        var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
        var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
        var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
        var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
        var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
        var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
        var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
        var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
        var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
        var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
        var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
        var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
        var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
        var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
        var LinearEncoding = 3000;
        var sRGBEncoding = 3001;
        var GammaEncoding = 3007;
        var RGBEEncoding = 3002;
        var LogLuvEncoding = 3003;
        var RGBM7Encoding = 3004;
        var RGBM16Encoding = 3005;
        var RGBDEncoding = 3006;
        var BasicDepthPacking = 3200;
        var RGBADepthPacking = 3201;
        var TangentSpaceNormalMap = 0;
        var ObjectSpaceNormalMap = 1;
        var KeepStencilOp = 7680;
        var AlwaysStencilFunc = 519;
        var StaticDrawUsage = 35044;

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author thezwap
         */
        var _lut = [];

        for (var i = 0; i < 256; i++) {
            _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
        }

        var MathUtils = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
                var d0 = Math.random() * 0xffffffff | 0;
                var d1 = Math.random() * 0xffffffff | 0;
                var d2 = Math.random() * 0xffffffff | 0;
                var d3 = Math.random() * 0xffffffff | 0;
                var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

                return uuid.toUpperCase();
            },
            clamp: function (value, min, max) {
                return Math.max(min, Math.min(max, value));
            },
            // compute euclidian modulo of m % n
            // https://en.wikipedia.org/wiki/Modulo_operation
            euclideanModulo: function (n, m) {
                return (n % m + m) % m;
            },
            // Linear mapping from range <a1, a2> to range <b1, b2>
            mapLinear: function (x, a1, a2, b1, b2) {
                return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
            },
            // https://en.wikipedia.org/wiki/Linear_interpolation
            lerp: function (x, y, t) {
                return (1 - t) * x + t * y;
            },
            // http://en.wikipedia.org/wiki/Smoothstep
            smoothstep: function (x, min, max) {
                if (x <= min) return 0;
                if (x >= max) return 1;
                x = (x - min) / (max - min);
                return x * x * (3 - 2 * x);
            },
            smootherstep: function (x, min, max) {
                if (x <= min) return 0;
                if (x >= max) return 1;
                x = (x - min) / (max - min);
                return x * x * x * (x * (x * 6 - 15) + 10);
            },
            // Random integer from <low, high> interval
            randInt: function (low, high) {
                return low + Math.floor(Math.random() * (high - low + 1));
            },
            // Random float from <low, high> interval
            randFloat: function (low, high) {
                return low + Math.random() * (high - low);
            },
            // Random float from <-range/2, range/2> interval
            randFloatSpread: function (range) {
                return range * (0.5 - Math.random());
            },
            degToRad: function (degrees) {
                return degrees * MathUtils.DEG2RAD;
            },
            radToDeg: function (radians) {
                return radians * MathUtils.RAD2DEG;
            },
            isPowerOfTwo: function (value) {
                return (value & value - 1) === 0 && value !== 0;
            },
            ceilPowerOfTwo: function (value) {
                return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
            },
            floorPowerOfTwo: function (value) {
                return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
            },
            setQuaternionFromProperEuler: function (q, a, b, c, order) {
                // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
                // rotations are applied to the axes in the order specified by 'order'
                // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
                // angles are in radians
                var cos = Math.cos;
                var sin = Math.sin;
                var c2 = cos(b / 2);
                var s2 = sin(b / 2);
                var c13 = cos((a + c) / 2);
                var s13 = sin((a + c) / 2);
                var c1_3 = cos((a - c) / 2);
                var s1_3 = sin((a - c) / 2);
                var c3_1 = cos((c - a) / 2);
                var s3_1 = sin((c - a) / 2);

                if (order === 'XYX') {
                    q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                } else if (order === 'YZY') {
                    q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                } else if (order === 'ZXZ') {
                    q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                } else if (order === 'XZX') {
                    q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                } else if (order === 'YXY') {
                    q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                } else if (order === 'ZYZ') {
                    q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                } else {
                    console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.');
                }
            }
        };

        /**
         * https://github.com/mrdoob/eventdispatcher.js/
         */
        function EventDispatcher() {}

        Object.assign(EventDispatcher.prototype, {
            addEventListener: function (type, listener) {
                if (this._listeners === undefined) this._listeners = {};
                var listeners = this._listeners;

                if (listeners[type] === undefined) {
                    listeners[type] = [];
                }

                if (listeners[type].indexOf(listener) === -1) {
                    listeners[type].push(listener);
                }
            },
            hasEventListener: function (type, listener) {
                if (this._listeners === undefined) return false;
                var listeners = this._listeners;
                return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
            },
            removeEventListener: function (type, listener) {
                if (this._listeners === undefined) return;
                var listeners = this._listeners;
                var listenerArray = listeners[type];

                if (listenerArray !== undefined) {
                    var index = listenerArray.indexOf(listener);

                    if (index !== -1) {
                        listenerArray.splice(index, 1);
                    }
                }
            },
            dispatchEvent: function (event) {
                if (this._listeners === undefined) return;
                var listeners = this._listeners;
                var listenerArray = listeners[event.type];

                if (listenerArray !== undefined) {
                    event.target = this;
                    var array = listenerArray.slice(0);

                    for (var i = 0, l = array.length; i < l; i++) {
                        array[i].call(this, event);
                    }
                }
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author philogb / http://blog.thejit.org/
         * @author egraether / http://egraether.com/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         */
        function Vector2(x, y) {
            this.x = x || 0;
            this.y = y || 0;
        }

        Object.defineProperties(Vector2.prototype, {
            "width": {
                get: function () {
                    return this.x;
                },
                set: function (value) {
                    this.x = value;
                }
            },
            "height": {
                get: function () {
                    return this.y;
                },
                set: function (value) {
                    this.y = value;
                }
            }
        });
        Object.assign(Vector2.prototype, {
            isVector2: true,
            set: function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            },
            setScalar: function (scalar) {
                this.x = scalar;
                this.y = scalar;
                return this;
            },
            setX: function (x) {
                this.x = x;
                return this;
            },
            setY: function (y) {
                this.y = y;
                return this;
            },
            setComponent: function (index, value) {
                switch (index) {
                    case 0:
                        this.x = value;
                        break;

                    case 1:
                        this.y = value;
                        break;

                    default:
                        throw new Error('index is out of range: ' + index);
                }

                return this;
            },
            getComponent: function (index) {
                switch (index) {
                    case 0:
                        return this.x;

                    case 1:
                        return this.y;

                    default:
                        throw new Error('index is out of range: ' + index);
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y);
            },
            copy: function (v) {
                this.x = v.x;
                this.y = v.y;
                return this;
            },
            add: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);
                }

                this.x += v.x;
                this.y += v.y;
                return this;
            },
            addScalar: function (s) {
                this.x += s;
                this.y += s;
                return this;
            },
            addVectors: function (a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                return this;
            },
            addScaledVector: function (v, s) {
                this.x += v.x * s;
                this.y += v.y * s;
                return this;
            },
            sub: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);
                }

                this.x -= v.x;
                this.y -= v.y;
                return this;
            },
            subScalar: function (s) {
                this.x -= s;
                this.y -= s;
                return this;
            },
            subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                return this;
            },
            multiply: function (v) {
                this.x *= v.x;
                this.y *= v.y;
                return this;
            },
            multiplyScalar: function (scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            },
            divide: function (v) {
                this.x /= v.x;
                this.y /= v.y;
                return this;
            },
            divideScalar: function (scalar) {
                return this.multiplyScalar(1 / scalar);
            },
            applyMatrix3: function (m) {
                var x = this.x,
                    y = this.y;
                var e = m.elements;
                this.x = e[0] * x + e[3] * y + e[6];
                this.y = e[1] * x + e[4] * y + e[7];
                return this;
            },
            min: function (v) {
                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                return this;
            },
            max: function (v) {
                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                return this;
            },
            clamp: function (min, max) {
                // assumes min < max, componentwise
                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));
                return this;
            },
            clampScalar: function (minVal, maxVal) {
                this.x = Math.max(minVal, Math.min(maxVal, this.x));
                this.y = Math.max(minVal, Math.min(maxVal, this.y));
                return this;
            },
            clampLength: function (min, max) {
                var length = this.length();
                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            },
            floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                return this;
            },
            ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                return this;
            },
            round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                return this;
            },
            roundToZero: function () {
                this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                return this;
            },
            negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                return this;
            },
            dot: function (v) {
                return this.x * v.x + this.y * v.y;
            },
            cross: function (v) {
                return this.x * v.y - this.y * v.x;
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y;
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y);
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1);
            },
            angle: function () {
                // computes the angle in radians with respect to the positive x-axis
                var angle = Math.atan2(-this.y, -this.x) + Math.PI;
                return angle;
            },
            distanceTo: function (v) {
                return Math.sqrt(this.distanceToSquared(v));
            },
            distanceToSquared: function (v) {
                var dx = this.x - v.x,
                    dy = this.y - v.y;
                return dx * dx + dy * dy;
            },
            manhattanDistanceTo: function (v) {
                return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
            },
            setLength: function (length) {
                return this.normalize().multiplyScalar(length);
            },
            lerp: function (v, alpha) {
                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                return this;
            },
            lerpVectors: function (v1, v2, alpha) {
                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            equals: function (v) {
                return v.x === this.x && v.y === this.y;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;
                this.x = array[offset];
                this.y = array[offset + 1];
                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this.x;
                array[offset + 1] = this.y;
                return array;
            },
            fromBufferAttribute: function (attribute, index, offset) {
                if (offset !== undefined) {
                    console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);
                return this;
            },
            rotateAround: function (center, angle) {
                var c = Math.cos(angle),
                    s = Math.sin(angle);
                var x = this.x - center.x;
                var y = this.y - center.y;
                this.x = x * c - y * s + center.x;
                this.y = x * s + y * c + center.y;
                return this;
            }
        });

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         * @author tschw
         */
        function Matrix3() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

            if (arguments.length > 0) {
                console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
            }
        }

        Object.assign(Matrix3.prototype, {
            isMatrix3: true,
            set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                var te = this.elements;
                te[0] = n11;
                te[1] = n21;
                te[2] = n31;
                te[3] = n12;
                te[4] = n22;
                te[5] = n32;
                te[6] = n13;
                te[7] = n23;
                te[8] = n33;
                return this;
            },
            identity: function () {
                this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                return this;
            },
            clone: function () {
                return new this.constructor().fromArray(this.elements);
            },
            copy: function (m) {
                var te = this.elements;
                var me = m.elements;
                te[0] = me[0];
                te[1] = me[1];
                te[2] = me[2];
                te[3] = me[3];
                te[4] = me[4];
                te[5] = me[5];
                te[6] = me[6];
                te[7] = me[7];
                te[8] = me[8];
                return this;
            },
            extractBasis: function (xAxis, yAxis, zAxis) {
                xAxis.setFromMatrix3Column(this, 0);
                yAxis.setFromMatrix3Column(this, 1);
                zAxis.setFromMatrix3Column(this, 2);
                return this;
            },
            setFromMatrix4: function (m) {
                var me = m.elements;
                this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
                return this;
            },
            multiply: function (m) {
                return this.multiplyMatrices(this, m);
            },
            premultiply: function (m) {
                return this.multiplyMatrices(m, this);
            },
            multiplyMatrices: function (a, b) {
                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;
                var a11 = ae[0],
                    a12 = ae[3],
                    a13 = ae[6];
                var a21 = ae[1],
                    a22 = ae[4],
                    a23 = ae[7];
                var a31 = ae[2],
                    a32 = ae[5],
                    a33 = ae[8];
                var b11 = be[0],
                    b12 = be[3],
                    b13 = be[6];
                var b21 = be[1],
                    b22 = be[4],
                    b23 = be[7];
                var b31 = be[2],
                    b32 = be[5],
                    b33 = be[8];
                te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                te[6] = a11 * b13 + a12 * b23 + a13 * b33;
                te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                te[7] = a21 * b13 + a22 * b23 + a23 * b33;
                te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                te[8] = a31 * b13 + a32 * b23 + a33 * b33;
                return this;
            },
            multiplyScalar: function (s) {
                var te = this.elements;
                te[0] *= s;
                te[3] *= s;
                te[6] *= s;
                te[1] *= s;
                te[4] *= s;
                te[7] *= s;
                te[2] *= s;
                te[5] *= s;
                te[8] *= s;
                return this;
            },
            determinant: function () {
                var te = this.elements;
                var a = te[0],
                    b = te[1],
                    c = te[2],
                    d = te[3],
                    e = te[4],
                    f = te[5],
                    g = te[6],
                    h = te[7],
                    i = te[8];
                return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            },
            getInverse: function (matrix, throwOnDegenerate) {
                if (matrix && matrix.isMatrix4) {
                    console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                }

                var me = matrix.elements,
                    te = this.elements,
                    n11 = me[0],
                    n21 = me[1],
                    n31 = me[2],
                    n12 = me[3],
                    n22 = me[4],
                    n32 = me[5],
                    n13 = me[6],
                    n23 = me[7],
                    n33 = me[8],
                    t11 = n33 * n22 - n32 * n23,
                    t12 = n32 * n13 - n33 * n12,
                    t13 = n23 * n12 - n22 * n13,
                    det = n11 * t11 + n21 * t12 + n31 * t13;

                if (det === 0) {
                    var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

                    if (throwOnDegenerate === true) {
                        throw new Error(msg);
                    } else {
                        console.warn(msg);
                    }

                    return this.identity();
                }

                var detInv = 1 / det;
                te[0] = t11 * detInv;
                te[1] = (n31 * n23 - n33 * n21) * detInv;
                te[2] = (n32 * n21 - n31 * n22) * detInv;
                te[3] = t12 * detInv;
                te[4] = (n33 * n11 - n31 * n13) * detInv;
                te[5] = (n31 * n12 - n32 * n11) * detInv;
                te[6] = t13 * detInv;
                te[7] = (n21 * n13 - n23 * n11) * detInv;
                te[8] = (n22 * n11 - n21 * n12) * detInv;
                return this;
            },
            transpose: function () {
                var tmp,
                    m = this.elements;
                tmp = m[1];
                m[1] = m[3];
                m[3] = tmp;
                tmp = m[2];
                m[2] = m[6];
                m[6] = tmp;
                tmp = m[5];
                m[5] = m[7];
                m[7] = tmp;
                return this;
            },
            getNormalMatrix: function (matrix4) {
                return this.setFromMatrix4(matrix4).getInverse(this).transpose();
            },
            transposeIntoArray: function (r) {
                var m = this.elements;
                r[0] = m[0];
                r[1] = m[3];
                r[2] = m[6];
                r[3] = m[1];
                r[4] = m[4];
                r[5] = m[7];
                r[6] = m[2];
                r[7] = m[5];
                r[8] = m[8];
                return this;
            },
            setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
                var c = Math.cos(rotation);
                var s = Math.sin(rotation);
                this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
            },
            scale: function (sx, sy) {
                var te = this.elements;
                te[0] *= sx;
                te[3] *= sx;
                te[6] *= sx;
                te[1] *= sy;
                te[4] *= sy;
                te[7] *= sy;
                return this;
            },
            rotate: function (theta) {
                var c = Math.cos(theta);
                var s = Math.sin(theta);
                var te = this.elements;
                var a11 = te[0],
                    a12 = te[3],
                    a13 = te[6];
                var a21 = te[1],
                    a22 = te[4],
                    a23 = te[7];
                te[0] = c * a11 + s * a21;
                te[3] = c * a12 + s * a22;
                te[6] = c * a13 + s * a23;
                te[1] = -s * a11 + c * a21;
                te[4] = -s * a12 + c * a22;
                te[7] = -s * a13 + c * a23;
                return this;
            },
            translate: function (tx, ty) {
                var te = this.elements;
                te[0] += tx * te[2];
                te[3] += tx * te[5];
                te[6] += tx * te[8];
                te[1] += ty * te[2];
                te[4] += ty * te[5];
                te[7] += ty * te[8];
                return this;
            },
            equals: function (matrix) {
                var te = this.elements;
                var me = matrix.elements;

                for (var i = 0; i < 9; i++) {
                    if (te[i] !== me[i]) return false;
                }

                return true;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;

                for (var i = 0; i < 9; i++) {
                    this.elements[i] = array[i + offset];
                }

                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                var te = this.elements;
                array[offset] = te[0];
                array[offset + 1] = te[1];
                array[offset + 2] = te[2];
                array[offset + 3] = te[3];
                array[offset + 4] = te[4];
                array[offset + 5] = te[5];
                array[offset + 6] = te[6];
                array[offset + 7] = te[7];
                array[offset + 8] = te[8];
                return array;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author szimek / https://github.com/szimek/
         */
        var _canvas;

        var ImageUtils = {
            getDataURL: function (image) {
                var canvas;

                if (typeof HTMLCanvasElement == 'undefined') {
                    return image.src;
                } else if (image instanceof HTMLCanvasElement) {
                    canvas = image;
                } else {
                    if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    _canvas.width = image.width;
                    _canvas.height = image.height;

                    var context = _canvas.getContext('2d');

                    if (image instanceof ImageData) {
                        context.putImageData(image, 0, 0);
                    } else {
                        context.drawImage(image, 0, 0, image.width, image.height);
                    }

                    canvas = _canvas;
                }

                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL('image/jpeg', 0.6);
                } else {
                    return canvas.toDataURL('image/png');
                }
            }
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author szimek / https://github.com/szimek/
         */
        var textureId = 0;

        function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            Object.defineProperty(this, 'id', {
                value: textureId++
            });
            this.uuid = MathUtils.generateUUID();
            this.name = '';
            this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
            this.mipmaps = [];
            this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
            this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
            this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
            this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
            this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
            this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
            this.format = format !== undefined ? format : RGBAFormat;
            this.internalFormat = null;
            this.type = type !== undefined ? type : UnsignedByteType;
            this.offset = new Vector2(0, 0);
            this.repeat = new Vector2(1, 1);
            this.center = new Vector2(0, 0);
            this.rotation = 0;
            this.matrixAutoUpdate = true;
            this.matrix = new Matrix3();
            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
            //
            // Also changing the encoding after already used by a Material will not automatically make the Material
            // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

            this.encoding = encoding !== undefined ? encoding : LinearEncoding;
            this.version = 0;
            this.onUpdate = null;
        }

        Texture.DEFAULT_IMAGE = undefined;
        Texture.DEFAULT_MAPPING = UVMapping;
        Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: Texture,
            isTexture: true,
            updateMatrix: function () {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (source) {
                this.name = source.name;
                this.image = source.image;
                this.mipmaps = source.mipmaps.slice(0);
                this.mapping = source.mapping;
                this.wrapS = source.wrapS;
                this.wrapT = source.wrapT;
                this.magFilter = source.magFilter;
                this.minFilter = source.minFilter;
                this.anisotropy = source.anisotropy;
                this.format = source.format;
                this.internalFormat = source.internalFormat;
                this.type = source.type;
                this.offset.copy(source.offset);
                this.repeat.copy(source.repeat);
                this.center.copy(source.center);
                this.rotation = source.rotation;
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrix.copy(source.matrix);
                this.generateMipmaps = source.generateMipmaps;
                this.premultiplyAlpha = source.premultiplyAlpha;
                this.flipY = source.flipY;
                this.unpackAlignment = source.unpackAlignment;
                this.encoding = source.encoding;
                return this;
            },
            toJSON: function (meta) {
                var isRootObject = meta === undefined || typeof meta === 'string';

                if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                    return meta.textures[this.uuid];
                }

                var output = {
                    metadata: {
                        version: 4.5,
                        type: 'Texture',
                        generator: 'Texture.toJSON'
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };

                if (this.image !== undefined) {
                    // TODO: Move to THREE.Image
                    var image = this.image;

                    if (image.uuid === undefined) {
                        image.uuid = MathUtils.generateUUID(); // UGH
                    }

                    if (!isRootObject && meta.images[image.uuid] === undefined) {
                        var url;

                        if (Array.isArray(image)) {
                            // process array of images e.g. CubeTexture
                            url = [];

                            for (var i = 0, l = image.length; i < l; i++) {
                                url.push(ImageUtils.getDataURL(image[i]));
                            }
                        } else {
                            // process single image
                            url = ImageUtils.getDataURL(image);
                        }

                        meta.images[image.uuid] = {
                            uuid: image.uuid,
                            url: url
                        };
                    }

                    output.image = image.uuid;
                }

                if (!isRootObject) {
                    meta.textures[this.uuid] = output;
                }

                return output;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            },
            transformUv: function (uv) {
                if (this.mapping !== UVMapping) return uv;
                uv.applyMatrix3(this.matrix);

                if (uv.x < 0 || uv.x > 1) {
                    switch (this.wrapS) {
                        case RepeatWrapping:
                            uv.x = uv.x - Math.floor(uv.x);
                            break;

                        case ClampToEdgeWrapping:
                            uv.x = uv.x < 0 ? 0 : 1;
                            break;

                        case MirroredRepeatWrapping:
                            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                                uv.x = Math.ceil(uv.x) - uv.x;
                            } else {
                                uv.x = uv.x - Math.floor(uv.x);
                            }

                            break;
                    }
                }

                if (uv.y < 0 || uv.y > 1) {
                    switch (this.wrapT) {
                        case RepeatWrapping:
                            uv.y = uv.y - Math.floor(uv.y);
                            break;

                        case ClampToEdgeWrapping:
                            uv.y = uv.y < 0 ? 0 : 1;
                            break;

                        case MirroredRepeatWrapping:
                            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                                uv.y = Math.ceil(uv.y) - uv.y;
                            } else {
                                uv.y = uv.y - Math.floor(uv.y);
                            }

                            break;
                    }
                }

                if (this.flipY) {
                    uv.y = 1 - uv.y;
                }

                return uv;
            }
        });
        Object.defineProperty(Texture.prototype, "needsUpdate", {
            set: function (value) {
                if (value === true) this.version++;
            }
        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.image = {
                data: data || null,
                width: width || 1,
                height: height || 1
            };
            this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
            this.needsUpdate = true;
        }

        DataTexture.prototype = Object.create(Texture.prototype);
        DataTexture.prototype.constructor = DataTexture;
        DataTexture.prototype.isDataTexture = true;

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         */

        function Quaternion(x, y, z, w) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = w !== undefined ? w : 1;
        }

        Object.assign(Quaternion, {
            slerp: function (qa, qb, qm, t) {
                return qm.copy(qa).slerp(qb, t);
            },
            slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                // fuzz-free, array-based Quaternion SLERP operation
                var x0 = src0[srcOffset0 + 0],
                    y0 = src0[srcOffset0 + 1],
                    z0 = src0[srcOffset0 + 2],
                    w0 = src0[srcOffset0 + 3],
                    x1 = src1[srcOffset1 + 0],
                    y1 = src1[srcOffset1 + 1],
                    z1 = src1[srcOffset1 + 2],
                    w1 = src1[srcOffset1 + 3];

                if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                    var s = 1 - t,
                        cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                        dir = cos >= 0 ? 1 : -1,
                        sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

                    if (sqrSin > Number.EPSILON) {
                        var sin = Math.sqrt(sqrSin),
                            len = Math.atan2(sin, cos * dir);
                        s = Math.sin(s * len) / sin;
                        t = Math.sin(t * len) / sin;
                    }

                    var tDir = t * dir;
                    x0 = x0 * s + x1 * tDir;
                    y0 = y0 * s + y1 * tDir;
                    z0 = z0 * s + z1 * tDir;
                    w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

                    if (s === 1 - t) {
                        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                        x0 *= f;
                        y0 *= f;
                        z0 *= f;
                        w0 *= f;
                    }
                }

                dst[dstOffset] = x0;
                dst[dstOffset + 1] = y0;
                dst[dstOffset + 2] = z0;
                dst[dstOffset + 3] = w0;
            }
        });
        Object.defineProperties(Quaternion.prototype, {
            x: {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x = value;

                    this._onChangeCallback();
                }
            },
            y: {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y = value;

                    this._onChangeCallback();
                }
            },
            z: {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z = value;

                    this._onChangeCallback();
                }
            },
            w: {
                get: function () {
                    return this._w;
                },
                set: function (value) {
                    this._w = value;

                    this._onChangeCallback();
                }
            }
        });
        Object.assign(Quaternion.prototype, {
            isQuaternion: true,
            set: function (x, y, z, w) {
                this._x = x;
                this._y = y;
                this._z = z;
                this._w = w;

                this._onChangeCallback();

                return this;
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w);
            },
            copy: function (quaternion) {
                this._x = quaternion.x;
                this._y = quaternion.y;
                this._z = quaternion.z;
                this._w = quaternion.w;

                this._onChangeCallback();

                return this;
            },
            setFromEuler: function (euler, update) {
                if (!(euler && euler.isEuler)) {
                    throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
                }

                var x = euler._x,
                    y = euler._y,
                    z = euler._z,
                    order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
                // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
                //	content/SpinCalc.m

                var cos = Math.cos;
                var sin = Math.sin;
                var c1 = cos(x / 2);
                var c2 = cos(y / 2);
                var c3 = cos(z / 2);
                var s1 = sin(x / 2);
                var s2 = sin(y / 2);
                var s3 = sin(z / 2);

                if (order === 'XYZ') {
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === 'YXZ') {
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if (order === 'ZXY') {
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === 'ZYX') {
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if (order === 'YZX') {
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === 'XZY') {
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                }

                if (update !== false) this._onChangeCallback();
                return this;
            },
            setFromAxisAngle: function (axis, angle) {
                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
                // assumes axis is normalized
                var halfAngle = angle / 2,
                    s = Math.sin(halfAngle);
                this._x = axis.x * s;
                this._y = axis.y * s;
                this._z = axis.z * s;
                this._w = Math.cos(halfAngle);

                this._onChangeCallback();

                return this;
            },
            setFromRotationMatrix: function (m) {
                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                var te = m.elements,
                    m11 = te[0],
                    m12 = te[4],
                    m13 = te[8],
                    m21 = te[1],
                    m22 = te[5],
                    m23 = te[9],
                    m31 = te[2],
                    m32 = te[6],
                    m33 = te[10],
                    trace = m11 + m22 + m33,
                    s;

                if (trace > 0) {
                    s = 0.5 / Math.sqrt(trace + 1.0);
                    this._w = 0.25 / s;
                    this._x = (m32 - m23) * s;
                    this._y = (m13 - m31) * s;
                    this._z = (m21 - m12) * s;
                } else if (m11 > m22 && m11 > m33) {
                    s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                    this._w = (m32 - m23) / s;
                    this._x = 0.25 * s;
                    this._y = (m12 + m21) / s;
                    this._z = (m13 + m31) / s;
                } else if (m22 > m33) {
                    s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                    this._w = (m13 - m31) / s;
                    this._x = (m12 + m21) / s;
                    this._y = 0.25 * s;
                    this._z = (m23 + m32) / s;
                } else {
                    s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                    this._w = (m21 - m12) / s;
                    this._x = (m13 + m31) / s;
                    this._y = (m23 + m32) / s;
                    this._z = 0.25 * s;
                }

                this._onChangeCallback();

                return this;
            },
            setFromUnitVectors: function (vFrom, vTo) {
                // assumes direction vectors vFrom and vTo are normalized
                var EPS = 0.000001;
                var r = vFrom.dot(vTo) + 1;

                if (r < EPS) {
                    r = 0;

                    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                        this._x = -vFrom.y;
                        this._y = vFrom.x;
                        this._z = 0;
                        this._w = r;
                    } else {
                        this._x = 0;
                        this._y = -vFrom.z;
                        this._z = vFrom.y;
                        this._w = r;
                    }
                } else {
                    // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                    this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                    this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                    this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                    this._w = r;
                }

                return this.normalize();
            },
            angleTo: function (q) {
                return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
            },
            rotateTowards: function (q, step) {
                var angle = this.angleTo(q);
                if (angle === 0) return this;
                var t = Math.min(1, step / angle);
                this.slerp(q, t);
                return this;
            },
            inverse: function () {
                // quaternion is assumed to have unit length
                return this.conjugate();
            },
            conjugate: function () {
                this._x *= -1;
                this._y *= -1;
                this._z *= -1;

                this._onChangeCallback();

                return this;
            },
            dot: function (v) {
                return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
            },
            lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            },
            length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
            },
            normalize: function () {
                var l = this.length();

                if (l === 0) {
                    this._x = 0;
                    this._y = 0;
                    this._z = 0;
                    this._w = 1;
                } else {
                    l = 1 / l;
                    this._x = this._x * l;
                    this._y = this._y * l;
                    this._z = this._z * l;
                    this._w = this._w * l;
                }

                this._onChangeCallback();

                return this;
            },
            multiply: function (q, p) {
                if (p !== undefined) {
                    console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                    return this.multiplyQuaternions(q, p);
                }

                return this.multiplyQuaternions(this, q);
            },
            premultiply: function (q) {
                return this.multiplyQuaternions(q, this);
            },
            multiplyQuaternions: function (a, b) {
                // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
                var qax = a._x,
                    qay = a._y,
                    qaz = a._z,
                    qaw = a._w;
                var qbx = b._x,
                    qby = b._y,
                    qbz = b._z,
                    qbw = b._w;
                this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

                this._onChangeCallback();

                return this;
            },
            slerp: function (qb, t) {
                if (t === 0) return this;
                if (t === 1) return this.copy(qb);
                var x = this._x,
                    y = this._y,
                    z = this._z,
                    w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

                var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

                if (cosHalfTheta < 0) {
                    this._w = -qb._w;
                    this._x = -qb._x;
                    this._y = -qb._y;
                    this._z = -qb._z;
                    cosHalfTheta = -cosHalfTheta;
                } else {
                    this.copy(qb);
                }

                if (cosHalfTheta >= 1.0) {
                    this._w = w;
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    return this;
                }

                var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

                if (sqrSinHalfTheta <= Number.EPSILON) {
                    var s = 1 - t;
                    this._w = s * w + t * this._w;
                    this._x = s * x + t * this._x;
                    this._y = s * y + t * this._y;
                    this._z = s * z + t * this._z;
                    this.normalize();

                    this._onChangeCallback();

                    return this;
                }

                var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
                var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                this._w = w * ratioA + this._w * ratioB;
                this._x = x * ratioA + this._x * ratioB;
                this._y = y * ratioA + this._y * ratioB;
                this._z = z * ratioA + this._z * ratioB;

                this._onChangeCallback();

                return this;
            },
            equals: function (quaternion) {
                return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;
                this._x = array[offset];
                this._y = array[offset + 1];
                this._z = array[offset + 2];
                this._w = array[offset + 3];

                this._onChangeCallback();

                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this._x;
                array[offset + 1] = this._y;
                array[offset + 2] = this._z;
                array[offset + 3] = this._w;
                return array;
            },
            _onChange: function (callback) {
                this._onChangeCallback = callback;
                return this;
            },
            _onChangeCallback: function () {}
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author kile / http://kile.stravaganza.org/
         * @author philogb / http://blog.thejit.org/
         * @author mikael emtinger / http://gomo.se/
         * @author egraether / http://egraether.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        var _vector = new Vector3();

        var _quaternion = new Quaternion();

        function Vector3(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }

        Object.assign(Vector3.prototype, {
            isVector3: true,
            set: function (x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            },
            setScalar: function (scalar) {
                this.x = scalar;
                this.y = scalar;
                this.z = scalar;
                return this;
            },
            setX: function (x) {
                this.x = x;
                return this;
            },
            setY: function (y) {
                this.y = y;
                return this;
            },
            setZ: function (z) {
                this.z = z;
                return this;
            },
            setComponent: function (index, value) {
                switch (index) {
                    case 0:
                        this.x = value;
                        break;

                    case 1:
                        this.y = value;
                        break;

                    case 2:
                        this.z = value;
                        break;

                    default:
                        throw new Error('index is out of range: ' + index);
                }

                return this;
            },
            getComponent: function (index) {
                switch (index) {
                    case 0:
                        return this.x;

                    case 1:
                        return this.y;

                    case 2:
                        return this.z;

                    default:
                        throw new Error('index is out of range: ' + index);
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z);
            },
            copy: function (v) {
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return this;
            },
            add: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);
                }

                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                return this;
            },
            addScalar: function (s) {
                this.x += s;
                this.y += s;
                this.z += s;
                return this;
            },
            addVectors: function (a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                return this;
            },
            addScaledVector: function (v, s) {
                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;
                return this;
            },
            sub: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);
                }

                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                return this;
            },
            subScalar: function (s) {
                this.x -= s;
                this.y -= s;
                this.z -= s;
                return this;
            },
            subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                return this;
            },
            multiply: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                    return this.multiplyVectors(v, w);
                }

                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z;
                return this;
            },
            multiplyScalar: function (scalar) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                return this;
            },
            multiplyVectors: function (a, b) {
                this.x = a.x * b.x;
                this.y = a.y * b.y;
                this.z = a.z * b.z;
                return this;
            },
            applyEuler: function (euler) {
                if (!(euler && euler.isEuler)) {
                    console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                }

                return this.applyQuaternion(_quaternion.setFromEuler(euler));
            },
            applyAxisAngle: function (axis, angle) {
                return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
            },
            applyMatrix3: function (m) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                this.x = e[0] * x + e[3] * y + e[6] * z;
                this.y = e[1] * x + e[4] * y + e[7] * z;
                this.z = e[2] * x + e[5] * y + e[8] * z;
                return this;
            },
            applyNormalMatrix: function (m) {
                return this.applyMatrix3(m).normalize();
            },
            applyMatrix4: function (m) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
                return this;
            },
            applyQuaternion: function (q) {
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var qx = q.x,
                    qy = q.y,
                    qz = q.z,
                    qw = q.w; // calculate quat * vector

                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

                this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return this;
            },
            project: function (camera) {
                return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            },
            unproject: function (camera) {
                return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
            },
            transformDirection: function (m) {
                // input: THREE.Matrix4 affine matrix
                // vector interpreted as a direction
                var x = this.x,
                    y = this.y,
                    z = this.z;
                var e = m.elements;
                this.x = e[0] * x + e[4] * y + e[8] * z;
                this.y = e[1] * x + e[5] * y + e[9] * z;
                this.z = e[2] * x + e[6] * y + e[10] * z;
                return this.normalize();
            },
            divide: function (v) {
                this.x /= v.x;
                this.y /= v.y;
                this.z /= v.z;
                return this;
            },
            divideScalar: function (scalar) {
                return this.multiplyScalar(1 / scalar);
            },
            min: function (v) {
                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                this.z = Math.min(this.z, v.z);
                return this;
            },
            max: function (v) {
                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                this.z = Math.max(this.z, v.z);
                return this;
            },
            clamp: function (min, max) {
                // assumes min < max, componentwise
                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));
                this.z = Math.max(min.z, Math.min(max.z, this.z));
                return this;
            },
            clampScalar: function (minVal, maxVal) {
                this.x = Math.max(minVal, Math.min(maxVal, this.x));
                this.y = Math.max(minVal, Math.min(maxVal, this.y));
                this.z = Math.max(minVal, Math.min(maxVal, this.z));
                return this;
            },
            clampLength: function (min, max) {
                var length = this.length();
                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            },
            floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);
                return this;
            },
            ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);
                return this;
            },
            round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);
                return this;
            },
            roundToZero: function () {
                this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
                return this;
            },
            negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                return this;
            },
            dot: function (v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            },
            // TODO lengthSquared?
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1);
            },
            setLength: function (length) {
                return this.normalize().multiplyScalar(length);
            },
            lerp: function (v, alpha) {
                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                this.z += (v.z - this.z) * alpha;
                return this;
            },
            lerpVectors: function (v1, v2, alpha) {
                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            cross: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                    return this.crossVectors(v, w);
                }

                return this.crossVectors(this, v);
            },
            crossVectors: function (a, b) {
                var ax = a.x,
                    ay = a.y,
                    az = a.z;
                var bx = b.x,
                    by = b.y,
                    bz = b.z;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
            },
            projectOnVector: function (v) {
                var denominator = v.lengthSq();
                if (denominator === 0) return this.set(0, 0, 0);
                var scalar = v.dot(this) / denominator;
                return this.copy(v).multiplyScalar(scalar);
            },
            projectOnPlane: function (planeNormal) {
                _vector.copy(this).projectOnVector(planeNormal);

                return this.sub(_vector);
            },
            reflect: function (normal) {
                // reflect incident vector off plane orthogonal to normal
                // normal is assumed to have unit length
                return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
            },
            angleTo: function (v) {
                var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
                if (denominator === 0) return Math.PI / 2;
                var theta = this.dot(v) / denominator; // clamp, to handle numerical problems

                return Math.acos(MathUtils.clamp(theta, -1, 1));
            },
            distanceTo: function (v) {
                return Math.sqrt(this.distanceToSquared(v));
            },
            distanceToSquared: function (v) {
                var dx = this.x - v.x,
                    dy = this.y - v.y,
                    dz = this.z - v.z;
                return dx * dx + dy * dy + dz * dz;
            },
            manhattanDistanceTo: function (v) {
                return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
            },
            setFromSpherical: function (s) {
                return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
            },
            setFromSphericalCoords: function (radius, phi, theta) {
                var sinPhiRadius = Math.sin(phi) * radius;
                this.x = sinPhiRadius * Math.sin(theta);
                this.y = Math.cos(phi) * radius;
                this.z = sinPhiRadius * Math.cos(theta);
                return this;
            },
            setFromCylindrical: function (c) {
                return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
            },
            setFromCylindricalCoords: function (radius, theta, y) {
                this.x = radius * Math.sin(theta);
                this.y = y;
                this.z = radius * Math.cos(theta);
                return this;
            },
            setFromMatrixPosition: function (m) {
                var e = m.elements;
                this.x = e[12];
                this.y = e[13];
                this.z = e[14];
                return this;
            },
            setFromMatrixScale: function (m) {
                var sx = this.setFromMatrixColumn(m, 0).length();
                var sy = this.setFromMatrixColumn(m, 1).length();
                var sz = this.setFromMatrixColumn(m, 2).length();
                this.x = sx;
                this.y = sy;
                this.z = sz;
                return this;
            },
            setFromMatrixColumn: function (m, index) {
                return this.fromArray(m.elements, index * 4);
            },
            setFromMatrix3Column: function (m, index) {
                return this.fromArray(m.elements, index * 3);
            },
            equals: function (v) {
                return v.x === this.x && v.y === this.y && v.z === this.z;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;
                this.x = array[offset];
                this.y = array[offset + 1];
                this.z = array[offset + 2];
                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this.x;
                array[offset + 1] = this.y;
                array[offset + 2] = this.z;
                return array;
            },
            fromBufferAttribute: function (attribute, index, offset) {
                if (offset !== undefined) {
                    console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);
                this.z = attribute.getZ(index);
                return this;
            }
        });

        var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

        var _vector$1 = new Vector3();

        var _box = new Box3(); // triangle centered vertices


        var _v0 = new Vector3();

        var _v1 = new Vector3();

        var _v2 = new Vector3(); // triangle edge vectors


        var _f0 = new Vector3();

        var _f1 = new Vector3();

        var _f2 = new Vector3();

        var _center = new Vector3();

        var _extents = new Vector3();

        var _triangleNormal = new Vector3();

        var _testAxis = new Vector3();
        /**
         * @author bhouston / http://clara.io
         * @author WestLangley / http://github.com/WestLangley
         */


        function Box3(min, max) {
            this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
            this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
        }

        Object.assign(Box3.prototype, {
            isBox3: true,
            set: function (min, max) {
                this.min.copy(min);
                this.max.copy(max);
                return this;
            },
            setFromArray: function (array) {
                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;

                for (var i = 0, l = array.length; i < l; i += 3) {
                    var x = array[i];
                    var y = array[i + 1];
                    var z = array[i + 2];
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (z < minZ) minZ = z;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                    if (z > maxZ) maxZ = z;
                }

                this.min.set(minX, minY, minZ);
                this.max.set(maxX, maxY, maxZ);
                return this;
            },
            setFromBufferAttribute: function (attribute) {
                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;

                for (var i = 0, l = attribute.count; i < l; i++) {
                    var x = attribute.getX(i);
                    var y = attribute.getY(i);
                    var z = attribute.getZ(i);
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (z < minZ) minZ = z;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                    if (z > maxZ) maxZ = z;
                }

                this.min.set(minX, minY, minZ);
                this.max.set(maxX, maxY, maxZ);
                return this;
            },
            setFromPoints: function (points) {
                this.makeEmpty();

                for (var i = 0, il = points.length; i < il; i++) {
                    this.expandByPoint(points[i]);
                }

                return this;
            },
            setFromCenterAndSize: function (center, size) {
                var halfSize = _vector$1.copy(size).multiplyScalar(0.5);

                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            },
            setFromObject: function (object) {
                this.makeEmpty();
                return this.expandByObject(object);
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (box) {
                this.min.copy(box.min);
                this.max.copy(box.max);
                return this;
            },
            makeEmpty: function () {
                this.min.x = this.min.y = this.min.z = +Infinity;
                this.max.x = this.max.y = this.max.z = -Infinity;
                return this;
            },
            isEmpty: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            },
            getCenter: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Box3: .getCenter() target is now required');
                    target = new Vector3();
                }

                return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Box3: .getSize() target is now required');
                    target = new Vector3();
                }

                return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
            },
            expandByPoint: function (point) {
                this.min.min(point);
                this.max.max(point);
                return this;
            },
            expandByVector: function (vector) {
                this.min.sub(vector);
                this.max.add(vector);
                return this;
            },
            expandByScalar: function (scalar) {
                this.min.addScalar(-scalar);
                this.max.addScalar(scalar);
                return this;
            },
            expandByObject: function (object) {
                // Computes the world-axis-aligned bounding box of an object (including its children),
                // accounting for both the object's, and children's, world transforms
                object.updateWorldMatrix(false, false);
                var geometry = object.geometry;

                if (geometry !== undefined) {
                    if (geometry.boundingBox === null) {
                        geometry.computeBoundingBox();
                    }

                    _box.copy(geometry.boundingBox);

                    _box.applyMatrix4(object.matrixWorld);

                    this.union(_box);
                }

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    this.expandByObject(children[i]);
                }

                return this;
            },
            containsPoint: function (point) {
                return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
            },
            containsBox: function (box) {
                return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
            },
            getParameter: function (point, target) {
                // This can potentially have a divide by zero if the box
                // has a size dimension of 0.
                if (target === undefined) {
                    console.warn('THREE.Box3: .getParameter() target is now required');
                    target = new Vector3();
                }

                return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
            },
            intersectsBox: function (box) {
                // using 6 splitting planes to rule out intersections.
                return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
            },
            intersectsSphere: function (sphere) {
                // Find the point on the AABB closest to the sphere center.
                this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.

                return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            },
            intersectsPlane: function (plane) {
                // We compute the minimum and maximum dot product values. If those values
                // are on the same side (back or front) of the plane, then there is no intersection.
                var min, max;

                if (plane.normal.x > 0) {
                    min = plane.normal.x * this.min.x;
                    max = plane.normal.x * this.max.x;
                } else {
                    min = plane.normal.x * this.max.x;
                    max = plane.normal.x * this.min.x;
                }

                if (plane.normal.y > 0) {
                    min += plane.normal.y * this.min.y;
                    max += plane.normal.y * this.max.y;
                } else {
                    min += plane.normal.y * this.max.y;
                    max += plane.normal.y * this.min.y;
                }

                if (plane.normal.z > 0) {
                    min += plane.normal.z * this.min.z;
                    max += plane.normal.z * this.max.z;
                } else {
                    min += plane.normal.z * this.max.z;
                    max += plane.normal.z * this.min.z;
                }

                return min <= -plane.constant && max >= -plane.constant;
            },
            intersectsTriangle: function (triangle) {
                if (this.isEmpty()) {
                    return false;
                } // compute box center and extents


                this.getCenter(_center);

                _extents.subVectors(this.max, _center); // translate triangle to aabb origin


                _v0.subVectors(triangle.a, _center);

                _v1.subVectors(triangle.b, _center);

                _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


                _f0.subVectors(_v1, _v0);

                _f1.subVectors(_v2, _v1);

                _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
                // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
                // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


                var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

                if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
                    return false;
                } // test 3 face normals from the aabb


                axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

                if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
                    return false;
                } // finally testing the face normal of the triangle
                // use already existing triangle edge vectors here


                _triangleNormal.crossVectors(_f0, _f1);

                axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
                return satForAxes(axes, _v0, _v1, _v2, _extents);
            },
            clampPoint: function (point, target) {
                if (target === undefined) {
                    console.warn('THREE.Box3: .clampPoint() target is now required');
                    target = new Vector3();
                }

                return target.copy(point).clamp(this.min, this.max);
            },
            distanceToPoint: function (point) {
                var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

                return clampedPoint.sub(point).length();
            },
            getBoundingSphere: function (target) {
                if (target === undefined) {
                    console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
                }

                this.getCenter(target.center);
                target.radius = this.getSize(_vector$1).length() * 0.5;
                return target;
            },
            intersect: function (box) {
                this.min.max(box.min);
                this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

                if (this.isEmpty()) this.makeEmpty();
                return this;
            },
            union: function (box) {
                this.min.min(box.min);
                this.max.max(box.max);
                return this;
            },
            applyMatrix4: function (matrix) {
                // transform of empty box is an empty box.
                if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

                _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


                _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


                _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


                _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


                _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


                _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


                _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


                _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


                this.setFromPoints(_points);
                return this;
            },
            translate: function (offset) {
                this.min.add(offset);
                this.max.add(offset);
                return this;
            },
            equals: function (box) {
                return box.min.equals(this.min) && box.max.equals(this.max);
            }
        });

        function satForAxes(axes, v0, v1, v2, extents) {
            var i, j;

            for (i = 0, j = axes.length - 3; i <= j; i += 3) {
                _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


                var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

                var p0 = v0.dot(_testAxis);
                var p1 = v1.dot(_testAxis);
                var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

                if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                    // points of the projected triangle are outside the projected half-length of the aabb
                    // the axis is seperating and we can exit
                    return false;
                }
            }

            return true;
        }

        var _box$1 = new Box3();
        /**
         * @author bhouston / http://clara.io
         * @author mrdoob / http://mrdoob.com/
         */


        function Sphere(center, radius) {
            this.center = center !== undefined ? center : new Vector3();
            this.radius = radius !== undefined ? radius : 0;
        }

        Object.assign(Sphere.prototype, {
            set: function (center, radius) {
                this.center.copy(center);
                this.radius = radius;
                return this;
            },
            setFromPoints: function (points, optionalCenter) {
                var center = this.center;

                if (optionalCenter !== undefined) {
                    center.copy(optionalCenter);
                } else {
                    _box$1.setFromPoints(points).getCenter(center);
                }

                var maxRadiusSq = 0;

                for (var i = 0, il = points.length; i < il; i++) {
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }

                this.radius = Math.sqrt(maxRadiusSq);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (sphere) {
                this.center.copy(sphere.center);
                this.radius = sphere.radius;
                return this;
            },
            empty: function () {
                return this.radius <= 0;
            },
            containsPoint: function (point) {
                return point.distanceToSquared(this.center) <= this.radius * this.radius;
            },
            distanceToPoint: function (point) {
                return point.distanceTo(this.center) - this.radius;
            },
            intersectsSphere: function (sphere) {
                var radiusSum = this.radius + sphere.radius;
                return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
            },
            intersectsBox: function (box) {
                return box.intersectsSphere(this);
            },
            intersectsPlane: function (plane) {
                return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
            },
            clampPoint: function (point, target) {
                var deltaLengthSq = this.center.distanceToSquared(point);

                if (target === undefined) {
                    console.warn('THREE.Sphere: .clampPoint() target is now required');
                    target = new Vector3();
                }

                target.copy(point);

                if (deltaLengthSq > this.radius * this.radius) {
                    target.sub(this.center).normalize();
                    target.multiplyScalar(this.radius).add(this.center);
                }

                return target;
            },
            getBoundingBox: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Sphere: .getBoundingBox() target is now required');
                    target = new Box3();
                }

                target.set(this.center, this.center);
                target.expandByScalar(this.radius);
                return target;
            },
            applyMatrix4: function (matrix) {
                this.center.applyMatrix4(matrix);
                this.radius = this.radius * matrix.getMaxScaleOnAxis();
                return this;
            },
            translate: function (offset) {
                this.center.add(offset);
                return this;
            },
            equals: function (sphere) {
                return sphere.center.equals(this.center) && sphere.radius === this.radius;
            }
        });

        /**
         * @author bhouston / http://clara.io
         */

        var _vector1 = new Vector3();

        var _vector2 = new Vector3();

        var _normalMatrix = new Matrix3();

        function Plane(normal, constant) {
            // normal is assumed to be normalized
            this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
            this.constant = constant !== undefined ? constant : 0;
        }

        Object.assign(Plane.prototype, {
            isPlane: true,
            set: function (normal, constant) {
                this.normal.copy(normal);
                this.constant = constant;
                return this;
            },
            setComponents: function (x, y, z, w) {
                this.normal.set(x, y, z);
                this.constant = w;
                return this;
            },
            setFromNormalAndCoplanarPoint: function (normal, point) {
                this.normal.copy(normal);
                this.constant = -point.dot(this.normal);
                return this;
            },
            setFromCoplanarPoints: function (a, b, c) {
                var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (plane) {
                this.normal.copy(plane.normal);
                this.constant = plane.constant;
                return this;
            },
            normalize: function () {
                // Note: will lead to a divide by zero if the plane is invalid.
                var inverseNormalLength = 1.0 / this.normal.length();
                this.normal.multiplyScalar(inverseNormalLength);
                this.constant *= inverseNormalLength;
                return this;
            },
            negate: function () {
                this.constant *= -1;
                this.normal.negate();
                return this;
            },
            distanceToPoint: function (point) {
                return this.normal.dot(point) + this.constant;
            },
            distanceToSphere: function (sphere) {
                return this.distanceToPoint(sphere.center) - sphere.radius;
            },
            projectPoint: function (point, target) {
                if (target === undefined) {
                    console.warn('THREE.Plane: .projectPoint() target is now required');
                    target = new Vector3();
                }

                return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
            },
            intersectLine: function (line, target) {
                if (target === undefined) {
                    console.warn('THREE.Plane: .intersectLine() target is now required');
                    target = new Vector3();
                }

                var direction = line.delta(_vector1);
                var denominator = this.normal.dot(direction);

                if (denominator === 0) {
                    // line is coplanar, return origin
                    if (this.distanceToPoint(line.start) === 0) {
                        return target.copy(line.start);
                    } // Unsure if this is the correct method to handle this case.


                    return undefined;
                }

                var t = -(line.start.dot(this.normal) + this.constant) / denominator;

                if (t < 0 || t > 1) {
                    return undefined;
                }

                return target.copy(direction).multiplyScalar(t).add(line.start);
            },
            intersectsLine: function (line) {
                // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
                var startSign = this.distanceToPoint(line.start);
                var endSign = this.distanceToPoint(line.end);
                return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
            },
            intersectsBox: function (box) {
                return box.intersectsPlane(this);
            },
            intersectsSphere: function (sphere) {
                return sphere.intersectsPlane(this);
            },
            coplanarPoint: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Plane: .coplanarPoint() target is now required');
                    target = new Vector3();
                }

                return target.copy(this.normal).multiplyScalar(-this.constant);
            },
            applyMatrix4: function (matrix, optionalNormalMatrix) {
                var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

                var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
            },
            translate: function (offset) {
                this.constant -= offset.dot(this.normal);
                return this;
            },
            equals: function (plane) {
                return plane.normal.equals(this.normal) && plane.constant === this.constant;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author bhouston / http://clara.io
         */

        var _sphere = new Sphere();

        var _vector$2 = new Vector3();

        function Frustum(p0, p1, p2, p3, p4, p5) {
            this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
        }

        Object.assign(Frustum.prototype, {
            set: function (p0, p1, p2, p3, p4, p5) {
                var planes = this.planes;
                planes[0].copy(p0);
                planes[1].copy(p1);
                planes[2].copy(p2);
                planes[3].copy(p3);
                planes[4].copy(p4);
                planes[5].copy(p5);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (frustum) {
                var planes = this.planes;

                for (var i = 0; i < 6; i++) {
                    planes[i].copy(frustum.planes[i]);
                }

                return this;
            },
            setFromProjectionMatrix: function (m) {
                var planes = this.planes;
                var me = m.elements;
                var me0 = me[0],
                    me1 = me[1],
                    me2 = me[2],
                    me3 = me[3];
                var me4 = me[4],
                    me5 = me[5],
                    me6 = me[6],
                    me7 = me[7];
                var me8 = me[8],
                    me9 = me[9],
                    me10 = me[10],
                    me11 = me[11];
                var me12 = me[12],
                    me13 = me[13],
                    me14 = me[14],
                    me15 = me[15];
                planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
                return this;
            },
            intersectsObject: function (object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

                return this.intersectsSphere(_sphere);
            },
            intersectsSprite: function (sprite) {
                _sphere.center.set(0, 0, 0);

                _sphere.radius = 0.7071067811865476;

                _sphere.applyMatrix4(sprite.matrixWorld);

                return this.intersectsSphere(_sphere);
            },
            intersectsSphere: function (sphere) {
                var planes = this.planes;
                var center = sphere.center;
                var negRadius = -sphere.radius;

                for (var i = 0; i < 6; i++) {
                    var distance = planes[i].distanceToPoint(center);

                    if (distance < negRadius) {
                        return false;
                    }
                }

                return true;
            },
            intersectsBox: function (box) {
                var planes = this.planes;

                for (var i = 0; i < 6; i++) {
                    var plane = planes[i]; // corner at max distance

                    _vector$2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    _vector$2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    _vector$2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                    if (plane.distanceToPoint(_vector$2) < 0) {
                        return false;
                    }
                }

                return true;
            },
            containsPoint: function (point) {
                var planes = this.planes;

                for (var i = 0; i < 6; i++) {
                    if (planes[i].distanceToPoint(point) < 0) {
                        return false;
                    }
                }

                return true;
            }
        });

        var _v1$1 = new Vector3();

        var _m1 = new Matrix4();

        var _zero = new Vector3(0, 0, 0);

        var _one = new Vector3(1, 1, 1);

        var _x = new Vector3();

        var _y = new Vector3();

        var _z = new Vector3();
        /**
         * @author mrdoob / http://mrdoob.com/
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author philogb / http://blog.thejit.org/
         * @author jordi_ros / http://plattsoft.com
         * @author D1plo1d / http://github.com/D1plo1d
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author timknip / http://www.floorplanner.com/
         * @author bhouston / http://clara.io
         * @author WestLangley / http://github.com/WestLangley
         */


        function Matrix4() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

            if (arguments.length > 0) {
                console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
            }
        }

        Object.assign(Matrix4.prototype, {
            isMatrix4: true,
            set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                var te = this.elements;
                te[0] = n11;
                te[4] = n12;
                te[8] = n13;
                te[12] = n14;
                te[1] = n21;
                te[5] = n22;
                te[9] = n23;
                te[13] = n24;
                te[2] = n31;
                te[6] = n32;
                te[10] = n33;
                te[14] = n34;
                te[3] = n41;
                te[7] = n42;
                te[11] = n43;
                te[15] = n44;
                return this;
            },
            identity: function () {
                this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return this;
            },
            clone: function () {
                return new Matrix4().fromArray(this.elements);
            },
            copy: function (m) {
                var te = this.elements;
                var me = m.elements;
                te[0] = me[0];
                te[1] = me[1];
                te[2] = me[2];
                te[3] = me[3];
                te[4] = me[4];
                te[5] = me[5];
                te[6] = me[6];
                te[7] = me[7];
                te[8] = me[8];
                te[9] = me[9];
                te[10] = me[10];
                te[11] = me[11];
                te[12] = me[12];
                te[13] = me[13];
                te[14] = me[14];
                te[15] = me[15];
                return this;
            },
            copyPosition: function (m) {
                var te = this.elements,
                    me = m.elements;
                te[12] = me[12];
                te[13] = me[13];
                te[14] = me[14];
                return this;
            },
            extractBasis: function (xAxis, yAxis, zAxis) {
                xAxis.setFromMatrixColumn(this, 0);
                yAxis.setFromMatrixColumn(this, 1);
                zAxis.setFromMatrixColumn(this, 2);
                return this;
            },
            makeBasis: function (xAxis, yAxis, zAxis) {
                this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
                return this;
            },
            extractRotation: function (m) {
                // this method does not support reflection matrices
                var te = this.elements;
                var me = m.elements;

                var scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();

                var scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();

                var scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();

                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[3] = 0;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[7] = 0;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                te[11] = 0;
                te[12] = 0;
                te[13] = 0;
                te[14] = 0;
                te[15] = 1;
                return this;
            },
            makeRotationFromEuler: function (euler) {
                if (!(euler && euler.isEuler)) {
                    console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
                }

                var te = this.elements;
                var x = euler.x,
                    y = euler.y,
                    z = euler.z;
                var a = Math.cos(x),
                    b = Math.sin(x);
                var c = Math.cos(y),
                    d = Math.sin(y);
                var e = Math.cos(z),
                    f = Math.sin(z);

                if (euler.order === 'XYZ') {
                    var ae = a * e,
                        af = a * f,
                        be = b * e,
                        bf = b * f;
                    te[0] = c * e;
                    te[4] = -c * f;
                    te[8] = d;
                    te[1] = af + be * d;
                    te[5] = ae - bf * d;
                    te[9] = -b * c;
                    te[2] = bf - ae * d;
                    te[6] = be + af * d;
                    te[10] = a * c;
                } else if (euler.order === 'YXZ') {
                    var ce = c * e,
                        cf = c * f,
                        de = d * e,
                        df = d * f;
                    te[0] = ce + df * b;
                    te[4] = de * b - cf;
                    te[8] = a * d;
                    te[1] = a * f;
                    te[5] = a * e;
                    te[9] = -b;
                    te[2] = cf * b - de;
                    te[6] = df + ce * b;
                    te[10] = a * c;
                } else if (euler.order === 'ZXY') {
                    var ce = c * e,
                        cf = c * f,
                        de = d * e,
                        df = d * f;
                    te[0] = ce - df * b;
                    te[4] = -a * f;
                    te[8] = de + cf * b;
                    te[1] = cf + de * b;
                    te[5] = a * e;
                    te[9] = df - ce * b;
                    te[2] = -a * d;
                    te[6] = b;
                    te[10] = a * c;
                } else if (euler.order === 'ZYX') {
                    var ae = a * e,
                        af = a * f,
                        be = b * e,
                        bf = b * f;
                    te[0] = c * e;
                    te[4] = be * d - af;
                    te[8] = ae * d + bf;
                    te[1] = c * f;
                    te[5] = bf * d + ae;
                    te[9] = af * d - be;
                    te[2] = -d;
                    te[6] = b * c;
                    te[10] = a * c;
                } else if (euler.order === 'YZX') {
                    var ac = a * c,
                        ad = a * d,
                        bc = b * c,
                        bd = b * d;
                    te[0] = c * e;
                    te[4] = bd - ac * f;
                    te[8] = bc * f + ad;
                    te[1] = f;
                    te[5] = a * e;
                    te[9] = -b * e;
                    te[2] = -d * e;
                    te[6] = ad * f + bc;
                    te[10] = ac - bd * f;
                } else if (euler.order === 'XZY') {
                    var ac = a * c,
                        ad = a * d,
                        bc = b * c,
                        bd = b * d;
                    te[0] = c * e;
                    te[4] = -f;
                    te[8] = d * e;
                    te[1] = ac * f + bd;
                    te[5] = a * e;
                    te[9] = ad * f - bc;
                    te[2] = bc * f - ad;
                    te[6] = b * e;
                    te[10] = bd * f + ac;
                } // bottom row


                te[3] = 0;
                te[7] = 0;
                te[11] = 0; // last column

                te[12] = 0;
                te[13] = 0;
                te[14] = 0;
                te[15] = 1;
                return this;
            },
            makeRotationFromQuaternion: function (q) {
                return this.compose(_zero, q, _one);
            },
            lookAt: function (eye, target, up) {
                var te = this.elements;

                _z.subVectors(eye, target);

                if (_z.lengthSq() === 0) {
                    // eye and target are in the same position
                    _z.z = 1;
                }

                _z.normalize();

                _x.crossVectors(up, _z);

                if (_x.lengthSq() === 0) {
                    // up and z are parallel
                    if (Math.abs(up.z) === 1) {
                        _z.x += 0.0001;
                    } else {
                        _z.z += 0.0001;
                    }

                    _z.normalize();

                    _x.crossVectors(up, _z);
                }

                _x.normalize();

                _y.crossVectors(_z, _x);

                te[0] = _x.x;
                te[4] = _y.x;
                te[8] = _z.x;
                te[1] = _x.y;
                te[5] = _y.y;
                te[9] = _z.y;
                te[2] = _x.z;
                te[6] = _y.z;
                te[10] = _z.z;
                return this;
            },
            multiply: function (m, n) {
                if (n !== undefined) {
                    console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                    return this.multiplyMatrices(m, n);
                }

                return this.multiplyMatrices(this, m);
            },
            premultiply: function (m) {
                return this.multiplyMatrices(m, this);
            },
            multiplyMatrices: function (a, b) {
                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;
                var a11 = ae[0],
                    a12 = ae[4],
                    a13 = ae[8],
                    a14 = ae[12];
                var a21 = ae[1],
                    a22 = ae[5],
                    a23 = ae[9],
                    a24 = ae[13];
                var a31 = ae[2],
                    a32 = ae[6],
                    a33 = ae[10],
                    a34 = ae[14];
                var a41 = ae[3],
                    a42 = ae[7],
                    a43 = ae[11],
                    a44 = ae[15];
                var b11 = be[0],
                    b12 = be[4],
                    b13 = be[8],
                    b14 = be[12];
                var b21 = be[1],
                    b22 = be[5],
                    b23 = be[9],
                    b24 = be[13];
                var b31 = be[2],
                    b32 = be[6],
                    b33 = be[10],
                    b34 = be[14];
                var b41 = be[3],
                    b42 = be[7],
                    b43 = be[11],
                    b44 = be[15];
                te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                return this;
            },
            multiplyScalar: function (s) {
                var te = this.elements;
                te[0] *= s;
                te[4] *= s;
                te[8] *= s;
                te[12] *= s;
                te[1] *= s;
                te[5] *= s;
                te[9] *= s;
                te[13] *= s;
                te[2] *= s;
                te[6] *= s;
                te[10] *= s;
                te[14] *= s;
                te[3] *= s;
                te[7] *= s;
                te[11] *= s;
                te[15] *= s;
                return this;
            },
            determinant: function () {
                var te = this.elements;
                var n11 = te[0],
                    n12 = te[4],
                    n13 = te[8],
                    n14 = te[12];
                var n21 = te[1],
                    n22 = te[5],
                    n23 = te[9],
                    n24 = te[13];
                var n31 = te[2],
                    n32 = te[6],
                    n33 = te[10],
                    n34 = te[14];
                var n41 = te[3],
                    n42 = te[7],
                    n43 = te[11],
                    n44 = te[15]; //TODO: make this more efficient
                //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

                return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
            },
            transpose: function () {
                var te = this.elements;
                var tmp;
                tmp = te[1];
                te[1] = te[4];
                te[4] = tmp;
                tmp = te[2];
                te[2] = te[8];
                te[8] = tmp;
                tmp = te[6];
                te[6] = te[9];
                te[9] = tmp;
                tmp = te[3];
                te[3] = te[12];
                te[12] = tmp;
                tmp = te[7];
                te[7] = te[13];
                te[13] = tmp;
                tmp = te[11];
                te[11] = te[14];
                te[14] = tmp;
                return this;
            },
            setPosition: function (x, y, z) {
                var te = this.elements;

                if (x.isVector3) {
                    te[12] = x.x;
                    te[13] = x.y;
                    te[14] = x.z;
                } else {
                    te[12] = x;
                    te[13] = y;
                    te[14] = z;
                }

                return this;
            },
            getInverse: function (m, throwOnDegenerate) {
                // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
                var te = this.elements,
                    me = m.elements,
                    n11 = me[0],
                    n21 = me[1],
                    n31 = me[2],
                    n41 = me[3],
                    n12 = me[4],
                    n22 = me[5],
                    n32 = me[6],
                    n42 = me[7],
                    n13 = me[8],
                    n23 = me[9],
                    n33 = me[10],
                    n43 = me[11],
                    n14 = me[12],
                    n24 = me[13],
                    n34 = me[14],
                    n44 = me[15],
                    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

                if (det === 0) {
                    var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

                    if (throwOnDegenerate === true) {
                        throw new Error(msg);
                    } else {
                        console.warn(msg);
                    }

                    return this.identity();
                }

                var detInv = 1 / det;
                te[0] = t11 * detInv;
                te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
                te[4] = t12 * detInv;
                te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
                te[8] = t13 * detInv;
                te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
                te[12] = t14 * detInv;
                te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
                return this;
            },
            scale: function (v) {
                var te = this.elements;
                var x = v.x,
                    y = v.y,
                    z = v.z;
                te[0] *= x;
                te[4] *= y;
                te[8] *= z;
                te[1] *= x;
                te[5] *= y;
                te[9] *= z;
                te[2] *= x;
                te[6] *= y;
                te[10] *= z;
                te[3] *= x;
                te[7] *= y;
                te[11] *= z;
                return this;
            },
            getMaxScaleOnAxis: function () {
                var te = this.elements;
                var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            },
            makeTranslation: function (x, y, z) {
                this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
                return this;
            },
            makeRotationX: function (theta) {
                var c = Math.cos(theta),
                    s = Math.sin(theta);
                this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
                return this;
            },
            makeRotationY: function (theta) {
                var c = Math.cos(theta),
                    s = Math.sin(theta);
                this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
                return this;
            },
            makeRotationZ: function (theta) {
                var c = Math.cos(theta),
                    s = Math.sin(theta);
                this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return this;
            },
            makeRotationAxis: function (axis, angle) {
                // Based on http://www.gamedev.net/reference/articles/article1199.asp
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                var t = 1 - c;
                var x = axis.x,
                    y = axis.y,
                    z = axis.z;
                var tx = t * x,
                    ty = t * y;
                this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
                return this;
            },
            makeScale: function (x, y, z) {
                this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
                return this;
            },
            makeShear: function (x, y, z) {
                this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
                return this;
            },
            compose: function (position, quaternion, scale) {
                var te = this.elements;
                var x = quaternion._x,
                    y = quaternion._y,
                    z = quaternion._z,
                    w = quaternion._w;
                var x2 = x + x,
                    y2 = y + y,
                    z2 = z + z;
                var xx = x * x2,
                    xy = x * y2,
                    xz = x * z2;
                var yy = y * y2,
                    yz = y * z2,
                    zz = z * z2;
                var wx = w * x2,
                    wy = w * y2,
                    wz = w * z2;
                var sx = scale.x,
                    sy = scale.y,
                    sz = scale.z;
                te[0] = (1 - (yy + zz)) * sx;
                te[1] = (xy + wz) * sx;
                te[2] = (xz - wy) * sx;
                te[3] = 0;
                te[4] = (xy - wz) * sy;
                te[5] = (1 - (xx + zz)) * sy;
                te[6] = (yz + wx) * sy;
                te[7] = 0;
                te[8] = (xz + wy) * sz;
                te[9] = (yz - wx) * sz;
                te[10] = (1 - (xx + yy)) * sz;
                te[11] = 0;
                te[12] = position.x;
                te[13] = position.y;
                te[14] = position.z;
                te[15] = 1;
                return this;
            },
            decompose: function (position, quaternion, scale) {
                var te = this.elements;

                var sx = _v1$1.set(te[0], te[1], te[2]).length();

                var sy = _v1$1.set(te[4], te[5], te[6]).length();

                var sz = _v1$1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


                var det = this.determinant();
                if (det < 0) sx = -sx;
                position.x = te[12];
                position.y = te[13];
                position.z = te[14]; // scale the rotation part

                _m1.copy(this);

                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                _m1.elements[0] *= invSX;
                _m1.elements[1] *= invSX;
                _m1.elements[2] *= invSX;
                _m1.elements[4] *= invSY;
                _m1.elements[5] *= invSY;
                _m1.elements[6] *= invSY;
                _m1.elements[8] *= invSZ;
                _m1.elements[9] *= invSZ;
                _m1.elements[10] *= invSZ;
                quaternion.setFromRotationMatrix(_m1);
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
            },
            makePerspective: function (left, right, top, bottom, near, far) {
                if (far === undefined) {
                    console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
                }

                var te = this.elements;
                var x = 2 * near / (right - left);
                var y = 2 * near / (top - bottom);
                var a = (right + left) / (right - left);
                var b = (top + bottom) / (top - bottom);
                var c = -(far + near) / (far - near);
                var d = -2 * far * near / (far - near);
                te[0] = x;
                te[4] = 0;
                te[8] = a;
                te[12] = 0;
                te[1] = 0;
                te[5] = y;
                te[9] = b;
                te[13] = 0;
                te[2] = 0;
                te[6] = 0;
                te[10] = c;
                te[14] = d;
                te[3] = 0;
                te[7] = 0;
                te[11] = -1;
                te[15] = 0;
                return this;
            },
            makeOrthographic: function (left, right, top, bottom, near, far) {
                var te = this.elements;
                var w = 1.0 / (right - left);
                var h = 1.0 / (top - bottom);
                var p = 1.0 / (far - near);
                var x = (right + left) * w;
                var y = (top + bottom) * h;
                var z = (far + near) * p;
                te[0] = 2 * w;
                te[4] = 0;
                te[8] = 0;
                te[12] = -x;
                te[1] = 0;
                te[5] = 2 * h;
                te[9] = 0;
                te[13] = -y;
                te[2] = 0;
                te[6] = 0;
                te[10] = -2 * p;
                te[14] = -z;
                te[3] = 0;
                te[7] = 0;
                te[11] = 0;
                te[15] = 1;
                return this;
            },
            equals: function (matrix) {
                var te = this.elements;
                var me = matrix.elements;

                for (var i = 0; i < 16; i++) {
                    if (te[i] !== me[i]) return false;
                }

                return true;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;

                for (var i = 0; i < 16; i++) {
                    this.elements[i] = array[i + offset];
                }

                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                var te = this.elements;
                array[offset] = te[0];
                array[offset + 1] = te[1];
                array[offset + 2] = te[2];
                array[offset + 3] = te[3];
                array[offset + 4] = te[4];
                array[offset + 5] = te[5];
                array[offset + 6] = te[6];
                array[offset + 7] = te[7];
                array[offset + 8] = te[8];
                array[offset + 9] = te[9];
                array[offset + 10] = te[10];
                array[offset + 11] = te[11];
                array[offset + 12] = te[12];
                array[offset + 13] = te[13];
                array[offset + 14] = te[14];
                array[offset + 15] = te[15];
                return array;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var _colorKeywords = {
            'aliceblue': 0xF0F8FF,
            'antiquewhite': 0xFAEBD7,
            'aqua': 0x00FFFF,
            'aquamarine': 0x7FFFD4,
            'azure': 0xF0FFFF,
            'beige': 0xF5F5DC,
            'bisque': 0xFFE4C4,
            'black': 0x000000,
            'blanchedalmond': 0xFFEBCD,
            'blue': 0x0000FF,
            'blueviolet': 0x8A2BE2,
            'brown': 0xA52A2A,
            'burlywood': 0xDEB887,
            'cadetblue': 0x5F9EA0,
            'chartreuse': 0x7FFF00,
            'chocolate': 0xD2691E,
            'coral': 0xFF7F50,
            'cornflowerblue': 0x6495ED,
            'cornsilk': 0xFFF8DC,
            'crimson': 0xDC143C,
            'cyan': 0x00FFFF,
            'darkblue': 0x00008B,
            'darkcyan': 0x008B8B,
            'darkgoldenrod': 0xB8860B,
            'darkgray': 0xA9A9A9,
            'darkgreen': 0x006400,
            'darkgrey': 0xA9A9A9,
            'darkkhaki': 0xBDB76B,
            'darkmagenta': 0x8B008B,
            'darkolivegreen': 0x556B2F,
            'darkorange': 0xFF8C00,
            'darkorchid': 0x9932CC,
            'darkred': 0x8B0000,
            'darksalmon': 0xE9967A,
            'darkseagreen': 0x8FBC8F,
            'darkslateblue': 0x483D8B,
            'darkslategray': 0x2F4F4F,
            'darkslategrey': 0x2F4F4F,
            'darkturquoise': 0x00CED1,
            'darkviolet': 0x9400D3,
            'deeppink': 0xFF1493,
            'deepskyblue': 0x00BFFF,
            'dimgray': 0x696969,
            'dimgrey': 0x696969,
            'dodgerblue': 0x1E90FF,
            'firebrick': 0xB22222,
            'floralwhite': 0xFFFAF0,
            'forestgreen': 0x228B22,
            'fuchsia': 0xFF00FF,
            'gainsboro': 0xDCDCDC,
            'ghostwhite': 0xF8F8FF,
            'gold': 0xFFD700,
            'goldenrod': 0xDAA520,
            'gray': 0x808080,
            'green': 0x008000,
            'greenyellow': 0xADFF2F,
            'grey': 0x808080,
            'honeydew': 0xF0FFF0,
            'hotpink': 0xFF69B4,
            'indianred': 0xCD5C5C,
            'indigo': 0x4B0082,
            'ivory': 0xFFFFF0,
            'khaki': 0xF0E68C,
            'lavender': 0xE6E6FA,
            'lavenderblush': 0xFFF0F5,
            'lawngreen': 0x7CFC00,
            'lemonchiffon': 0xFFFACD,
            'lightblue': 0xADD8E6,
            'lightcoral': 0xF08080,
            'lightcyan': 0xE0FFFF,
            'lightgoldenrodyellow': 0xFAFAD2,
            'lightgray': 0xD3D3D3,
            'lightgreen': 0x90EE90,
            'lightgrey': 0xD3D3D3,
            'lightpink': 0xFFB6C1,
            'lightsalmon': 0xFFA07A,
            'lightseagreen': 0x20B2AA,
            'lightskyblue': 0x87CEFA,
            'lightslategray': 0x778899,
            'lightslategrey': 0x778899,
            'lightsteelblue': 0xB0C4DE,
            'lightyellow': 0xFFFFE0,
            'lime': 0x00FF00,
            'limegreen': 0x32CD32,
            'linen': 0xFAF0E6,
            'magenta': 0xFF00FF,
            'maroon': 0x800000,
            'mediumaquamarine': 0x66CDAA,
            'mediumblue': 0x0000CD,
            'mediumorchid': 0xBA55D3,
            'mediumpurple': 0x9370DB,
            'mediumseagreen': 0x3CB371,
            'mediumslateblue': 0x7B68EE,
            'mediumspringgreen': 0x00FA9A,
            'mediumturquoise': 0x48D1CC,
            'mediumvioletred': 0xC71585,
            'midnightblue': 0x191970,
            'mintcream': 0xF5FFFA,
            'mistyrose': 0xFFE4E1,
            'moccasin': 0xFFE4B5,
            'navajowhite': 0xFFDEAD,
            'navy': 0x000080,
            'oldlace': 0xFDF5E6,
            'olive': 0x808000,
            'olivedrab': 0x6B8E23,
            'orange': 0xFFA500,
            'orangered': 0xFF4500,
            'orchid': 0xDA70D6,
            'palegoldenrod': 0xEEE8AA,
            'palegreen': 0x98FB98,
            'paleturquoise': 0xAFEEEE,
            'palevioletred': 0xDB7093,
            'papayawhip': 0xFFEFD5,
            'peachpuff': 0xFFDAB9,
            'peru': 0xCD853F,
            'pink': 0xFFC0CB,
            'plum': 0xDDA0DD,
            'powderblue': 0xB0E0E6,
            'purple': 0x800080,
            'rebeccapurple': 0x663399,
            'red': 0xFF0000,
            'rosybrown': 0xBC8F8F,
            'royalblue': 0x4169E1,
            'saddlebrown': 0x8B4513,
            'salmon': 0xFA8072,
            'sandybrown': 0xF4A460,
            'seagreen': 0x2E8B57,
            'seashell': 0xFFF5EE,
            'sienna': 0xA0522D,
            'silver': 0xC0C0C0,
            'skyblue': 0x87CEEB,
            'slateblue': 0x6A5ACD,
            'slategray': 0x708090,
            'slategrey': 0x708090,
            'snow': 0xFFFAFA,
            'springgreen': 0x00FF7F,
            'steelblue': 0x4682B4,
            'tan': 0xD2B48C,
            'teal': 0x008080,
            'thistle': 0xD8BFD8,
            'tomato': 0xFF6347,
            'turquoise': 0x40E0D0,
            'violet': 0xEE82EE,
            'wheat': 0xF5DEB3,
            'white': 0xFFFFFF,
            'whitesmoke': 0xF5F5F5,
            'yellow': 0xFFFF00,
            'yellowgreen': 0x9ACD32
        };
        var _hslA = {
            h: 0,
            s: 0,
            l: 0
        };
        var _hslB = {
            h: 0,
            s: 0,
            l: 0
        };

        function Color(r, g, b) {
            if (g === undefined && b === undefined) {
                // r is THREE.Color, hex or string
                return this.set(r);
            }

            return this.setRGB(r, g, b);
        }

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        }

        function SRGBToLinear(c) {
            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
        }

        function LinearToSRGB(c) {
            return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
        }

        Object.assign(Color.prototype, {
            isColor: true,
            r: 1,
            g: 1,
            b: 1,
            set: function (value) {
                if (value && value.isColor) {
                    this.copy(value);
                } else if (typeof value === 'number') {
                    this.setHex(value);
                } else if (typeof value === 'string') {
                    this.setStyle(value);
                }

                return this;
            },
            setScalar: function (scalar) {
                this.r = scalar;
                this.g = scalar;
                this.b = scalar;
                return this;
            },
            setHex: function (hex) {
                hex = Math.floor(hex);
                this.r = (hex >> 16 & 255) / 255;
                this.g = (hex >> 8 & 255) / 255;
                this.b = (hex & 255) / 255;
                return this;
            },
            setRGB: function (r, g, b) {
                this.r = r;
                this.g = g;
                this.b = b;
                return this;
            },
            setHSL: function (h, s, l) {
                // h,s,l ranges are in 0.0 - 1.0
                h = MathUtils.euclideanModulo(h, 1);
                s = MathUtils.clamp(s, 0, 1);
                l = MathUtils.clamp(l, 0, 1);

                if (s === 0) {
                    this.r = this.g = this.b = l;
                } else {
                    var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                    var q = 2 * l - p;
                    this.r = hue2rgb(q, p, h + 1 / 3);
                    this.g = hue2rgb(q, p, h);
                    this.b = hue2rgb(q, p, h - 1 / 3);
                }

                return this;
            },
            setStyle: function (style) {
                function handleAlpha(string) {
                    if (string === undefined) return;

                    if (parseFloat(string) < 1) {
                        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                    }
                }

                var m;

                if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                    // rgb / hsl
                    var color;
                    var name = m[1];
                    var components = m[2];

                    switch (name) {
                        case 'rgb':
                        case 'rgba':
                            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                // rgb(255,0,0) rgba(255,0,0,0.5)
                                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                                handleAlpha(color[5]);
                                return this;
                            }

                            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                                handleAlpha(color[5]);
                                return this;
                            }

                            break;

                        case 'hsl':
                        case 'hsla':
                            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                                var h = parseFloat(color[1]) / 360;
                                var s = parseInt(color[2], 10) / 100;
                                var l = parseInt(color[3], 10) / 100;
                                handleAlpha(color[5]);
                                return this.setHSL(h, s, l);
                            }

                            break;
                    }
                } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                    // hex color
                    var hex = m[1];
                    var size = hex.length;

                    if (size === 3) {
                        // #ff0
                        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                        return this;
                    } else if (size === 6) {
                        // #ff0000
                        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                        return this;
                    }
                }

                if (style && style.length > 0) {
                    return this.setColorName(style);
                }

                return this;
            },
            setColorName: function (style) {
                // color keywords
                var hex = _colorKeywords[style];

                if (hex !== undefined) {
                    // red
                    this.setHex(hex);
                } else {
                    // unknown color
                    console.warn('THREE.Color: Unknown color ' + style);
                }

                return this;
            },
            clone: function () {
                return new this.constructor(this.r, this.g, this.b);
            },
            copy: function (color) {
                this.r = color.r;
                this.g = color.g;
                this.b = color.b;
                return this;
            },
            copyGammaToLinear: function (color, gammaFactor) {
                if (gammaFactor === undefined) gammaFactor = 2.0;
                this.r = Math.pow(color.r, gammaFactor);
                this.g = Math.pow(color.g, gammaFactor);
                this.b = Math.pow(color.b, gammaFactor);
                return this;
            },
            copyLinearToGamma: function (color, gammaFactor) {
                if (gammaFactor === undefined) gammaFactor = 2.0;
                var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
                this.r = Math.pow(color.r, safeInverse);
                this.g = Math.pow(color.g, safeInverse);
                this.b = Math.pow(color.b, safeInverse);
                return this;
            },
            convertGammaToLinear: function (gammaFactor) {
                this.copyGammaToLinear(this, gammaFactor);
                return this;
            },
            convertLinearToGamma: function (gammaFactor) {
                this.copyLinearToGamma(this, gammaFactor);
                return this;
            },
            copySRGBToLinear: function (color) {
                this.r = SRGBToLinear(color.r);
                this.g = SRGBToLinear(color.g);
                this.b = SRGBToLinear(color.b);
                return this;
            },
            copyLinearToSRGB: function (color) {
                this.r = LinearToSRGB(color.r);
                this.g = LinearToSRGB(color.g);
                this.b = LinearToSRGB(color.b);
                return this;
            },
            convertSRGBToLinear: function () {
                this.copySRGBToLinear(this);
                return this;
            },
            convertLinearToSRGB: function () {
                this.copyLinearToSRGB(this);
                return this;
            },
            getHex: function () {
                return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
            },
            getHexString: function () {
                return ('000000' + this.getHex().toString(16)).slice(-6);
            },
            getHSL: function (target) {
                // h,s,l ranges are in 0.0 - 1.0
                if (target === undefined) {
                    console.warn('THREE.Color: .getHSL() target is now required');
                    target = {
                        h: 0,
                        s: 0,
                        l: 0
                    };
                }

                var r = this.r,
                    g = this.g,
                    b = this.b;
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var hue, saturation;
                var lightness = (min + max) / 2.0;

                if (min === max) {
                    hue = 0;
                    saturation = 0;
                } else {
                    var delta = max - min;
                    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

                    switch (max) {
                        case r:
                            hue = (g - b) / delta + (g < b ? 6 : 0);
                            break;

                        case g:
                            hue = (b - r) / delta + 2;
                            break;

                        case b:
                            hue = (r - g) / delta + 4;
                            break;
                    }

                    hue /= 6;
                }

                target.h = hue;
                target.s = saturation;
                target.l = lightness;
                return target;
            },
            getStyle: function () {
                return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
            },
            offsetHSL: function (h, s, l) {
                this.getHSL(_hslA);
                _hslA.h += h;
                _hslA.s += s;
                _hslA.l += l;
                this.setHSL(_hslA.h, _hslA.s, _hslA.l);
                return this;
            },
            add: function (color) {
                this.r += color.r;
                this.g += color.g;
                this.b += color.b;
                return this;
            },
            addColors: function (color1, color2) {
                this.r = color1.r + color2.r;
                this.g = color1.g + color2.g;
                this.b = color1.b + color2.b;
                return this;
            },
            addScalar: function (s) {
                this.r += s;
                this.g += s;
                this.b += s;
                return this;
            },
            sub: function (color) {
                this.r = Math.max(0, this.r - color.r);
                this.g = Math.max(0, this.g - color.g);
                this.b = Math.max(0, this.b - color.b);
                return this;
            },
            multiply: function (color) {
                this.r *= color.r;
                this.g *= color.g;
                this.b *= color.b;
                return this;
            },
            multiplyScalar: function (s) {
                this.r *= s;
                this.g *= s;
                this.b *= s;
                return this;
            },
            lerp: function (color, alpha) {
                this.r += (color.r - this.r) * alpha;
                this.g += (color.g - this.g) * alpha;
                this.b += (color.b - this.b) * alpha;
                return this;
            },
            lerpHSL: function (color, alpha) {
                this.getHSL(_hslA);
                color.getHSL(_hslB);
                var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
                var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
                var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
                this.setHSL(h, s, l);
                return this;
            },
            equals: function (c) {
                return c.r === this.r && c.g === this.g && c.b === this.b;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;
                this.r = array[offset];
                this.g = array[offset + 1];
                this.b = array[offset + 2];
                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this.r;
                array[offset + 1] = this.g;
                array[offset + 2] = this.b;
                return array;
            },
            toJSON: function () {
                return this.getHex();
            }
        });
        Color.NAMES = _colorKeywords;

        /**
         * Uniforms library for shared webgl shaders
         */

        var UniformsLib = {
            common: {
                diffuse: {
                    value: new Color(0xeeeeee)
                },
                opacity: {
                    value: 1.0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Matrix3()
                },
                uv2Transform: {
                    value: new Matrix3()
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1.0
                },
                refractionRatio: {
                    value: 0.98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new Vector2(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 0.00025
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2000
                },
                fogColor: {
                    value: new Color(0xffffff)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new Color(0xeeeeee)
                },
                opacity: {
                    value: 1.0
                },
                size: {
                    value: 1.0
                },
                scale: {
                    value: 1.0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Matrix3()
                }
            },
            sprite: {
                diffuse: {
                    value: new Color(0xeeeeee)
                },
                opacity: {
                    value: 1.0
                },
                center: {
                    value: new Vector2(0.5, 0.5)
                },
                rotation: {
                    value: 0.0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new Matrix3()
                }
            }
        };

        /**
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author philogb / http://blog.thejit.org/
         * @author mikael emtinger / http://gomo.se/
         * @author egraether / http://egraether.com/
         * @author WestLangley / http://github.com/WestLangley
         */
        function Vector4(x, y, z, w) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== undefined ? w : 1;
        }

        Object.defineProperties(Vector4.prototype, {
            "width": {
                get: function () {
                    return this.z;
                },
                set: function (value) {
                    this.z = value;
                }
            },
            "height": {
                get: function () {
                    return this.w;
                },
                set: function (value) {
                    this.w = value;
                }
            }
        });
        Object.assign(Vector4.prototype, {
            isVector4: true,
            set: function (x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
            },
            setScalar: function (scalar) {
                this.x = scalar;
                this.y = scalar;
                this.z = scalar;
                this.w = scalar;
                return this;
            },
            setX: function (x) {
                this.x = x;
                return this;
            },
            setY: function (y) {
                this.y = y;
                return this;
            },
            setZ: function (z) {
                this.z = z;
                return this;
            },
            setW: function (w) {
                this.w = w;
                return this;
            },
            setComponent: function (index, value) {
                switch (index) {
                    case 0:
                        this.x = value;
                        break;

                    case 1:
                        this.y = value;
                        break;

                    case 2:
                        this.z = value;
                        break;

                    case 3:
                        this.w = value;
                        break;

                    default:
                        throw new Error('index is out of range: ' + index);
                }

                return this;
            },
            getComponent: function (index) {
                switch (index) {
                    case 0:
                        return this.x;

                    case 1:
                        return this.y;

                    case 2:
                        return this.z;

                    case 3:
                        return this.w;

                    default:
                        throw new Error('index is out of range: ' + index);
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w);
            },
            copy: function (v) {
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                this.w = v.w !== undefined ? v.w : 1;
                return this;
            },
            add: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);
                }

                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                this.w += v.w;
                return this;
            },
            addScalar: function (s) {
                this.x += s;
                this.y += s;
                this.z += s;
                this.w += s;
                return this;
            },
            addVectors: function (a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                this.w = a.w + b.w;
                return this;
            },
            addScaledVector: function (v, s) {
                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;
                this.w += v.w * s;
                return this;
            },
            sub: function (v, w) {
                if (w !== undefined) {
                    console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);
                }

                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                this.w -= v.w;
                return this;
            },
            subScalar: function (s) {
                this.x -= s;
                this.y -= s;
                this.z -= s;
                this.w -= s;
                return this;
            },
            subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                this.w = a.w - b.w;
                return this;
            },
            multiplyScalar: function (scalar) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
                return this;
            },
            applyMatrix4: function (m) {
                var x = this.x,
                    y = this.y,
                    z = this.z,
                    w = this.w;
                var e = m.elements;
                this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
                return this;
            },
            divideScalar: function (scalar) {
                return this.multiplyScalar(1 / scalar);
            },
            setAxisAngleFromQuaternion: function (q) {
                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
                // q is assumed to be normalized
                this.w = 2 * Math.acos(q.w);
                var s = Math.sqrt(1 - q.w * q.w);

                if (s < 0.0001) {
                    this.x = 1;
                    this.y = 0;
                    this.z = 0;
                } else {
                    this.x = q.x / s;
                    this.y = q.y / s;
                    this.z = q.z / s;
                }

                return this;
            },
            setAxisAngleFromRotationMatrix: function (m) {
                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                var angle,
                    x,
                    y,
                    z,
                    // variables for result
                    epsilon = 0.01,
                    // margin to allow for rounding errors
                    epsilon2 = 0.1,
                    // margin to distinguish between 0 and 180 degrees
                    te = m.elements,
                    m11 = te[0],
                    m12 = te[4],
                    m13 = te[8],
                    m21 = te[1],
                    m22 = te[5],
                    m23 = te[9],
                    m31 = te[2],
                    m32 = te[6],
                    m33 = te[10];

                if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                    // singularity found
                    // first check for identity matrix which must have +1 for all terms
                    // in leading diagonal and zero in other terms
                    if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                        // this singularity is identity matrix so angle = 0
                        this.set(1, 0, 0, 0);
                        return this; // zero angle, arbitrary axis
                    } // otherwise this singularity is angle = 180


                    angle = Math.PI;
                    var xx = (m11 + 1) / 2;
                    var yy = (m22 + 1) / 2;
                    var zz = (m33 + 1) / 2;
                    var xy = (m12 + m21) / 4;
                    var xz = (m13 + m31) / 4;
                    var yz = (m23 + m32) / 4;

                    if (xx > yy && xx > zz) {
                        // m11 is the largest diagonal term
                        if (xx < epsilon) {
                            x = 0;
                            y = 0.707106781;
                            z = 0.707106781;
                        } else {
                            x = Math.sqrt(xx);
                            y = xy / x;
                            z = xz / x;
                        }
                    } else if (yy > zz) {
                        // m22 is the largest diagonal term
                        if (yy < epsilon) {
                            x = 0.707106781;
                            y = 0;
                            z = 0.707106781;
                        } else {
                            y = Math.sqrt(yy);
                            x = xy / y;
                            z = yz / y;
                        }
                    } else {
                        // m33 is the largest diagonal term so base result on this
                        if (zz < epsilon) {
                            x = 0.707106781;
                            y = 0.707106781;
                            z = 0;
                        } else {
                            z = Math.sqrt(zz);
                            x = xz / z;
                            y = yz / z;
                        }
                    }

                    this.set(x, y, z, angle);
                    return this; // return 180 deg rotation
                } // as we have reached here there are no singularities so we can handle normally


                var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

                if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
                // caught by singularity test above, but I've left it in just in case

                this.x = (m32 - m23) / s;
                this.y = (m13 - m31) / s;
                this.z = (m21 - m12) / s;
                this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
                return this;
            },
            min: function (v) {
                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                this.z = Math.min(this.z, v.z);
                this.w = Math.min(this.w, v.w);
                return this;
            },
            max: function (v) {
                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                this.z = Math.max(this.z, v.z);
                this.w = Math.max(this.w, v.w);
                return this;
            },
            clamp: function (min, max) {
                // assumes min < max, componentwise
                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));
                this.z = Math.max(min.z, Math.min(max.z, this.z));
                this.w = Math.max(min.w, Math.min(max.w, this.w));
                return this;
            },
            clampScalar: function (minVal, maxVal) {
                this.x = Math.max(minVal, Math.min(maxVal, this.x));
                this.y = Math.max(minVal, Math.min(maxVal, this.y));
                this.z = Math.max(minVal, Math.min(maxVal, this.z));
                this.w = Math.max(minVal, Math.min(maxVal, this.w));
                return this;
            },
            clampLength: function (min, max) {
                var length = this.length();
                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            },
            floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);
                this.w = Math.floor(this.w);
                return this;
            },
            ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);
                this.w = Math.ceil(this.w);
                return this;
            },
            round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);
                this.w = Math.round(this.w);
                return this;
            },
            roundToZero: function () {
                this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
                return this;
            },
            negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this;
            },
            dot: function (v) {
                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1);
            },
            setLength: function (length) {
                return this.normalize().multiplyScalar(length);
            },
            lerp: function (v, alpha) {
                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                this.z += (v.z - this.z) * alpha;
                this.w += (v.w - this.w) * alpha;
                return this;
            },
            lerpVectors: function (v1, v2, alpha) {
                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            equals: function (v) {
                return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
            },
            fromArray: function (array, offset) {
                if (offset === undefined) offset = 0;
                this.x = array[offset];
                this.y = array[offset + 1];
                this.z = array[offset + 2];
                this.w = array[offset + 3];
                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this.x;
                array[offset + 1] = this.y;
                array[offset + 2] = this.z;
                array[offset + 3] = this.w;
                return array;
            },
            fromBufferAttribute: function (attribute, index, offset) {
                if (offset !== undefined) {
                    console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);
                this.z = attribute.getZ(index);
                this.w = attribute.getW(index);
                return this;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         */

        var _matrix = new Matrix4();

        var _quaternion$1 = new Quaternion();

        function Euler(x, y, z, order) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._order = order || Euler.DefaultOrder;
        }

        Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
        Euler.DefaultOrder = 'XYZ';
        Object.defineProperties(Euler.prototype, {
            x: {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x = value;

                    this._onChangeCallback();
                }
            },
            y: {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y = value;

                    this._onChangeCallback();
                }
            },
            z: {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z = value;

                    this._onChangeCallback();
                }
            },
            order: {
                get: function () {
                    return this._order;
                },
                set: function (value) {
                    this._order = value;

                    this._onChangeCallback();
                }
            }
        });
        Object.assign(Euler.prototype, {
            isEuler: true,
            set: function (x, y, z, order) {
                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order || this._order;

                this._onChangeCallback();

                return this;
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order);
            },
            copy: function (euler) {
                this._x = euler._x;
                this._y = euler._y;
                this._z = euler._z;
                this._order = euler._order;

                this._onChangeCallback();

                return this;
            },
            setFromRotationMatrix: function (m, order, update) {
                var clamp = MathUtils.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

                var te = m.elements;
                var m11 = te[0],
                    m12 = te[4],
                    m13 = te[8];
                var m21 = te[1],
                    m22 = te[5],
                    m23 = te[9];
                var m31 = te[2],
                    m32 = te[6],
                    m33 = te[10];
                order = order || this._order;

                if (order === 'XYZ') {
                    this._y = Math.asin(clamp(m13, -1, 1));

                    if (Math.abs(m13) < 0.9999999) {
                        this._x = Math.atan2(-m23, m33);
                        this._z = Math.atan2(-m12, m11);
                    } else {
                        this._x = Math.atan2(m32, m22);
                        this._z = 0;
                    }
                } else if (order === 'YXZ') {
                    this._x = Math.asin(-clamp(m23, -1, 1));

                    if (Math.abs(m23) < 0.9999999) {
                        this._y = Math.atan2(m13, m33);
                        this._z = Math.atan2(m21, m22);
                    } else {
                        this._y = Math.atan2(-m31, m11);
                        this._z = 0;
                    }
                } else if (order === 'ZXY') {
                    this._x = Math.asin(clamp(m32, -1, 1));

                    if (Math.abs(m32) < 0.9999999) {
                        this._y = Math.atan2(-m31, m33);
                        this._z = Math.atan2(-m12, m22);
                    } else {
                        this._y = 0;
                        this._z = Math.atan2(m21, m11);
                    }
                } else if (order === 'ZYX') {
                    this._y = Math.asin(-clamp(m31, -1, 1));

                    if (Math.abs(m31) < 0.9999999) {
                        this._x = Math.atan2(m32, m33);
                        this._z = Math.atan2(m21, m11);
                    } else {
                        this._x = 0;
                        this._z = Math.atan2(-m12, m22);
                    }
                } else if (order === 'YZX') {
                    this._z = Math.asin(clamp(m21, -1, 1));

                    if (Math.abs(m21) < 0.9999999) {
                        this._x = Math.atan2(-m23, m22);
                        this._y = Math.atan2(-m31, m11);
                    } else {
                        this._x = 0;
                        this._y = Math.atan2(m13, m33);
                    }
                } else if (order === 'XZY') {
                    this._z = Math.asin(-clamp(m12, -1, 1));

                    if (Math.abs(m12) < 0.9999999) {
                        this._x = Math.atan2(m32, m22);
                        this._y = Math.atan2(m13, m11);
                    } else {
                        this._x = Math.atan2(-m23, m33);
                        this._y = 0;
                    }
                } else {
                    console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
                }

                this._order = order;
                if (update !== false) this._onChangeCallback();
                return this;
            },
            setFromQuaternion: function (q, order, update) {
                _matrix.makeRotationFromQuaternion(q);

                return this.setFromRotationMatrix(_matrix, order, update);
            },
            setFromVector3: function (v, order) {
                return this.set(v.x, v.y, v.z, order || this._order);
            },
            reorder: function (newOrder) {
                // WARNING: this discards revolution information -bhouston
                _quaternion$1.setFromEuler(this);

                return this.setFromQuaternion(_quaternion$1, newOrder);
            },
            equals: function (euler) {
                return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
            },
            fromArray: function (array) {
                this._x = array[0];
                this._y = array[1];
                this._z = array[2];
                if (array[3] !== undefined) this._order = array[3];

                this._onChangeCallback();

                return this;
            },
            toArray: function (array, offset) {
                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;
                array[offset] = this._x;
                array[offset + 1] = this._y;
                array[offset + 2] = this._z;
                array[offset + 3] = this._order;
                return array;
            },
            toVector3: function (optionalResult) {
                if (optionalResult) {
                    return optionalResult.set(this._x, this._y, this._z);
                } else {
                    return new Vector3(this._x, this._y, this._z);
                }
            },
            _onChange: function (callback) {
                this._onChangeCallback = callback;
                return this;
            },
            _onChangeCallback: function () {}
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function Layers() {
            this.mask = 1 | 0;
        }

        Object.assign(Layers.prototype, {
            set: function (channel) {
                this.mask = 1 << channel | 0;
            },
            enable: function (channel) {
                this.mask |= 1 << channel | 0;
            },
            enableAll: function () {
                this.mask = 0xffffffff | 0;
            },
            toggle: function (channel) {
                this.mask ^= 1 << channel | 0;
            },
            disable: function (channel) {
                this.mask &= ~(1 << channel | 0);
            },
            disableAll: function () {
                this.mask = 0;
            },
            test: function (layers) {
                return (this.mask & layers.mask) !== 0;
            }
        });

        var _object3DId = 0;

        var _v1$2 = new Vector3();

        var _q1 = new Quaternion();

        var _m1$1 = new Matrix4();

        var _target = new Vector3();

        var _position = new Vector3();

        var _scale = new Vector3();

        var _quaternion$2 = new Quaternion();

        var _xAxis = new Vector3(1, 0, 0);

        var _yAxis = new Vector3(0, 1, 0);

        var _zAxis = new Vector3(0, 0, 1);

        var _addedEvent = {
            type: 'added'
        };
        var _removedEvent = {
            type: 'removed'
        };
        /**
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author elephantatwork / www.elephantatwork.ch
         */

        function Object3D() {
            Object.defineProperty(this, 'id', {
                value: _object3DId++
            });
            this.uuid = MathUtils.generateUUID();
            this.name = '';
            this.type = 'Object3D';
            this.parent = null;
            this.children = [];
            this.up = Object3D.DefaultUp.clone();
            var position = new Vector3();
            var rotation = new Euler();
            var quaternion = new Quaternion();
            var scale = new Vector3(1, 1, 1);

            function onRotationChange() {
                quaternion.setFromEuler(rotation, false);
            }

            function onQuaternionChange() {
                rotation.setFromQuaternion(quaternion, undefined, false);
            }

            rotation._onChange(onRotationChange);

            quaternion._onChange(onQuaternionChange);

            Object.defineProperties(this, {
                position: {
                    configurable: true,
                    enumerable: true,
                    value: position
                },
                rotation: {
                    configurable: true,
                    enumerable: true,
                    value: rotation
                },
                quaternion: {
                    configurable: true,
                    enumerable: true,
                    value: quaternion
                },
                scale: {
                    configurable: true,
                    enumerable: true,
                    value: scale
                },
                modelViewMatrix: {
                    value: new Matrix4()
                },
                normalMatrix: {
                    value: new Matrix3()
                }
            });
            this.matrix = new Matrix4();
            this.matrixWorld = new Matrix4();
            this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            this.matrixWorldNeedsUpdate = false;
            this.layers = new Layers();
            this.visible = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.frustumCulled = true;
            this.renderOrder = 0;
            this.userData = {};
        }

        Object3D.DefaultUp = new Vector3(0, 1, 0);
        Object3D.DefaultMatrixAutoUpdate = true;
        Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: Object3D,
            isObject3D: true,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix4: function (matrix) {
                if (this.matrixAutoUpdate) this.updateMatrix();
                this.matrix.premultiply(matrix);
                this.matrix.decompose(this.position, this.quaternion, this.scale);
            },
            applyQuaternion: function (q) {
                this.quaternion.premultiply(q);
                return this;
            },
            setRotationFromAxisAngle: function (axis, angle) {
                // assumes axis is normalized
                this.quaternion.setFromAxisAngle(axis, angle);
            },
            setRotationFromEuler: function (euler) {
                this.quaternion.setFromEuler(euler, true);
            },
            setRotationFromMatrix: function (m) {
                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                this.quaternion.setFromRotationMatrix(m);
            },
            setRotationFromQuaternion: function (q) {
                // assumes q is normalized
                this.quaternion.copy(q);
            },
            rotateOnAxis: function (axis, angle) {
                // rotate object on axis in object space
                // axis is assumed to be normalized
                _q1.setFromAxisAngle(axis, angle);

                this.quaternion.multiply(_q1);
                return this;
            },
            rotateOnWorldAxis: function (axis, angle) {
                // rotate object on axis in world space
                // axis is assumed to be normalized
                // method assumes no rotated parent
                _q1.setFromAxisAngle(axis, angle);

                this.quaternion.premultiply(_q1);
                return this;
            },
            rotateX: function (angle) {
                return this.rotateOnAxis(_xAxis, angle);
            },
            rotateY: function (angle) {
                return this.rotateOnAxis(_yAxis, angle);
            },
            rotateZ: function (angle) {
                return this.rotateOnAxis(_zAxis, angle);
            },
            translateOnAxis: function (axis, distance) {
                // translate object by distance along axis in object space
                // axis is assumed to be normalized
                _v1$2.copy(axis).applyQuaternion(this.quaternion);

                this.position.add(_v1$2.multiplyScalar(distance));
                return this;
            },
            translateX: function (distance) {
                return this.translateOnAxis(_xAxis, distance);
            },
            translateY: function (distance) {
                return this.translateOnAxis(_yAxis, distance);
            },
            translateZ: function (distance) {
                return this.translateOnAxis(_zAxis, distance);
            },
            localToWorld: function (vector) {
                return vector.applyMatrix4(this.matrixWorld);
            },
            worldToLocal: function (vector) {
                return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
            },
            lookAt: function (x, y, z) {
                // This method does not support objects having non-uniformly-scaled parent(s)
                if (x.isVector3) {
                    _target.copy(x);
                } else {
                    _target.set(x, y, z);
                }

                var parent = this.parent;
                this.updateWorldMatrix(true, false);

                _position.setFromMatrixPosition(this.matrixWorld);

                if (this.isCamera || this.isLight) {
                    _m1$1.lookAt(_position, _target, this.up);
                } else {
                    _m1$1.lookAt(_target, _position, this.up);
                }

                this.quaternion.setFromRotationMatrix(_m1$1);

                if (parent) {
                    _m1$1.extractRotation(parent.matrixWorld);

                    _q1.setFromRotationMatrix(_m1$1);

                    this.quaternion.premultiply(_q1.inverse());
                }
            },
            add: function (object) {
                if (arguments.length > 1) {
                    for (var i = 0; i < arguments.length; i++) {
                        this.add(arguments[i]);
                    }

                    return this;
                }

                if (object === this) {
                    console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                    return this;
                }

                if (object && object.isObject3D) {
                    if (object.parent !== null) {
                        object.parent.remove(object);
                    }

                    object.parent = this;
                    this.children.push(object);
                    object.dispatchEvent(_addedEvent);
                } else {
                    console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
                }

                return this;
            },
            remove: function (object) {
                if (arguments.length > 1) {
                    for (var i = 0; i < arguments.length; i++) {
                        this.remove(arguments[i]);
                    }

                    return this;
                }

                var index = this.children.indexOf(object);

                if (index !== -1) {
                    object.parent = null;
                    this.children.splice(index, 1);
                    object.dispatchEvent(_removedEvent);
                }

                return this;
            },
            attach: function (object) {
                // adds object as a child of this, while maintaining the object's world transform
                this.updateWorldMatrix(true, false);

                _m1$1.getInverse(this.matrixWorld);

                if (object.parent !== null) {
                    object.parent.updateWorldMatrix(true, false);

                    _m1$1.multiply(object.parent.matrixWorld);
                }

                object.applyMatrix4(_m1$1);
                object.updateWorldMatrix(false, false);
                this.add(object);
                return this;
            },
            getObjectById: function (id) {
                return this.getObjectByProperty('id', id);
            },
            getObjectByName: function (name) {
                return this.getObjectByProperty('name', name);
            },
            getObjectByProperty: function (name, value) {
                if (this[name] === value) return this;

                for (var i = 0, l = this.children.length; i < l; i++) {
                    var child = this.children[i];
                    var object = child.getObjectByProperty(name, value);

                    if (object !== undefined) {
                        return object;
                    }
                }

                return undefined;
            },
            getWorldPosition: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldPosition() target is now required');
                    target = new Vector3();
                }

                this.updateMatrixWorld(true);
                return target.setFromMatrixPosition(this.matrixWorld);
            },
            getWorldQuaternion: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
                    target = new Quaternion();
                }

                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(_position, target, _scale);
                return target;
            },
            getWorldScale: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldScale() target is now required');
                    target = new Vector3();
                }

                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(_position, _quaternion$2, target);
                return target;
            },
            getWorldDirection: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldDirection() target is now required');
                    target = new Vector3();
                }

                this.updateMatrixWorld(true);
                var e = this.matrixWorld.elements;
                return target.set(e[8], e[9], e[10]).normalize();
            },
            raycast: function () {},
            traverse: function (callback) {
                callback(this);
                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    children[i].traverse(callback);
                }
            },
            traverseVisible: function (callback) {
                if (this.visible === false) return;
                callback(this);
                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    children[i].traverseVisible(callback);
                }
            },
            traverseAncestors: function (callback) {
                var parent = this.parent;

                if (parent !== null) {
                    callback(parent);
                    parent.traverseAncestors(callback);
                }
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale);
                this.matrixWorldNeedsUpdate = true;
            },
            updateMatrixWorld: function (force) {
                if (this.matrixAutoUpdate) this.updateMatrix();

                if (this.matrixWorldNeedsUpdate || force) {
                    if (this.parent === null) {
                        this.matrixWorld.copy(this.matrix);
                    } else {
                        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                    }

                    this.matrixWorldNeedsUpdate = false;
                    force = true;
                } // update children


                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    children[i].updateMatrixWorld(force);
                }
            },
            updateWorldMatrix: function (updateParents, updateChildren) {
                var parent = this.parent;

                if (updateParents === true && parent !== null) {
                    parent.updateWorldMatrix(true, false);
                }

                if (this.matrixAutoUpdate) this.updateMatrix();

                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                } // update children


                if (updateChildren === true) {
                    var children = this.children;

                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].updateWorldMatrix(false, true);
                    }
                }
            },
            toJSON: function (meta) {
                // meta is a string when called from JSON.stringify
                var isRootObject = meta === undefined || typeof meta === 'string';
                var output = {}; // meta is a hash used to collect geometries, materials.
                // not providing it implies that this is the root object
                // being serialized.

                if (isRootObject) {
                    // initialize meta obj
                    meta = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    };
                    output.metadata = {
                        version: 4.5,
                        type: 'Object',
                        generator: 'Object3D.toJSON'
                    };
                } // standard Object3D serialization


                var object = {};
                object.uuid = this.uuid;
                object.type = this.type;
                if (this.name !== '') object.name = this.name;
                if (this.castShadow === true) object.castShadow = true;
                if (this.receiveShadow === true) object.receiveShadow = true;
                if (this.visible === false) object.visible = false;
                if (this.frustumCulled === false) object.frustumCulled = false;
                if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
                if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
                object.layers = this.layers.mask;
                object.matrix = this.matrix.toArray();
                if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

                if (this.isInstancedMesh) {
                    object.type = 'InstancedMesh';
                    object.count = this.count;
                    object.instanceMatrix = this.instanceMatrix.toJSON();
                } //


                function serialize(library, element) {
                    if (library[element.uuid] === undefined) {
                        library[element.uuid] = element.toJSON(meta);
                    }

                    return element.uuid;
                }

                if (this.isMesh || this.isLine || this.isPoints) {
                    object.geometry = serialize(meta.geometries, this.geometry);
                    var parameters = this.geometry.parameters;

                    if (parameters !== undefined && parameters.shapes !== undefined) {
                        var shapes = parameters.shapes;

                        if (Array.isArray(shapes)) {
                            for (var i = 0, l = shapes.length; i < l; i++) {
                                var shape = shapes[i];
                                serialize(meta.shapes, shape);
                            }
                        } else {
                            serialize(meta.shapes, shapes);
                        }
                    }
                }

                if (this.material !== undefined) {
                    if (Array.isArray(this.material)) {
                        var uuids = [];

                        for (var i = 0, l = this.material.length; i < l; i++) {
                            uuids.push(serialize(meta.materials, this.material[i]));
                        }

                        object.material = uuids;
                    } else {
                        object.material = serialize(meta.materials, this.material);
                    }
                } //


                if (this.children.length > 0) {
                    object.children = [];

                    for (var i = 0; i < this.children.length; i++) {
                        object.children.push(this.children[i].toJSON(meta).object);
                    }
                }

                if (isRootObject) {
                    var geometries = extractFromCache(meta.geometries);
                    var materials = extractFromCache(meta.materials);
                    var textures = extractFromCache(meta.textures);
                    var images = extractFromCache(meta.images);
                    var shapes = extractFromCache(meta.shapes);
                    if (geometries.length > 0) output.geometries = geometries;
                    if (materials.length > 0) output.materials = materials;
                    if (textures.length > 0) output.textures = textures;
                    if (images.length > 0) output.images = images;
                    if (shapes.length > 0) output.shapes = shapes;
                }

                output.object = object;
                return output; // extract data from the cache hash
                // remove metadata on each item
                // and return as array

                function extractFromCache(cache) {
                    var values = [];

                    for (var key in cache) {
                        var data = cache[key];
                        delete data.metadata;
                        values.push(data);
                    }

                    return values;
                }
            },
            clone: function (recursive) {
                return new this.constructor().copy(this, recursive);
            },
            copy: function (source, recursive) {
                if (recursive === undefined) recursive = true;
                this.name = source.name;
                this.up.copy(source.up);
                this.position.copy(source.position);
                this.quaternion.copy(source.quaternion);
                this.scale.copy(source.scale);
                this.matrix.copy(source.matrix);
                this.matrixWorld.copy(source.matrixWorld);
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                this.layers.mask = source.layers.mask;
                this.visible = source.visible;
                this.castShadow = source.castShadow;
                this.receiveShadow = source.receiveShadow;
                this.frustumCulled = source.frustumCulled;
                this.renderOrder = source.renderOrder;
                this.userData = JSON.parse(JSON.stringify(source.userData));

                if (recursive === true) {
                    for (var i = 0; i < source.children.length; i++) {
                        var child = source.children[i];
                        this.add(child.clone());
                    }
                }

                return this;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Scene() {
            Object3D.call(this);
            this.type = 'Scene';
            this.background = null;
            this.environment = null;
            this.fog = null;
            this.overrideMaterial = null;
            this.autoUpdate = true; // checked by the renderer

            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                    detail: this
                })); // eslint-disable-line no-undef

            }
        }

        Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Scene,
            isScene: true,
            copy: function (source, recursive) {
                Object3D.prototype.copy.call(this, source, recursive);
                if (source.background !== null) this.background = source.background.clone();
                if (source.environment !== null) this.environment = source.environment.clone();
                if (source.fog !== null) this.fog = source.fog.clone();
                if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
                this.autoUpdate = source.autoUpdate;
                this.matrixAutoUpdate = source.matrixAutoUpdate;
                return this;
            },
            toJSON: function (meta) {
                var data = Object3D.prototype.toJSON.call(this, meta);
                if (this.background !== null) data.object.background = this.background.toJSON(meta);
                if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
                if (this.fog !== null) data.object.fog = this.fog.toJSON();
                return data;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLAnimation() {
            var context = null;
            var isAnimating = false;
            var animationLoop = null;

            function onAnimationFrame(time, frame) {
                if (isAnimating === false) return;
                animationLoop(time, frame);
                context.requestAnimationFrame(onAnimationFrame);
            }

            return {
                start: function () {
                    if (isAnimating === true) return;
                    if (animationLoop === null) return;
                    context.requestAnimationFrame(onAnimationFrame);
                    isAnimating = true;
                },
                stop: function () {
                    isAnimating = false;
                },
                setAnimationLoop: function (callback) {
                    animationLoop = callback;
                },
                setContext: function (value) {
                    context = value;
                }
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLAttributes(gl, capabilities) {
            var isWebGL2 = capabilities.isWebGL2;
            var buffers = new WeakMap();

            function createBuffer(attribute, bufferType) {
                var array = attribute.array;
                var usage = attribute.usage;
                var buffer = gl.createBuffer();
                gl.bindBuffer(bufferType, buffer);
                gl.bufferData(bufferType, array, usage);
                attribute.onUploadCallback();
                var type = gl.FLOAT;

                if (array instanceof Float32Array) {
                    type = gl.FLOAT;
                } else if (array instanceof Float64Array) {
                    console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
                } else if (array instanceof Uint16Array) {
                    type = gl.UNSIGNED_SHORT;
                } else if (array instanceof Int16Array) {
                    type = gl.SHORT;
                } else if (array instanceof Uint32Array) {
                    type = gl.UNSIGNED_INT;
                } else if (array instanceof Int32Array) {
                    type = gl.INT;
                } else if (array instanceof Int8Array) {
                    type = gl.BYTE;
                } else if (array instanceof Uint8Array) {
                    type = gl.UNSIGNED_BYTE;
                }

                return {
                    buffer: buffer,
                    type: type,
                    bytesPerElement: array.BYTES_PER_ELEMENT,
                    version: attribute.version
                };
            }

            function updateBuffer(buffer, attribute, bufferType) {
                var array = attribute.array;
                var updateRange = attribute.updateRange;
                gl.bindBuffer(bufferType, buffer);

                if (updateRange.count === -1) {
                    // Not using update ranges
                    gl.bufferSubData(bufferType, 0, array);
                } else {
                    if (isWebGL2) {
                        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
                    } else {
                        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                    }

                    updateRange.count = -1; // reset range
                }
            } //


            function get(attribute) {
                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                return buffers.get(attribute);
            }

            function remove(attribute) {
                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                var data = buffers.get(attribute);

                if (data) {
                    gl.deleteBuffer(data.buffer);
                    buffers.delete(attribute);
                }
            }

            function update(attribute, bufferType) {
                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                var data = buffers.get(attribute);

                if (data === undefined) {
                    buffers.set(attribute, createBuffer(attribute, bufferType));
                } else if (data.version < attribute.version) {
                    updateBuffer(data.buffer, attribute, bufferType);
                    data.version = attribute.version;
                }
            }

            return {
                get: get,
                remove: remove,
                update: update
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function Face3(a, b, c, normal, color, materialIndex) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal && normal.isVector3 ? normal : new Vector3();
            this.vertexNormals = Array.isArray(normal) ? normal : [];
            this.color = color && color.isColor ? color : new Color();
            this.vertexColors = Array.isArray(color) ? color : [];
            this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
        }

        Object.assign(Face3.prototype, {
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (source) {
                this.a = source.a;
                this.b = source.b;
                this.c = source.c;
                this.normal.copy(source.normal);
                this.color.copy(source.color);
                this.materialIndex = source.materialIndex;

                for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                    this.vertexNormals[i] = source.vertexNormals[i].clone();
                }

                for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                    this.vertexColors[i] = source.vertexColors[i].clone();
                }

                return this;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author kile / http://kile.stravaganza.org/
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author bhouston / http://clara.io
         */

        var _geometryId = 0; // Geometry uses even numbers as Id

        var _m1$2 = new Matrix4();

        var _obj = new Object3D();

        var _offset = new Vector3();

        function Geometry() {
            Object.defineProperty(this, 'id', {
                value: _geometryId += 2
            });
            this.uuid = MathUtils.generateUUID();
            this.name = '';
            this.type = 'Geometry';
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null; // update flags

            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }

        Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: Geometry,
            isGeometry: true,
            applyMatrix4: function (matrix) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);

                for (var i = 0, il = this.vertices.length; i < il; i++) {
                    var vertex = this.vertices[i];
                    vertex.applyMatrix4(matrix);
                }

                for (var i = 0, il = this.faces.length; i < il; i++) {
                    var face = this.faces[i];
                    face.normal.applyMatrix3(normalMatrix).normalize();

                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                    }
                }

                if (this.boundingBox !== null) {
                    this.computeBoundingBox();
                }

                if (this.boundingSphere !== null) {
                    this.computeBoundingSphere();
                }

                this.verticesNeedUpdate = true;
                this.normalsNeedUpdate = true;
                return this;
            },
            rotateX: function (angle) {
                // rotate geometry around world x-axis
                _m1$2.makeRotationX(angle);

                this.applyMatrix4(_m1$2);
                return this;
            },
            rotateY: function (angle) {
                // rotate geometry around world y-axis
                _m1$2.makeRotationY(angle);

                this.applyMatrix4(_m1$2);
                return this;
            },
            rotateZ: function (angle) {
                // rotate geometry around world z-axis
                _m1$2.makeRotationZ(angle);

                this.applyMatrix4(_m1$2);
                return this;
            },
            translate: function (x, y, z) {
                // translate geometry
                _m1$2.makeTranslation(x, y, z);

                this.applyMatrix4(_m1$2);
                return this;
            },
            scale: function (x, y, z) {
                // scale geometry
                _m1$2.makeScale(x, y, z);

                this.applyMatrix4(_m1$2);
                return this;
            },
            lookAt: function (vector) {
                _obj.lookAt(vector);

                _obj.updateMatrix();

                this.applyMatrix4(_obj.matrix);
                return this;
            },
            fromBufferGeometry: function (geometry) {
                var scope = this;
                var indices = geometry.index !== null ? geometry.index.array : undefined;
                var attributes = geometry.attributes;

                if (attributes.position === undefined) {
                    console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
                    return this;
                }

                var positions = attributes.position.array;
                var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
                var colors = attributes.color !== undefined ? attributes.color.array : undefined;
                var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
                var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
                if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

                for (var i = 0; i < positions.length; i += 3) {
                    scope.vertices.push(new Vector3().fromArray(positions, i));

                    if (colors !== undefined) {
                        scope.colors.push(new Color().fromArray(colors, i));
                    }
                }

                function addFace(a, b, c, materialIndex) {
                    var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
                    var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
                    var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                    scope.faces.push(face);

                    if (uvs !== undefined) {
                        scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
                    }

                    if (uvs2 !== undefined) {
                        scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
                    }
                }

                var groups = geometry.groups;

                if (groups.length > 0) {
                    for (var i = 0; i < groups.length; i++) {
                        var group = groups[i];
                        var start = group.start;
                        var count = group.count;

                        for (var j = start, jl = start + count; j < jl; j += 3) {
                            if (indices !== undefined) {
                                addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                            } else {
                                addFace(j, j + 1, j + 2, group.materialIndex);
                            }
                        }
                    }
                } else {
                    if (indices !== undefined) {
                        for (var i = 0; i < indices.length; i += 3) {
                            addFace(indices[i], indices[i + 1], indices[i + 2]);
                        }
                    } else {
                        for (var i = 0; i < positions.length / 3; i += 3) {
                            addFace(i, i + 1, i + 2);
                        }
                    }
                }

                this.computeFaceNormals();

                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }

                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }

                return this;
            },
            center: function () {
                this.computeBoundingBox();
                this.boundingBox.getCenter(_offset).negate();
                this.translate(_offset.x, _offset.y, _offset.z);
                return this;
            },
            normalize: function () {
                this.computeBoundingSphere();
                var center = this.boundingSphere.center;
                var radius = this.boundingSphere.radius;
                var s = radius === 0 ? 1 : 1.0 / radius;
                var matrix = new Matrix4();
                matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
                this.applyMatrix4(matrix);
                return this;
            },
            computeFaceNormals: function () {
                var cb = new Vector3(),
                    ab = new Vector3();

                for (var f = 0, fl = this.faces.length; f < fl; f++) {
                    var face = this.faces[f];
                    var vA = this.vertices[face.a];
                    var vB = this.vertices[face.b];
                    var vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    cb.normalize();
                    face.normal.copy(cb);
                }
            },
            computeVertexNormals: function (areaWeighted) {
                if (areaWeighted === undefined) areaWeighted = true;
                var v, vl, f, fl, face, vertices;
                vertices = new Array(this.vertices.length);

                for (v = 0, vl = this.vertices.length; v < vl; v++) {
                    vertices[v] = new Vector3();
                }

                if (areaWeighted) {
                    // vertex normals weighted by triangle areas
                    // http://www.iquilezles.org/www/articles/normals/normals.htm
                    var vA, vB, vC;
                    var cb = new Vector3(),
                        ab = new Vector3();

                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        vA = this.vertices[face.a];
                        vB = this.vertices[face.b];
                        vC = this.vertices[face.c];
                        cb.subVectors(vC, vB);
                        ab.subVectors(vA, vB);
                        cb.cross(ab);
                        vertices[face.a].add(cb);
                        vertices[face.b].add(cb);
                        vertices[face.c].add(cb);
                    }
                } else {
                    this.computeFaceNormals();

                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        vertices[face.a].add(face.normal);
                        vertices[face.b].add(face.normal);
                        vertices[face.c].add(face.normal);
                    }
                }

                for (v = 0, vl = this.vertices.length; v < vl; v++) {
                    vertices[v].normalize();
                }

                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {
                        vertexNormals[0].copy(vertices[face.a]);
                        vertexNormals[1].copy(vertices[face.b]);
                        vertexNormals[2].copy(vertices[face.c]);
                    } else {
                        vertexNormals[0] = vertices[face.a].clone();
                        vertexNormals[1] = vertices[face.b].clone();
                        vertexNormals[2] = vertices[face.c].clone();
                    }
                }

                if (this.faces.length > 0) {
                    this.normalsNeedUpdate = true;
                }
            },
            computeFlatVertexNormals: function () {
                var f, fl, face;
                this.computeFaceNormals();

                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {
                        vertexNormals[0].copy(face.normal);
                        vertexNormals[1].copy(face.normal);
                        vertexNormals[2].copy(face.normal);
                    } else {
                        vertexNormals[0] = face.normal.clone();
                        vertexNormals[1] = face.normal.clone();
                        vertexNormals[2] = face.normal.clone();
                    }
                }

                if (this.faces.length > 0) {
                    this.normalsNeedUpdate = true;
                }
            },
            computeMorphNormals: function () {
                var i, il, f, fl, face; // save original normals
                // - create temp variables on first access
                //   otherwise just copy (for faster repeated calls)

                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];

                    if (!face.__originalFaceNormal) {
                        face.__originalFaceNormal = face.normal.clone();
                    } else {
                        face.__originalFaceNormal.copy(face.normal);
                    }

                    if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

                    for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                        if (!face.__originalVertexNormals[i]) {
                            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                        } else {
                            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                        }
                    }
                } // use temp geometry to compute face and vertex normals for each morph


                var tmpGeo = new Geometry();
                tmpGeo.faces = this.faces;

                for (i = 0, il = this.morphTargets.length; i < il; i++) {
                    // create on first access
                    if (!this.morphNormals[i]) {
                        this.morphNormals[i] = {};
                        this.morphNormals[i].faceNormals = [];
                        this.morphNormals[i].vertexNormals = [];
                        var dstNormalsFace = this.morphNormals[i].faceNormals;
                        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                        var faceNormal, vertexNormals;

                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            faceNormal = new Vector3();
                            vertexNormals = {
                                a: new Vector3(),
                                b: new Vector3(),
                                c: new Vector3()
                            };
                            dstNormalsFace.push(faceNormal);
                            dstNormalsVertex.push(vertexNormals);
                        }
                    }

                    var morphNormals = this.morphNormals[i]; // set vertices to morph target

                    tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

                    tmpGeo.computeFaceNormals();
                    tmpGeo.computeVertexNormals(); // store morph normals

                    var faceNormal, vertexNormals;

                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        faceNormal = morphNormals.faceNormals[f];
                        vertexNormals = morphNormals.vertexNormals[f];
                        faceNormal.copy(face.normal);
                        vertexNormals.a.copy(face.vertexNormals[0]);
                        vertexNormals.b.copy(face.vertexNormals[1]);
                        vertexNormals.c.copy(face.vertexNormals[2]);
                    }
                } // restore original normals


                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    face.normal = face.__originalFaceNormal;
                    face.vertexNormals = face.__originalVertexNormals;
                }
            },
            computeBoundingBox: function () {
                if (this.boundingBox === null) {
                    this.boundingBox = new Box3();
                }

                this.boundingBox.setFromPoints(this.vertices);
            },
            computeBoundingSphere: function () {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new Sphere();
                }

                this.boundingSphere.setFromPoints(this.vertices);
            },
            merge: function (geometry, matrix, materialIndexOffset) {
                if (!(geometry && geometry.isGeometry)) {
                    console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                    return;
                }

                var normalMatrix,
                    vertexOffset = this.vertices.length,
                    vertices1 = this.vertices,
                    vertices2 = geometry.vertices,
                    faces1 = this.faces,
                    faces2 = geometry.faces,
                    colors1 = this.colors,
                    colors2 = geometry.colors;
                if (materialIndexOffset === undefined) materialIndexOffset = 0;

                if (matrix !== undefined) {
                    normalMatrix = new Matrix3().getNormalMatrix(matrix);
                } // vertices


                for (var i = 0, il = vertices2.length; i < il; i++) {
                    var vertex = vertices2[i];
                    var vertexCopy = vertex.clone();
                    if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
                    vertices1.push(vertexCopy);
                } // colors


                for (var i = 0, il = colors2.length; i < il; i++) {
                    colors1.push(colors2[i].clone());
                } // faces


                for (i = 0, il = faces2.length; i < il; i++) {
                    var face = faces2[i],
                        faceCopy,
                        normal,
                        color,
                        faceVertexNormals = face.vertexNormals,
                        faceVertexColors = face.vertexColors;
                    faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                    faceCopy.normal.copy(face.normal);

                    if (normalMatrix !== undefined) {
                        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                    }

                    for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                        normal = faceVertexNormals[j].clone();

                        if (normalMatrix !== undefined) {
                            normal.applyMatrix3(normalMatrix).normalize();
                        }

                        faceCopy.vertexNormals.push(normal);
                    }

                    faceCopy.color.copy(face.color);

                    for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                        color = faceVertexColors[j];
                        faceCopy.vertexColors.push(color.clone());
                    }

                    faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                    faces1.push(faceCopy);
                } // uvs


                for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
                    var faceVertexUvs2 = geometry.faceVertexUvs[i];
                    if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

                    for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
                        var uvs2 = faceVertexUvs2[j],
                            uvsCopy = [];

                        for (var k = 0, kl = uvs2.length; k < kl; k++) {
                            uvsCopy.push(uvs2[k].clone());
                        }

                        this.faceVertexUvs[i].push(uvsCopy);
                    }
                }
            },
            mergeMesh: function (mesh) {
                if (!(mesh && mesh.isMesh)) {
                    console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                    return;
                }

                if (mesh.matrixAutoUpdate) mesh.updateMatrix();
                this.merge(mesh.geometry, mesh.matrix);
            },

            /*
	   * Checks for duplicate vertices with hashmap.
	   * Duplicated vertices are removed
	   * and faces' vertices are updated.
	   */
            mergeVertices: function () {
                var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

                var unique = [],
                    changes = [];
                var v, key;
                var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

                var precision = Math.pow(10, precisionPoints);
                var i, il, face;
                var indices, j, jl;

                for (i = 0, il = this.vertices.length; i < il; i++) {
                    v = this.vertices[i];
                    key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

                    if (verticesMap[key] === undefined) {
                        verticesMap[key] = i;
                        unique.push(this.vertices[i]);
                        changes[i] = unique.length - 1;
                    } else {
                        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                        changes[i] = changes[verticesMap[key]];
                    }
                } // if faces are completely degenerate after merging vertices, we
                // have to remove them from the geometry.


                var faceIndicesToRemove = [];

                for (i = 0, il = this.faces.length; i < il; i++) {
                    face = this.faces[i];
                    face.a = changes[face.a];
                    face.b = changes[face.b];
                    face.c = changes[face.c];
                    indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
                    // we have to remove the face as nothing can be saved

                    for (var n = 0; n < 3; n++) {
                        if (indices[n] === indices[(n + 1) % 3]) {
                            faceIndicesToRemove.push(i);
                            break;
                        }
                    }
                }

                for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                    var idx = faceIndicesToRemove[i];
                    this.faces.splice(idx, 1);

                    for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                        this.faceVertexUvs[j].splice(idx, 1);
                    }
                } // Use unique set of vertices


                var diff = this.vertices.length - unique.length;
                this.vertices = unique;
                return diff;
            },
            setFromPoints: function (points) {
                this.vertices = [];

                for (var i = 0, l = points.length; i < l; i++) {
                    var point = points[i];
                    this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
                }

                return this;
            },
            sortFacesByMaterialIndex: function () {
                var faces = this.faces;
                var length = faces.length; // tag faces

                for (var i = 0; i < length; i++) {
                    faces[i]._id = i;
                } // sort faces


                function materialIndexSort(a, b) {
                    return a.materialIndex - b.materialIndex;
                }

                faces.sort(materialIndexSort); // sort uvs

                var uvs1 = this.faceVertexUvs[0];
                var uvs2 = this.faceVertexUvs[1];
                var newUvs1, newUvs2;
                if (uvs1 && uvs1.length === length) newUvs1 = [];
                if (uvs2 && uvs2.length === length) newUvs2 = [];

                for (var i = 0; i < length; i++) {
                    var id = faces[i]._id;
                    if (newUvs1) newUvs1.push(uvs1[id]);
                    if (newUvs2) newUvs2.push(uvs2[id]);
                }

                if (newUvs1) this.faceVertexUvs[0] = newUvs1;
                if (newUvs2) this.faceVertexUvs[1] = newUvs2;
            },
            toJSON: function () {
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Geometry',
                        generator: 'Geometry.toJSON'
                    }
                }; // standard Geometry serialization

                data.uuid = this.uuid;
                data.type = this.type;
                if (this.name !== '') data.name = this.name;

                if (this.parameters !== undefined) {
                    var parameters = this.parameters;

                    for (var key in parameters) {
                        if (parameters[key] !== undefined) data[key] = parameters[key];
                    }

                    return data;
                }

                var vertices = [];

                for (var i = 0; i < this.vertices.length; i++) {
                    var vertex = this.vertices[i];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }

                var faces = [];
                var normals = [];
                var normalsHash = {};
                var colors = [];
                var colorsHash = {};
                var uvs = [];
                var uvsHash = {};

                for (var i = 0; i < this.faces.length; i++) {
                    var face = this.faces[i];
                    var hasMaterial = true;
                    var hasFaceUv = false; // deprecated

                    var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                    var hasFaceNormal = face.normal.length() > 0;
                    var hasFaceVertexNormal = face.vertexNormals.length > 0;
                    var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                    var hasFaceVertexColor = face.vertexColors.length > 0;
                    var faceType = 0;
                    faceType = setBit(faceType, 0, 0); // isQuad

                    faceType = setBit(faceType, 1, hasMaterial);
                    faceType = setBit(faceType, 2, hasFaceUv);
                    faceType = setBit(faceType, 3, hasFaceVertexUv);
                    faceType = setBit(faceType, 4, hasFaceNormal);
                    faceType = setBit(faceType, 5, hasFaceVertexNormal);
                    faceType = setBit(faceType, 6, hasFaceColor);
                    faceType = setBit(faceType, 7, hasFaceVertexColor);
                    faces.push(faceType);
                    faces.push(face.a, face.b, face.c);
                    faces.push(face.materialIndex);

                    if (hasFaceVertexUv) {
                        var faceVertexUvs = this.faceVertexUvs[0][i];
                        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                    }

                    if (hasFaceNormal) {
                        faces.push(getNormalIndex(face.normal));
                    }

                    if (hasFaceVertexNormal) {
                        var vertexNormals = face.vertexNormals;
                        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                    }

                    if (hasFaceColor) {
                        faces.push(getColorIndex(face.color));
                    }

                    if (hasFaceVertexColor) {
                        var vertexColors = face.vertexColors;
                        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                    }
                }

                function setBit(value, position, enabled) {
                    return enabled ? value | 1 << position : value & ~(1 << position);
                }

                function getNormalIndex(normal) {
                    var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

                    if (normalsHash[hash] !== undefined) {
                        return normalsHash[hash];
                    }

                    normalsHash[hash] = normals.length / 3;
                    normals.push(normal.x, normal.y, normal.z);
                    return normalsHash[hash];
                }

                function getColorIndex(color) {
                    var hash = color.r.toString() + color.g.toString() + color.b.toString();

                    if (colorsHash[hash] !== undefined) {
                        return colorsHash[hash];
                    }

                    colorsHash[hash] = colors.length;
                    colors.push(color.getHex());
                    return colorsHash[hash];
                }

                function getUvIndex(uv) {
                    var hash = uv.x.toString() + uv.y.toString();

                    if (uvsHash[hash] !== undefined) {
                        return uvsHash[hash];
                    }

                    uvsHash[hash] = uvs.length / 2;
                    uvs.push(uv.x, uv.y);
                    return uvsHash[hash];
                }

                data.data = {};
                data.data.vertices = vertices;
                data.data.normals = normals;
                if (colors.length > 0) data.data.colors = colors;
                if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

                data.data.faces = faces;
                return data;
            },
            clone: function () {
                /*
	     // Handle primitives
	    	 var parameters = this.parameters;
	    	 if ( parameters !== undefined ) {
	    	 var values = [];
	    	 for ( var key in parameters ) {
	    	 values.push( parameters[ key ] );
	    	 }
	    	 var geometry = Object.create( this.constructor.prototype );
	     this.constructor.apply( geometry, values );
	     return geometry;
	    	 }
	    	 return new this.constructor().copy( this );
	     */
                return new Geometry().copy(this);
            },
            copy: function (source) {
                var i, il, j, jl, k, kl; // reset

                this.vertices = [];
                this.colors = [];
                this.faces = [];
                this.faceVertexUvs = [[]];
                this.morphTargets = [];
                this.morphNormals = [];
                this.skinWeights = [];
                this.skinIndices = [];
                this.lineDistances = [];
                this.boundingBox = null;
                this.boundingSphere = null; // name

                this.name = source.name; // vertices

                var vertices = source.vertices;

                for (i = 0, il = vertices.length; i < il; i++) {
                    this.vertices.push(vertices[i].clone());
                } // colors


                var colors = source.colors;

                for (i = 0, il = colors.length; i < il; i++) {
                    this.colors.push(colors[i].clone());
                } // faces


                var faces = source.faces;

                for (i = 0, il = faces.length; i < il; i++) {
                    this.faces.push(faces[i].clone());
                } // face vertex uvs


                for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                    var faceVertexUvs = source.faceVertexUvs[i];

                    if (this.faceVertexUvs[i] === undefined) {
                        this.faceVertexUvs[i] = [];
                    }

                    for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                        var uvs = faceVertexUvs[j],
                            uvsCopy = [];

                        for (k = 0, kl = uvs.length; k < kl; k++) {
                            var uv = uvs[k];
                            uvsCopy.push(uv.clone());
                        }

                        this.faceVertexUvs[i].push(uvsCopy);
                    }
                } // morph targets


                var morphTargets = source.morphTargets;

                for (i = 0, il = morphTargets.length; i < il; i++) {
                    var morphTarget = {};
                    morphTarget.name = morphTargets[i].name; // vertices

                    if (morphTargets[i].vertices !== undefined) {
                        morphTarget.vertices = [];

                        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                        }
                    } // normals


                    if (morphTargets[i].normals !== undefined) {
                        morphTarget.normals = [];

                        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                            morphTarget.normals.push(morphTargets[i].normals[j].clone());
                        }
                    }

                    this.morphTargets.push(morphTarget);
                } // morph normals


                var morphNormals = source.morphNormals;

                for (i = 0, il = morphNormals.length; i < il; i++) {
                    var morphNormal = {}; // vertex normals

                    if (morphNormals[i].vertexNormals !== undefined) {
                        morphNormal.vertexNormals = [];

                        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                            var srcVertexNormal = morphNormals[i].vertexNormals[j];
                            var destVertexNormal = {};
                            destVertexNormal.a = srcVertexNormal.a.clone();
                            destVertexNormal.b = srcVertexNormal.b.clone();
                            destVertexNormal.c = srcVertexNormal.c.clone();
                            morphNormal.vertexNormals.push(destVertexNormal);
                        }
                    } // face normals


                    if (morphNormals[i].faceNormals !== undefined) {
                        morphNormal.faceNormals = [];

                        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                        }
                    }

                    this.morphNormals.push(morphNormal);
                } // skin weights


                var skinWeights = source.skinWeights;

                for (i = 0, il = skinWeights.length; i < il; i++) {
                    this.skinWeights.push(skinWeights[i].clone());
                } // skin indices


                var skinIndices = source.skinIndices;

                for (i = 0, il = skinIndices.length; i < il; i++) {
                    this.skinIndices.push(skinIndices[i].clone());
                } // line distances


                var lineDistances = source.lineDistances;

                for (i = 0, il = lineDistances.length; i < il; i++) {
                    this.lineDistances.push(lineDistances[i]);
                } // bounding box


                var boundingBox = source.boundingBox;

                if (boundingBox !== null) {
                    this.boundingBox = boundingBox.clone();
                } // bounding sphere


                var boundingSphere = source.boundingSphere;

                if (boundingSphere !== null) {
                    this.boundingSphere = boundingSphere.clone();
                } // update flags


                this.elementsNeedUpdate = source.elementsNeedUpdate;
                this.verticesNeedUpdate = source.verticesNeedUpdate;
                this.uvsNeedUpdate = source.uvsNeedUpdate;
                this.normalsNeedUpdate = source.normalsNeedUpdate;
                this.colorsNeedUpdate = source.colorsNeedUpdate;
                this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
                this.groupsNeedUpdate = source.groupsNeedUpdate;
                return this;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var _vector$3 = new Vector3();

        function BufferAttribute(array, itemSize, normalized) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }

            this.name = '';
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized === true;
            this.usage = StaticDrawUsage;
            this.updateRange = {
                offset: 0,
                count: -1
            };
            this.version = 0;
        }

        Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
            set: function (value) {
                if (value === true) this.version++;
            }
        });
        Object.assign(BufferAttribute.prototype, {
            isBufferAttribute: true,
            onUploadCallback: function () {},
            setUsage: function (value) {
                this.usage = value;
                return this;
            },
            copy: function (source) {
                this.name = source.name;
                this.array = new source.array.constructor(source.array);
                this.itemSize = source.itemSize;
                this.count = source.count;
                this.normalized = source.normalized;
                this.usage = source.usage;
                return this;
            },
            copyAt: function (index1, attribute, index2) {
                index1 *= this.itemSize;
                index2 *= attribute.itemSize;

                for (var i = 0, l = this.itemSize; i < l; i++) {
                    this.array[index1 + i] = attribute.array[index2 + i];
                }

                return this;
            },
            copyArray: function (array) {
                this.array.set(array);
                return this;
            },
            copyColorsArray: function (colors) {
                var array = this.array,
                    offset = 0;

                for (var i = 0, l = colors.length; i < l; i++) {
                    var color = colors[i];

                    if (color === undefined) {
                        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                        color = new Color();
                    }

                    array[offset++] = color.r;
                    array[offset++] = color.g;
                    array[offset++] = color.b;
                }

                return this;
            },
            copyVector2sArray: function (vectors) {
                var array = this.array,
                    offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {
                    var vector = vectors[i];

                    if (vector === undefined) {
                        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                        vector = new Vector2();
                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;
                }

                return this;
            },
            copyVector3sArray: function (vectors) {
                var array = this.array,
                    offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {
                    var vector = vectors[i];

                    if (vector === undefined) {
                        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                        vector = new Vector3();
                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;
                    array[offset++] = vector.z;
                }

                return this;
            },
            copyVector4sArray: function (vectors) {
                var array = this.array,
                    offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {
                    var vector = vectors[i];

                    if (vector === undefined) {
                        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                        vector = new Vector4();
                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;
                    array[offset++] = vector.z;
                    array[offset++] = vector.w;
                }

                return this;
            },
            applyMatrix3: function (m) {
                for (var i = 0, l = this.count; i < l; i++) {
                    _vector$3.x = this.getX(i);
                    _vector$3.y = this.getY(i);
                    _vector$3.z = this.getZ(i);

                    _vector$3.applyMatrix3(m);

                    this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                }

                return this;
            },
            applyMatrix4: function (m) {
                for (var i = 0, l = this.count; i < l; i++) {
                    _vector$3.x = this.getX(i);
                    _vector$3.y = this.getY(i);
                    _vector$3.z = this.getZ(i);

                    _vector$3.applyMatrix4(m);

                    this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                }

                return this;
            },
            applyNormalMatrix: function (m) {
                for (var i = 0, l = this.count; i < l; i++) {
                    _vector$3.x = this.getX(i);
                    _vector$3.y = this.getY(i);
                    _vector$3.z = this.getZ(i);

                    _vector$3.applyNormalMatrix(m);

                    this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                }

                return this;
            },
            transformDirection: function (m) {
                for (var i = 0, l = this.count; i < l; i++) {
                    _vector$3.x = this.getX(i);
                    _vector$3.y = this.getY(i);
                    _vector$3.z = this.getZ(i);

                    _vector$3.transformDirection(m);

                    this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
                }

                return this;
            },
            set: function (value, offset) {
                if (offset === undefined) offset = 0;
                this.array.set(value, offset);
                return this;
            },
            getX: function (index) {
                return this.array[index * this.itemSize];
            },
            setX: function (index, x) {
                this.array[index * this.itemSize] = x;
                return this;
            },
            getY: function (index) {
                return this.array[index * this.itemSize + 1];
            },
            setY: function (index, y) {
                this.array[index * this.itemSize + 1] = y;
                return this;
            },
            getZ: function (index) {
                return this.array[index * this.itemSize + 2];
            },
            setZ: function (index, z) {
                this.array[index * this.itemSize + 2] = z;
                return this;
            },
            getW: function (index) {
                return this.array[index * this.itemSize + 3];
            },
            setW: function (index, w) {
                this.array[index * this.itemSize + 3] = w;
                return this;
            },
            setXY: function (index, x, y) {
                index *= this.itemSize;
                this.array[index + 0] = x;
                this.array[index + 1] = y;
                return this;
            },
            setXYZ: function (index, x, y, z) {
                index *= this.itemSize;
                this.array[index + 0] = x;
                this.array[index + 1] = y;
                this.array[index + 2] = z;
                return this;
            },
            setXYZW: function (index, x, y, z, w) {
                index *= this.itemSize;
                this.array[index + 0] = x;
                this.array[index + 1] = y;
                this.array[index + 2] = z;
                this.array[index + 3] = w;
                return this;
            },
            onUpload: function (callback) {
                this.onUploadCallback = callback;
                return this;
            },
            clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this);
            },
            toJSON: function () {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
            }
        }); //

        function Int8BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
        }

        Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

        function Uint8BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
        }

        Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

        function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
        }

        Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

        function Int16BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
        }

        Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

        function Uint16BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
        }

        Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

        function Int32BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
        }

        Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

        function Uint32BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
        }

        Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

        function Float32BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
        }

        Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

        function Float64BufferAttribute(array, itemSize, normalized) {
            BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
        }

        Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; //

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function DirectGeometry() {
            this.vertices = [];
            this.normals = [];
            this.colors = [];
            this.uvs = [];
            this.uvs2 = [];
            this.groups = [];
            this.morphTargets = {};
            this.skinWeights = [];
            this.skinIndices = []; // this.lineDistances = [];

            this.boundingBox = null;
            this.boundingSphere = null; // update flags

            this.verticesNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }

        Object.assign(DirectGeometry.prototype, {
            computeGroups: function (geometry) {
                var group;
                var groups = [];
                var materialIndex = undefined;
                var faces = geometry.faces;

                for (var i = 0; i < faces.length; i++) {
                    var face = faces[i]; // materials

                    if (face.materialIndex !== materialIndex) {
                        materialIndex = face.materialIndex;

                        if (group !== undefined) {
                            group.count = i * 3 - group.start;
                            groups.push(group);
                        }

                        group = {
                            start: i * 3,
                            materialIndex: materialIndex
                        };
                    }
                }

                if (group !== undefined) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                }

                this.groups = groups;
            },
            fromGeometry: function (geometry) {
                var faces = geometry.faces;
                var vertices = geometry.vertices;
                var faceVertexUvs = geometry.faceVertexUvs;
                var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
                var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

                var morphTargets = geometry.morphTargets;
                var morphTargetsLength = morphTargets.length;
                var morphTargetsPosition;

                if (morphTargetsLength > 0) {
                    morphTargetsPosition = [];

                    for (var i = 0; i < morphTargetsLength; i++) {
                        morphTargetsPosition[i] = {
                            name: morphTargets[i].name,
                            data: []
                        };
                    }

                    this.morphTargets.position = morphTargetsPosition;
                }

                var morphNormals = geometry.morphNormals;
                var morphNormalsLength = morphNormals.length;
                var morphTargetsNormal;

                if (morphNormalsLength > 0) {
                    morphTargetsNormal = [];

                    for (var i = 0; i < morphNormalsLength; i++) {
                        morphTargetsNormal[i] = {
                            name: morphNormals[i].name,
                            data: []
                        };
                    }

                    this.morphTargets.normal = morphTargetsNormal;
                } // skins


                var skinIndices = geometry.skinIndices;
                var skinWeights = geometry.skinWeights;
                var hasSkinIndices = skinIndices.length === vertices.length;
                var hasSkinWeights = skinWeights.length === vertices.length; //

                if (vertices.length > 0 && faces.length === 0) {
                    console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
                }

                for (var i = 0; i < faces.length; i++) {
                    var face = faces[i];
                    this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {
                        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                    } else {
                        var normal = face.normal;
                        this.normals.push(normal, normal, normal);
                    }

                    var vertexColors = face.vertexColors;

                    if (vertexColors.length === 3) {
                        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                    } else {
                        var color = face.color;
                        this.colors.push(color, color, color);
                    }

                    if (hasFaceVertexUv === true) {
                        var vertexUvs = faceVertexUvs[0][i];

                        if (vertexUvs !== undefined) {
                            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                        } else {
                            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                        }
                    }

                    if (hasFaceVertexUv2 === true) {
                        var vertexUvs = faceVertexUvs[1][i];

                        if (vertexUvs !== undefined) {
                            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                        } else {
                            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                        }
                    } // morphs


                    for (var j = 0; j < morphTargetsLength; j++) {
                        var morphTarget = morphTargets[j].vertices;
                        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                    }

                    for (var j = 0; j < morphNormalsLength; j++) {
                        var morphNormal = morphNormals[j].vertexNormals[i];
                        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
                    } // skins


                    if (hasSkinIndices) {
                        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                    }

                    if (hasSkinWeights) {
                        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                    }
                }

                this.computeGroups(geometry);
                this.verticesNeedUpdate = geometry.verticesNeedUpdate;
                this.normalsNeedUpdate = geometry.normalsNeedUpdate;
                this.colorsNeedUpdate = geometry.colorsNeedUpdate;
                this.uvsNeedUpdate = geometry.uvsNeedUpdate;
                this.groupsNeedUpdate = geometry.groupsNeedUpdate;

                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }

                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }

                return this;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function arrayMax(array) {
            if (array.length === 0) return -Infinity;
            var max = array[0];

            for (var i = 1, l = array.length; i < l; ++i) {
                if (array[i] > max) max = array[i];
            }

            return max;
        }

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

        var _m1$3 = new Matrix4();

        var _obj$1 = new Object3D();

        var _offset$1 = new Vector3();

        var _box$2 = new Box3();

        var _boxMorphTargets = new Box3();

        var _vector$4 = new Vector3();

        function BufferGeometry() {
            Object.defineProperty(this, 'id', {
                value: _bufferGeometryId += 2
            });
            this.uuid = MathUtils.generateUUID();
            this.name = '';
            this.type = 'BufferGeometry';
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.morphTargetsRelative = false;
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.drawRange = {
                start: 0,
                count: Infinity
            };
            this.userData = {};
        }

        BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: BufferGeometry,
            isBufferGeometry: true,
            getIndex: function () {
                return this.index;
            },
            setIndex: function (index) {
                if (Array.isArray(index)) {
                    this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
                } else {
                    this.index = index;
                }
            },
            getAttribute: function (name) {
                return this.attributes[name];
            },
            setAttribute: function (name, attribute) {
                this.attributes[name] = attribute;
                return this;
            },
            deleteAttribute: function (name) {
                delete this.attributes[name];
                return this;
            },
            addGroup: function (start, count, materialIndex) {
                this.groups.push({
                    start: start,
                    count: count,
                    materialIndex: materialIndex !== undefined ? materialIndex : 0
                });
            },
            clearGroups: function () {
                this.groups = [];
            },
            setDrawRange: function (start, count) {
                this.drawRange.start = start;
                this.drawRange.count = count;
            },
            applyMatrix4: function (matrix) {
                var position = this.attributes.position;

                if (position !== undefined) {
                    position.applyMatrix4(matrix);
                    position.needsUpdate = true;
                }

                var normal = this.attributes.normal;

                if (normal !== undefined) {
                    var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                    normal.applyNormalMatrix(normalMatrix);
                    normal.needsUpdate = true;
                }

                var tangent = this.attributes.tangent;

                if (tangent !== undefined) {
                    tangent.transformDirection(matrix);
                    tangent.needsUpdate = true;
                }

                if (this.boundingBox !== null) {
                    this.computeBoundingBox();
                }

                if (this.boundingSphere !== null) {
                    this.computeBoundingSphere();
                }

                return this;
            },
            rotateX: function (angle) {
                // rotate geometry around world x-axis
                _m1$3.makeRotationX(angle);

                this.applyMatrix4(_m1$3);
                return this;
            },
            rotateY: function (angle) {
                // rotate geometry around world y-axis
                _m1$3.makeRotationY(angle);

                this.applyMatrix4(_m1$3);
                return this;
            },
            rotateZ: function (angle) {
                // rotate geometry around world z-axis
                _m1$3.makeRotationZ(angle);

                this.applyMatrix4(_m1$3);
                return this;
            },
            translate: function (x, y, z) {
                // translate geometry
                _m1$3.makeTranslation(x, y, z);

                this.applyMatrix4(_m1$3);
                return this;
            },
            scale: function (x, y, z) {
                // scale geometry
                _m1$3.makeScale(x, y, z);

                this.applyMatrix4(_m1$3);
                return this;
            },
            lookAt: function (vector) {
                _obj$1.lookAt(vector);

                _obj$1.updateMatrix();

                this.applyMatrix4(_obj$1.matrix);
                return this;
            },
            center: function () {
                this.computeBoundingBox();
                this.boundingBox.getCenter(_offset$1).negate();
                this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
                return this;
            },
            setFromObject: function (object) {
                // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
                var geometry = object.geometry;

                if (object.isPoints || object.isLine) {
                    var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                    var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                    this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
                    this.setAttribute('color', colors.copyColorsArray(geometry.colors));

                    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                    }

                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone();
                    }

                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone();
                    }
                } else if (object.isMesh) {
                    if (geometry && geometry.isGeometry) {
                        this.fromGeometry(geometry);
                    }
                }

                return this;
            },
            setFromPoints: function (points) {
                var position = [];

                for (var i = 0, l = points.length; i < l; i++) {
                    var point = points[i];
                    position.push(point.x, point.y, point.z || 0);
                }

                this.setAttribute('position', new Float32BufferAttribute(position, 3));
                return this;
            },
            updateFromObject: function (object) {
                var geometry = object.geometry;

                if (object.isMesh) {
                    var direct = geometry.__directGeometry;

                    if (geometry.elementsNeedUpdate === true) {
                        direct = undefined;
                        geometry.elementsNeedUpdate = false;
                    }

                    if (direct === undefined) {
                        return this.fromGeometry(geometry);
                    }

                    direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                    direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                    direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                    direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                    direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                    geometry.verticesNeedUpdate = false;
                    geometry.normalsNeedUpdate = false;
                    geometry.colorsNeedUpdate = false;
                    geometry.uvsNeedUpdate = false;
                    geometry.groupsNeedUpdate = false;
                    geometry = direct;
                }

                var attribute;

                if (geometry.verticesNeedUpdate === true) {
                    attribute = this.attributes.position;

                    if (attribute !== undefined) {
                        attribute.copyVector3sArray(geometry.vertices);
                        attribute.needsUpdate = true;
                    }

                    geometry.verticesNeedUpdate = false;
                }

                if (geometry.normalsNeedUpdate === true) {
                    attribute = this.attributes.normal;

                    if (attribute !== undefined) {
                        attribute.copyVector3sArray(geometry.normals);
                        attribute.needsUpdate = true;
                    }

                    geometry.normalsNeedUpdate = false;
                }

                if (geometry.colorsNeedUpdate === true) {
                    attribute = this.attributes.color;

                    if (attribute !== undefined) {
                        attribute.copyColorsArray(geometry.colors);
                        attribute.needsUpdate = true;
                    }

                    geometry.colorsNeedUpdate = false;
                }

                if (geometry.uvsNeedUpdate) {
                    attribute = this.attributes.uv;

                    if (attribute !== undefined) {
                        attribute.copyVector2sArray(geometry.uvs);
                        attribute.needsUpdate = true;
                    }

                    geometry.uvsNeedUpdate = false;
                }

                if (geometry.lineDistancesNeedUpdate) {
                    attribute = this.attributes.lineDistance;

                    if (attribute !== undefined) {
                        attribute.copyArray(geometry.lineDistances);
                        attribute.needsUpdate = true;
                    }

                    geometry.lineDistancesNeedUpdate = false;
                }

                if (geometry.groupsNeedUpdate) {
                    geometry.computeGroups(object.geometry);
                    this.groups = geometry.groups;
                    geometry.groupsNeedUpdate = false;
                }

                return this;
            },
            fromGeometry: function (geometry) {
                geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
                return this.fromDirectGeometry(geometry.__directGeometry);
            },
            fromDirectGeometry: function (geometry) {
                var positions = new Float32Array(geometry.vertices.length * 3);
                this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

                if (geometry.normals.length > 0) {
                    var normals = new Float32Array(geometry.normals.length * 3);
                    this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
                }

                if (geometry.colors.length > 0) {
                    var colors = new Float32Array(geometry.colors.length * 3);
                    this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
                }

                if (geometry.uvs.length > 0) {
                    var uvs = new Float32Array(geometry.uvs.length * 2);
                    this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
                }

                if (geometry.uvs2.length > 0) {
                    var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                    this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
                } // groups


                this.groups = geometry.groups; // morphs

                for (var name in geometry.morphTargets) {
                    var array = [];
                    var morphTargets = geometry.morphTargets[name];

                    for (var i = 0, l = morphTargets.length; i < l; i++) {
                        var morphTarget = morphTargets[i];
                        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                        attribute.name = morphTarget.name;
                        array.push(attribute.copyVector3sArray(morphTarget.data));
                    }

                    this.morphAttributes[name] = array;
                } // skinning


                if (geometry.skinIndices.length > 0) {
                    var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                    this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
                }

                if (geometry.skinWeights.length > 0) {
                    var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                    this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
                } //


                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }

                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }

                return this;
            },
            computeBoundingBox: function () {
                if (this.boundingBox === null) {
                    this.boundingBox = new Box3();
                }

                var position = this.attributes.position;
                var morphAttributesPosition = this.morphAttributes.position;

                if (position !== undefined) {
                    this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

                    if (morphAttributesPosition) {
                        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                            var morphAttribute = morphAttributesPosition[i];

                            _box$2.setFromBufferAttribute(morphAttribute);

                            if (this.morphTargetsRelative) {
                                _vector$4.addVectors(this.boundingBox.min, _box$2.min);

                                this.boundingBox.expandByPoint(_vector$4);

                                _vector$4.addVectors(this.boundingBox.max, _box$2.max);

                                this.boundingBox.expandByPoint(_vector$4);
                            } else {
                                this.boundingBox.expandByPoint(_box$2.min);
                                this.boundingBox.expandByPoint(_box$2.max);
                            }
                        }
                    }
                } else {
                    this.boundingBox.makeEmpty();
                }

                if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                    console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
                }
            },
            computeBoundingSphere: function () {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new Sphere();
                }

                var position = this.attributes.position;
                var morphAttributesPosition = this.morphAttributes.position;

                if (position) {
                    // first, find the center of the bounding sphere
                    var center = this.boundingSphere.center;

                    _box$2.setFromBufferAttribute(position); // process morph attributes if present


                    if (morphAttributesPosition) {
                        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                            var morphAttribute = morphAttributesPosition[i];

                            _boxMorphTargets.setFromBufferAttribute(morphAttribute);

                            if (this.morphTargetsRelative) {
                                _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

                                _box$2.expandByPoint(_vector$4);

                                _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

                                _box$2.expandByPoint(_vector$4);
                            } else {
                                _box$2.expandByPoint(_boxMorphTargets.min);

                                _box$2.expandByPoint(_boxMorphTargets.max);
                            }
                        }
                    }

                    _box$2.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
                    // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


                    var maxRadiusSq = 0;

                    for (var i = 0, il = position.count; i < il; i++) {
                        _vector$4.fromBufferAttribute(position, i);

                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
                    } // process morph attributes if present


                    if (morphAttributesPosition) {
                        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                            var morphAttribute = morphAttributesPosition[i];
                            var morphTargetsRelative = this.morphTargetsRelative;

                            for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
                                _vector$4.fromBufferAttribute(morphAttribute, j);

                                if (morphTargetsRelative) {
                                    _offset$1.fromBufferAttribute(position, j);

                                    _vector$4.add(_offset$1);
                                }

                                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
                            }
                        }
                    }

                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

                    if (isNaN(this.boundingSphere.radius)) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            },
            computeFaceNormals: function () {// backwards compatibility
            },
            computeVertexNormals: function () {
                var index = this.index;
                var attributes = this.attributes;

                if (attributes.position) {
                    var positions = attributes.position.array;

                    if (attributes.normal === undefined) {
                        this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
                    } else {
                        // reset existing normals to zero
                        var array = attributes.normal.array;

                        for (var i = 0, il = array.length; i < il; i++) {
                            array[i] = 0;
                        }
                    }

                    var normals = attributes.normal.array;
                    var vA, vB, vC;
                    var pA = new Vector3(),
                        pB = new Vector3(),
                        pC = new Vector3();
                    var cb = new Vector3(),
                        ab = new Vector3(); // indexed elements

                    if (index) {
                        var indices = index.array;

                        for (var i = 0, il = index.count; i < il; i += 3) {
                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    } else {
                        // non-indexed elements (unconnected triangle soup)
                        for (var i = 0, il = positions.length; i < il; i += 9) {
                            pA.fromArray(positions, i);
                            pB.fromArray(positions, i + 3);
                            pC.fromArray(positions, i + 6);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[i] = cb.x;
                            normals[i + 1] = cb.y;
                            normals[i + 2] = cb.z;
                            normals[i + 3] = cb.x;
                            normals[i + 4] = cb.y;
                            normals[i + 5] = cb.z;
                            normals[i + 6] = cb.x;
                            normals[i + 7] = cb.y;
                            normals[i + 8] = cb.z;
                        }
                    }

                    this.normalizeNormals();
                    attributes.normal.needsUpdate = true;
                }
            },
            merge: function (geometry, offset) {
                if (!(geometry && geometry.isBufferGeometry)) {
                    console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                    return;
                }

                if (offset === undefined) {
                    offset = 0;
                    console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
                }

                var attributes = this.attributes;

                for (var key in attributes) {
                    if (geometry.attributes[key] === undefined) continue;
                    var attribute1 = attributes[key];
                    var attributeArray1 = attribute1.array;
                    var attribute2 = geometry.attributes[key];
                    var attributeArray2 = attribute2.array;
                    var attributeOffset = attribute2.itemSize * offset;
                    var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

                    for (var i = 0, j = attributeOffset; i < length; i++, j++) {
                        attributeArray1[j] = attributeArray2[i];
                    }
                }

                return this;
            },
            normalizeNormals: function () {
                var normals = this.attributes.normal;

                for (var i = 0, il = normals.count; i < il; i++) {
                    _vector$4.x = normals.getX(i);
                    _vector$4.y = normals.getY(i);
                    _vector$4.z = normals.getZ(i);

                    _vector$4.normalize();

                    normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
                }
            },
            toNonIndexed: function () {
                function convertBufferAttribute(attribute, indices) {
                    var array = attribute.array;
                    var itemSize = attribute.itemSize;
                    var array2 = new array.constructor(indices.length * itemSize);
                    var index = 0,
                        index2 = 0;

                    for (var i = 0, l = indices.length; i < l; i++) {
                        index = indices[i] * itemSize;

                        for (var j = 0; j < itemSize; j++) {
                            array2[index2++] = array[index++];
                        }
                    }

                    return new BufferAttribute(array2, itemSize);
                } //


                if (this.index === null) {
                    console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                    return this;
                }

                var geometry2 = new BufferGeometry();
                var indices = this.index.array;
                var attributes = this.attributes; // attributes

                for (var name in attributes) {
                    var attribute = attributes[name];
                    var newAttribute = convertBufferAttribute(attribute, indices);
                    geometry2.setAttribute(name, newAttribute);
                } // morph attributes


                var morphAttributes = this.morphAttributes;

                for (name in morphAttributes) {
                    var morphArray = [];
                    var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

                    for (var i = 0, il = morphAttribute.length; i < il; i++) {
                        var attribute = morphAttribute[i];
                        var newAttribute = convertBufferAttribute(attribute, indices);
                        morphArray.push(newAttribute);
                    }

                    geometry2.morphAttributes[name] = morphArray;
                }

                geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

                var groups = this.groups;

                for (var i = 0, l = groups.length; i < l; i++) {
                    var group = groups[i];
                    geometry2.addGroup(group.start, group.count, group.materialIndex);
                }

                return geometry2;
            },
            toJSON: function () {
                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'BufferGeometry',
                        generator: 'BufferGeometry.toJSON'
                    }
                }; // standard BufferGeometry serialization

                data.uuid = this.uuid;
                data.type = this.type;
                if (this.name !== '') data.name = this.name;
                if (Object.keys(this.userData).length > 0) data.userData = this.userData;

                if (this.parameters !== undefined) {
                    var parameters = this.parameters;

                    for (var key in parameters) {
                        if (parameters[key] !== undefined) data[key] = parameters[key];
                    }

                    return data;
                }

                data.data = {
                    attributes: {}
                };
                var index = this.index;

                if (index !== null) {
                    data.data.index = {
                        type: index.array.constructor.name,
                        array: Array.prototype.slice.call(index.array)
                    };
                }

                var attributes = this.attributes;

                for (var key in attributes) {
                    var attribute = attributes[key];
                    var attributeData = attribute.toJSON();
                    if (attribute.name !== '') attributeData.name = attribute.name;
                    data.data.attributes[key] = attributeData;
                }

                var morphAttributes = {};
                var hasMorphAttributes = false;

                for (var key in this.morphAttributes) {
                    var attributeArray = this.morphAttributes[key];
                    var array = [];

                    for (var i = 0, il = attributeArray.length; i < il; i++) {
                        var attribute = attributeArray[i];
                        var attributeData = attribute.toJSON();
                        if (attribute.name !== '') attributeData.name = attribute.name;
                        array.push(attributeData);
                    }

                    if (array.length > 0) {
                        morphAttributes[key] = array;
                        hasMorphAttributes = true;
                    }
                }

                if (hasMorphAttributes) {
                    data.data.morphAttributes = morphAttributes;
                    data.data.morphTargetsRelative = this.morphTargetsRelative;
                }

                var groups = this.groups;

                if (groups.length > 0) {
                    data.data.groups = JSON.parse(JSON.stringify(groups));
                }

                var boundingSphere = this.boundingSphere;

                if (boundingSphere !== null) {
                    data.data.boundingSphere = {
                        center: boundingSphere.center.toArray(),
                        radius: boundingSphere.radius
                    };
                }

                return data;
            },
            clone: function () {
                /*
	     // Handle primitives
	    	 var parameters = this.parameters;
	    	 if ( parameters !== undefined ) {
	    	 var values = [];
	    	 for ( var key in parameters ) {
	    	 values.push( parameters[ key ] );
	    	 }
	    	 var geometry = Object.create( this.constructor.prototype );
	     this.constructor.apply( geometry, values );
	     return geometry;
	    	 }
	    	 return new this.constructor().copy( this );
	     */
                return new BufferGeometry().copy(this);
            },
            copy: function (source) {
                var name, i, l; // reset

                this.index = null;
                this.attributes = {};
                this.morphAttributes = {};
                this.groups = [];
                this.boundingBox = null;
                this.boundingSphere = null; // name

                this.name = source.name; // index

                var index = source.index;

                if (index !== null) {
                    this.setIndex(index.clone());
                } // attributes


                var attributes = source.attributes;

                for (name in attributes) {
                    var attribute = attributes[name];
                    this.setAttribute(name, attribute.clone());
                } // morph attributes


                var morphAttributes = source.morphAttributes;

                for (name in morphAttributes) {
                    var array = [];
                    var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

                    for (i = 0, l = morphAttribute.length; i < l; i++) {
                        array.push(morphAttribute[i].clone());
                    }

                    this.morphAttributes[name] = array;
                }

                this.morphTargetsRelative = source.morphTargetsRelative; // groups

                var groups = source.groups;

                for (i = 0, l = groups.length; i < l; i++) {
                    var group = groups[i];
                    this.addGroup(group.start, group.count, group.materialIndex);
                } // bounding box


                var boundingBox = source.boundingBox;

                if (boundingBox !== null) {
                    this.boundingBox = boundingBox.clone();
                } // bounding sphere


                var boundingSphere = source.boundingSphere;

                if (boundingSphere !== null) {
                    this.boundingSphere = boundingSphere.clone();
                } // draw range


                this.drawRange.start = source.drawRange.start;
                this.drawRange.count = source.drawRange.count; // user data

                this.userData = source.userData;
                return this;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */


        class BoxBufferGeometry extends BufferGeometry {
            constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
                super();
                this.type = 'BoxBufferGeometry';
                this.parameters = {
                    width: width,
                    height: height,
                    depth: depth,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    depthSegments: depthSegments
                };
                var scope = this;
                width = width || 1;
                height = height || 1;
                depth = depth || 1; // segments

                widthSegments = Math.floor(widthSegments) || 1;
                heightSegments = Math.floor(heightSegments) || 1;
                depthSegments = Math.floor(depthSegments) || 1; // buffers

                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = []; // helper variables

                var numberOfVertices = 0;
                var groupStart = 0; // build each side of the box geometry

                buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

                buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

                buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

                buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

                buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

                buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
                // build geometry

                this.setIndex(indices);
                this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                    var segmentWidth = width / gridX;
                    var segmentHeight = height / gridY;
                    var widthHalf = width / 2;
                    var heightHalf = height / 2;
                    var depthHalf = depth / 2;
                    var gridX1 = gridX + 1;
                    var gridY1 = gridY + 1;
                    var vertexCounter = 0;
                    var groupCount = 0;
                    var ix, iy;
                    var vector = new Vector3(); // generate vertices, normals and uvs

                    for (iy = 0; iy < gridY1; iy++) {
                        var y = iy * segmentHeight - heightHalf;

                        for (ix = 0; ix < gridX1; ix++) {
                            var x = ix * segmentWidth - widthHalf; // set values to correct vector component

                            vector[u] = x * udir;
                            vector[v] = y * vdir;
                            vector[w] = depthHalf; // now apply vector to vertex buffer

                            vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

                            vector[u] = 0;
                            vector[v] = 0;
                            vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

                            normals.push(vector.x, vector.y, vector.z); // uvs

                            uvs.push(ix / gridX);
                            uvs.push(1 - iy / gridY); // counters

                            vertexCounter += 1;
                        }
                    } // indices
                    // 1. you need three indices to draw a single face
                    // 2. a single segment consists of two faces
                    // 3. so we need to generate six (2*3) indices per segment


                    for (iy = 0; iy < gridY; iy++) {
                        for (ix = 0; ix < gridX; ix++) {
                            var a = numberOfVertices + ix + gridX1 * iy;
                            var b = numberOfVertices + ix + gridX1 * (iy + 1);
                            var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                            var d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

                            indices.push(a, b, d);
                            indices.push(b, c, d); // increase counter

                            groupCount += 6;
                        }
                    } // add a group to the geometry. this will ensure multi material support


                    scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

                    groupStart += groupCount; // update total number of vertices

                    numberOfVertices += vertexCounter;
                }
            }

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        function PlaneGeometry(width, height, widthSegments, heightSegments) {
            Geometry.call(this);
            this.type = 'PlaneGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
            this.mergeVertices();
        }

        PlaneGeometry.prototype = Object.create(Geometry.prototype);
        PlaneGeometry.prototype.constructor = PlaneGeometry; // PlaneBufferGeometry

        function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
            BufferGeometry.call(this);
            this.type = 'PlaneBufferGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            width = width || 1;
            height = height || 1;
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor(widthSegments) || 1;
            var gridY = Math.floor(heightSegments) || 1;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY;
            var ix, iy; // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // generate vertices, normals and uvs

            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segment_height - height_half;

                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segment_width - width_half;
                    vertices.push(x, -y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                }
            } // indices


            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = ix + 1 + gridX1 * (iy + 1);
                    var d = ix + 1 + gridX1 * iy; // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            } // build geometry


            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }

        PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        var materialId = 0;

        function Material() {
            Object.defineProperty(this, 'id', {
                value: materialId++
            });
            this.uuid = MathUtils.generateUUID();
            this.name = '';
            this.type = 'Material';
            this.fog = true;
            this.blending = NormalBlending;
            this.side = FrontSide;
            this.flatShading = false;
            this.vertexColors = false;
            this.opacity = 1;
            this.transparent = false;
            this.blendSrc = SrcAlphaFactor;
            this.blendDst = OneMinusSrcAlphaFactor;
            this.blendEquation = AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;
            this.depthFunc = LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;
            this.stencilWriteMask = 0xff;
            this.stencilFunc = AlwaysStencilFunc;
            this.stencilRef = 0;
            this.stencilFuncMask = 0xff;
            this.stencilFail = KeepStencilOp;
            this.stencilZFail = KeepStencilOp;
            this.stencilZPass = KeepStencilOp;
            this.stencilWrite = false;
            this.clippingPlanes = null;
            this.clipIntersection = false;
            this.clipShadows = false;
            this.shadowSide = null;
            this.colorWrite = true;
            this.precision = null; // override the renderer's default precision for this material

            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;
            this.dithering = false;
            this.alphaTest = 0;
            this.premultipliedAlpha = false;
            this.visible = true;
            this.toneMapped = true;
            this.userData = {};
            this.version = 0;
        }

        Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: Material,
            isMaterial: true,
            onBeforeCompile: function () {},
            setValues: function (values) {
                if (values === undefined) return;

                for (var key in values) {
                    var newValue = values[key];

                    if (newValue === undefined) {
                        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                        continue;
                    } // for backward compatability if shading is set in the constructor


                    if (key === 'shading') {
                        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                        this.flatShading = newValue === FlatShading ? true : false;
                        continue;
                    }

                    var currentValue = this[key];

                    if (currentValue === undefined) {
                        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                        continue;
                    }

                    if (currentValue && currentValue.isColor) {
                        currentValue.set(newValue);
                    } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
                        currentValue.copy(newValue);
                    } else {
                        this[key] = newValue;
                    }
                }
            },
            toJSON: function (meta) {
                var isRoot = meta === undefined || typeof meta === 'string';

                if (isRoot) {
                    meta = {
                        textures: {},
                        images: {}
                    };
                }

                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Material',
                        generator: 'Material.toJSON'
                    }
                }; // standard Material serialization

                data.uuid = this.uuid;
                data.type = this.type;
                if (this.name !== '') data.name = this.name;
                if (this.color && this.color.isColor) data.color = this.color.getHex();
                if (this.roughness !== undefined) data.roughness = this.roughness;
                if (this.metalness !== undefined) data.metalness = this.metalness;
                if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
                if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
                if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
                if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
                if (this.shininess !== undefined) data.shininess = this.shininess;
                if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
                if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

                if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                    data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                    data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
                }

                if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
                if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
                if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

                if (this.aoMap && this.aoMap.isTexture) {
                    data.aoMap = this.aoMap.toJSON(meta).uuid;
                    data.aoMapIntensity = this.aoMapIntensity;
                }

                if (this.bumpMap && this.bumpMap.isTexture) {
                    data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                    data.bumpScale = this.bumpScale;
                }

                if (this.normalMap && this.normalMap.isTexture) {
                    data.normalMap = this.normalMap.toJSON(meta).uuid;
                    data.normalMapType = this.normalMapType;
                    data.normalScale = this.normalScale.toArray();
                }

                if (this.displacementMap && this.displacementMap.isTexture) {
                    data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                    data.displacementScale = this.displacementScale;
                    data.displacementBias = this.displacementBias;
                }

                if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
                if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

                if (this.envMap && this.envMap.isTexture) {
                    data.envMap = this.envMap.toJSON(meta).uuid;
                    data.reflectivity = this.reflectivity; // Scale behind envMap

                    data.refractionRatio = this.refractionRatio;
                    if (this.combine !== undefined) data.combine = this.combine;
                    if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
                }

                if (this.gradientMap && this.gradientMap.isTexture) {
                    data.gradientMap = this.gradientMap.toJSON(meta).uuid;
                }

                if (this.size !== undefined) data.size = this.size;
                if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
                if (this.blending !== NormalBlending) data.blending = this.blending;
                if (this.flatShading === true) data.flatShading = this.flatShading;
                if (this.side !== FrontSide) data.side = this.side;
                if (this.vertexColors) data.vertexColors = true;
                if (this.opacity < 1) data.opacity = this.opacity;
                if (this.transparent === true) data.transparent = this.transparent;
                data.depthFunc = this.depthFunc;
                data.depthTest = this.depthTest;
                data.depthWrite = this.depthWrite;
                data.stencilWrite = this.stencilWrite;
                data.stencilWriteMask = this.stencilWriteMask;
                data.stencilFunc = this.stencilFunc;
                data.stencilRef = this.stencilRef;
                data.stencilFuncMask = this.stencilFuncMask;
                data.stencilFail = this.stencilFail;
                data.stencilZFail = this.stencilZFail;
                data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

                if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
                if (this.polygonOffset === true) data.polygonOffset = true;
                if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
                if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
                if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
                if (this.dashSize !== undefined) data.dashSize = this.dashSize;
                if (this.gapSize !== undefined) data.gapSize = this.gapSize;
                if (this.scale !== undefined) data.scale = this.scale;
                if (this.dithering === true) data.dithering = true;
                if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
                if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
                if (this.wireframe === true) data.wireframe = this.wireframe;
                if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
                if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
                if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
                if (this.morphTargets === true) data.morphTargets = true;
                if (this.morphNormals === true) data.morphNormals = true;
                if (this.skinning === true) data.skinning = true;
                if (this.visible === false) data.visible = false;
                if (this.toneMapped === false) data.toneMapped = false;
                if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

                function extractFromCache(cache) {
                    var values = [];

                    for (var key in cache) {
                        var data = cache[key];
                        delete data.metadata;
                        values.push(data);
                    }

                    return values;
                }

                if (isRoot) {
                    var textures = extractFromCache(meta.textures);
                    var images = extractFromCache(meta.images);
                    if (textures.length > 0) data.textures = textures;
                    if (images.length > 0) data.images = images;
                }

                return data;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (source) {
                this.name = source.name;
                this.fog = source.fog;
                this.blending = source.blending;
                this.side = source.side;
                this.flatShading = source.flatShading;
                this.vertexColors = source.vertexColors;
                this.opacity = source.opacity;
                this.transparent = source.transparent;
                this.blendSrc = source.blendSrc;
                this.blendDst = source.blendDst;
                this.blendEquation = source.blendEquation;
                this.blendSrcAlpha = source.blendSrcAlpha;
                this.blendDstAlpha = source.blendDstAlpha;
                this.blendEquationAlpha = source.blendEquationAlpha;
                this.depthFunc = source.depthFunc;
                this.depthTest = source.depthTest;
                this.depthWrite = source.depthWrite;
                this.stencilWriteMask = source.stencilWriteMask;
                this.stencilFunc = source.stencilFunc;
                this.stencilRef = source.stencilRef;
                this.stencilFuncMask = source.stencilFuncMask;
                this.stencilFail = source.stencilFail;
                this.stencilZFail = source.stencilZFail;
                this.stencilZPass = source.stencilZPass;
                this.stencilWrite = source.stencilWrite;
                var srcPlanes = source.clippingPlanes,
                    dstPlanes = null;

                if (srcPlanes !== null) {
                    var n = srcPlanes.length;
                    dstPlanes = new Array(n);

                    for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
                }

                this.clippingPlanes = dstPlanes;
                this.clipIntersection = source.clipIntersection;
                this.clipShadows = source.clipShadows;
                this.shadowSide = source.shadowSide;
                this.colorWrite = source.colorWrite;
                this.precision = source.precision;
                this.polygonOffset = source.polygonOffset;
                this.polygonOffsetFactor = source.polygonOffsetFactor;
                this.polygonOffsetUnits = source.polygonOffsetUnits;
                this.dithering = source.dithering;
                this.alphaTest = source.alphaTest;
                this.premultipliedAlpha = source.premultipliedAlpha;
                this.visible = source.visible;
                this.toneMapped = source.toneMapped;
                this.userData = JSON.parse(JSON.stringify(source.userData));
                return this;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            }
        });
        Object.defineProperty(Material.prototype, 'needsUpdate', {
            set: function (value) {
                if (value === true) this.version++;
            }
        });

        /**
         * Uniform Utilities
         */
        function cloneUniforms(src) {
            var dst = {};

            for (var u in src) {
                dst[u] = {};

                for (var p in src[u]) {
                    var property = src[u][p];

                    if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
                        dst[u][p] = property.clone();
                    } else if (Array.isArray(property)) {
                        dst[u][p] = property.slice();
                    } else {
                        dst[u][p] = property;
                    }
                }
            }

            return dst;
        }
        function mergeUniforms(uniforms) {
            var merged = {};

            for (var u = 0; u < uniforms.length; u++) {
                var tmp = cloneUniforms(uniforms[u]);

                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }

            return merged;
        } // Legacy

        var UniformsUtils = {
            clone: cloneUniforms,
            merge: mergeUniforms
        };

        var default_vertex = /* glsl */
            `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`	;

        var default_fragment = /* glsl */
            `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`	;

        /**
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
         *  defines: { "label" : "value" },
         *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
         *
         *  fragmentShader: <string>,
         *  vertexShader: <string>,
         *
         *  wireframe: <boolean>,
         *  wireframeLinewidth: <float>,
         *
         *  lights: <bool>,
         *
         *  skinning: <bool>,
         *  morphTargets: <bool>,
         *  morphNormals: <bool>
         * }
         */

        function ShaderMaterial(parameters) {
            Material.call(this);
            this.type = 'ShaderMaterial';
            this.defines = {};
            this.uniforms = {};
            this.vertexShader = default_vertex;
            this.fragmentShader = default_fragment;
            this.linewidth = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false; // set to use scene fog

            this.lights = false; // set to use scene lights

            this.clipping = false; // set to use user-defined clipping planes

            this.skinning = false; // set to use skinning attribute streams

            this.morphTargets = false; // set to use morph targets

            this.morphNormals = false; // set to use morph normals

            this.extensions = {
                derivatives: false,
                // set to use derivatives
                fragDepth: false,
                // set to use fragment depth values
                drawBuffers: false,
                // set to use draw buffers
                shaderTextureLOD: false // set to use shader texture LOD

            }; // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.

            this.defaultAttributeValues = {
                'color': [1, 1, 1],
                'uv': [0, 0],
                'uv2': [0, 0]
            };
            this.index0AttributeName = undefined;
            this.uniformsNeedUpdate = false;

            if (parameters !== undefined) {
                if (parameters.attributes !== undefined) {
                    console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
                }

                this.setValues(parameters);
            }
        }

        ShaderMaterial.prototype = Object.create(Material.prototype);
        ShaderMaterial.prototype.constructor = ShaderMaterial;
        ShaderMaterial.prototype.isShaderMaterial = true;

        ShaderMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;
            this.uniforms = cloneUniforms(source.uniforms);
            this.defines = Object.assign({}, source.defines);
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.lights = source.lights;
            this.clipping = source.clipping;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            this.extensions = source.extensions;
            return this;
        };

        ShaderMaterial.prototype.toJSON = function (meta) {
            var data = Material.prototype.toJSON.call(this, meta);
            data.uniforms = {};

            for (var name in this.uniforms) {
                var uniform = this.uniforms[name];
                var value = uniform.value;

                if (value && value.isTexture) {
                    data.uniforms[name] = {
                        type: 't',
                        value: value.toJSON(meta).uuid
                    };
                } else if (value && value.isColor) {
                    data.uniforms[name] = {
                        type: 'c',
                        value: value.getHex()
                    };
                } else if (value && value.isVector2) {
                    data.uniforms[name] = {
                        type: 'v2',
                        value: value.toArray()
                    };
                } else if (value && value.isVector3) {
                    data.uniforms[name] = {
                        type: 'v3',
                        value: value.toArray()
                    };
                } else if (value && value.isVector4) {
                    data.uniforms[name] = {
                        type: 'v4',
                        value: value.toArray()
                    };
                } else if (value && value.isMatrix3) {
                    data.uniforms[name] = {
                        type: 'm3',
                        value: value.toArray()
                    };
                } else if (value && value.isMatrix4) {
                    data.uniforms[name] = {
                        type: 'm4',
                        value: value.toArray()
                    };
                } else {
                    data.uniforms[name] = {
                        value: value
                    }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                }
            }

            if (Object.keys(this.defines).length > 0) data.defines = this.defines;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;
            var extensions = {};

            for (var key in this.extensions) {
                if (this.extensions[key] === true) extensions[key] = true;
            }

            if (Object.keys(extensions).length > 0) data.extensions = extensions;
            return data;
        };

        var _vector$5 = new Vector3();

        var _segCenter = new Vector3();

        var _segDir = new Vector3();

        var _diff = new Vector3();

        var _edge1 = new Vector3();

        var _edge2 = new Vector3();

        var _normal = new Vector3();
        /**
         * @author bhouston / http://clara.io
         */


        function Ray(origin, direction) {
            this.origin = origin !== undefined ? origin : new Vector3();
            this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
        }

        Object.assign(Ray.prototype, {
            set: function (origin, direction) {
                this.origin.copy(origin);
                this.direction.copy(direction);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (ray) {
                this.origin.copy(ray.origin);
                this.direction.copy(ray.direction);
                return this;
            },
            at: function (t, target) {
                if (target === undefined) {
                    console.warn('THREE.Ray: .at() target is now required');
                    target = new Vector3();
                }

                return target.copy(this.direction).multiplyScalar(t).add(this.origin);
            },
            lookAt: function (v) {
                this.direction.copy(v).sub(this.origin).normalize();
                return this;
            },
            recast: function (t) {
                this.origin.copy(this.at(t, _vector$5));
                return this;
            },
            closestPointToPoint: function (point, target) {
                if (target === undefined) {
                    console.warn('THREE.Ray: .closestPointToPoint() target is now required');
                    target = new Vector3();
                }

                target.subVectors(point, this.origin);
                var directionDistance = target.dot(this.direction);

                if (directionDistance < 0) {
                    return target.copy(this.origin);
                }

                return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            },
            distanceToPoint: function (point) {
                return Math.sqrt(this.distanceSqToPoint(point));
            },
            distanceSqToPoint: function (point) {
                var directionDistance = _vector$5.subVectors(point, this.origin).dot(this.direction); // point behind the ray


                if (directionDistance < 0) {
                    return this.origin.distanceToSquared(point);
                }

                _vector$5.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

                return _vector$5.distanceToSquared(point);
            },
            distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
                // It returns the min distance between the ray and the segment
                // defined by v0 and v1
                // It can also set two optional targets :
                // - The closest point on the ray
                // - The closest point on the segment
                _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

                _segDir.copy(v1).sub(v0).normalize();

                _diff.copy(this.origin).sub(_segCenter);

                var segExtent = v0.distanceTo(v1) * 0.5;
                var a01 = -this.direction.dot(_segDir);

                var b0 = _diff.dot(this.direction);

                var b1 = -_diff.dot(_segDir);

                var c = _diff.lengthSq();

                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;

                if (det > 0) {
                    // The ray and segment are not parallel.
                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;

                    if (s0 >= 0) {
                        if (s1 >= -extDet) {
                            if (s1 <= extDet) {
                                // region 0
                                // Minimum at interior points of ray and segment.
                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                            } else {
                                // region 1
                                s1 = segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        } else {
                            // region 5
                            s1 = -segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        if (s1 <= -extDet) {
                            // region 4
                            s0 = Math.max(0, -(-a01 * segExtent + b0));
                            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        } else if (s1 <= extDet) {
                            // region 3
                            s0 = 0;
                            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = s1 * (s1 + 2 * b1) + c;
                        } else {
                            // region 2
                            s0 = Math.max(0, -(a01 * segExtent + b0));
                            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                } else {
                    // Ray and segment are parallel.
                    s1 = a01 > 0 ? -segExtent : segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }

                if (optionalPointOnRay) {
                    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }

                if (optionalPointOnSegment) {
                    optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
                }

                return sqrDist;
            },
            intersectSphere: function (sphere, target) {
                _vector$5.subVectors(sphere.center, this.origin);

                var tca = _vector$5.dot(this.direction);

                var d2 = _vector$5.dot(_vector$5) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

                var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

                var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

                if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
                // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                // in order to always return an intersect point that is in front of the ray.

                if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

                return this.at(t0, target);
            },
            intersectsSphere: function (sphere) {
                return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
            },
            distanceToPlane: function (plane) {
                var denominator = plane.normal.dot(this.direction);

                if (denominator === 0) {
                    // line is coplanar, return origin
                    if (plane.distanceToPoint(this.origin) === 0) {
                        return 0;
                    } // Null is preferable to undefined since undefined means.... it is undefined


                    return null;
                }

                var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

                return t >= 0 ? t : null;
            },
            intersectPlane: function (plane, target) {
                var t = this.distanceToPlane(plane);

                if (t === null) {
                    return null;
                }

                return this.at(t, target);
            },
            intersectsPlane: function (plane) {
                // check if the ray lies on the plane first
                var distToPoint = plane.distanceToPoint(this.origin);

                if (distToPoint === 0) {
                    return true;
                }

                var denominator = plane.normal.dot(this.direction);

                if (denominator * distToPoint < 0) {
                    return true;
                } // ray origin is behind the plane (and is pointing behind it)


                return false;
            },
            intersectBox: function (box, target) {
                var tmin, tmax, tymin, tymax, tzmin, tzmax;
                var invdirx = 1 / this.direction.x,
                    invdiry = 1 / this.direction.y,
                    invdirz = 1 / this.direction.z;
                var origin = this.origin;

                if (invdirx >= 0) {
                    tmin = (box.min.x - origin.x) * invdirx;
                    tmax = (box.max.x - origin.x) * invdirx;
                } else {
                    tmin = (box.max.x - origin.x) * invdirx;
                    tmax = (box.min.x - origin.x) * invdirx;
                }

                if (invdiry >= 0) {
                    tymin = (box.min.y - origin.y) * invdiry;
                    tymax = (box.max.y - origin.y) * invdiry;
                } else {
                    tymin = (box.max.y - origin.y) * invdiry;
                    tymax = (box.min.y - origin.y) * invdiry;
                }

                if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
                // (result of 0 * Infinity). x !== x returns true if x is NaN

                if (tymin > tmin || tmin !== tmin) tmin = tymin;
                if (tymax < tmax || tmax !== tmax) tmax = tymax;

                if (invdirz >= 0) {
                    tzmin = (box.min.z - origin.z) * invdirz;
                    tzmax = (box.max.z - origin.z) * invdirz;
                } else {
                    tzmin = (box.max.z - origin.z) * invdirz;
                    tzmax = (box.min.z - origin.z) * invdirz;
                }

                if (tmin > tzmax || tzmin > tmax) return null;
                if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
                if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

                if (tmax < 0) return null;
                return this.at(tmin >= 0 ? tmin : tmax, target);
            },
            intersectsBox: function (box) {
                return this.intersectBox(box, _vector$5) !== null;
            },
            intersectTriangle: function (a, b, c, backfaceCulling, target) {
                // Compute the offset origin, edges, and normal.
                // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
                _edge1.subVectors(b, a);

                _edge2.subVectors(c, a);

                _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


                var DdN = this.direction.dot(_normal);
                var sign;

                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else if (DdN < 0) {
                    sign = -1;
                    DdN = -DdN;
                } else {
                    return null;
                }

                _diff.subVectors(this.origin, a);

                var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

                if (DdQxE2 < 0) {
                    return null;
                }

                var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

                if (DdE1xQ < 0) {
                    return null;
                } // b1+b2 > 1, no intersection


                if (DdQxE2 + DdE1xQ > DdN) {
                    return null;
                } // Line intersects triangle, check if ray does.


                var QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


                if (QdN < 0) {
                    return null;
                } // Ray intersects triangle.


                return this.at(QdN / DdN, target);
            },
            applyMatrix4: function (matrix4) {
                this.origin.applyMatrix4(matrix4);
                this.direction.transformDirection(matrix4);
                return this;
            },
            equals: function (ray) {
                return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
            }
        });

        /**
         * @author bhouston / http://clara.io
         * @author mrdoob / http://mrdoob.com/
         */

        var _v0$1 = new Vector3();

        var _v1$3 = new Vector3();

        var _v2$1 = new Vector3();

        var _v3 = new Vector3();

        var _vab = new Vector3();

        var _vac = new Vector3();

        var _vbc = new Vector3();

        var _vap = new Vector3();

        var _vbp = new Vector3();

        var _vcp = new Vector3();

        function Triangle(a, b, c) {
            this.a = a !== undefined ? a : new Vector3();
            this.b = b !== undefined ? b : new Vector3();
            this.c = c !== undefined ? c : new Vector3();
        }

        Object.assign(Triangle, {
            getNormal: function (a, b, c, target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .getNormal() target is now required');
                    target = new Vector3();
                }

                target.subVectors(c, b);

                _v0$1.subVectors(a, b);

                target.cross(_v0$1);
                var targetLengthSq = target.lengthSq();

                if (targetLengthSq > 0) {
                    return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
                }

                return target.set(0, 0, 0);
            },
            // static/instance method to calculate barycentric coordinates
            // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
            getBarycoord: function (point, a, b, c, target) {
                _v0$1.subVectors(c, a);

                _v1$3.subVectors(b, a);

                _v2$1.subVectors(point, a);

                var dot00 = _v0$1.dot(_v0$1);

                var dot01 = _v0$1.dot(_v1$3);

                var dot02 = _v0$1.dot(_v2$1);

                var dot11 = _v1$3.dot(_v1$3);

                var dot12 = _v1$3.dot(_v2$1);

                var denom = dot00 * dot11 - dot01 * dot01;

                if (target === undefined) {
                    console.warn('THREE.Triangle: .getBarycoord() target is now required');
                    target = new Vector3();
                } // collinear or singular triangle


                if (denom === 0) {
                    // arbitrary location outside of triangle?
                    // not sure if this is the best idea, maybe should be returning undefined
                    return target.set(-2, -1, -1);
                }

                var invDenom = 1 / denom;
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

                return target.set(1 - u - v, v, u);
            },
            containsPoint: function (point, a, b, c) {
                Triangle.getBarycoord(point, a, b, c, _v3);
                return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
            },
            getUV: function (point, p1, p2, p3, uv1, uv2, uv3, target) {
                this.getBarycoord(point, p1, p2, p3, _v3);
                target.set(0, 0);
                target.addScaledVector(uv1, _v3.x);
                target.addScaledVector(uv2, _v3.y);
                target.addScaledVector(uv3, _v3.z);
                return target;
            },
            isFrontFacing: function (a, b, c, direction) {
                _v0$1.subVectors(c, b);

                _v1$3.subVectors(a, b); // strictly front facing


                return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
            }
        });
        Object.assign(Triangle.prototype, {
            set: function (a, b, c) {
                this.a.copy(a);
                this.b.copy(b);
                this.c.copy(c);
                return this;
            },
            setFromPointsAndIndices: function (points, i0, i1, i2) {
                this.a.copy(points[i0]);
                this.b.copy(points[i1]);
                this.c.copy(points[i2]);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (triangle) {
                this.a.copy(triangle.a);
                this.b.copy(triangle.b);
                this.c.copy(triangle.c);
                return this;
            },
            getArea: function () {
                _v0$1.subVectors(this.c, this.b);

                _v1$3.subVectors(this.a, this.b);

                return _v0$1.cross(_v1$3).length() * 0.5;
            },
            getMidpoint: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .getMidpoint() target is now required');
                    target = new Vector3();
                }

                return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
            },
            getNormal: function (target) {
                return Triangle.getNormal(this.a, this.b, this.c, target);
            },
            getPlane: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .getPlane() target is now required');
                    target = new Plane();
                }

                return target.setFromCoplanarPoints(this.a, this.b, this.c);
            },
            getBarycoord: function (point, target) {
                return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
            },
            getUV: function (point, uv1, uv2, uv3, target) {
                return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
            },
            containsPoint: function (point) {
                return Triangle.containsPoint(point, this.a, this.b, this.c);
            },
            isFrontFacing: function (direction) {
                return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
            },
            intersectsBox: function (box) {
                return box.intersectsTriangle(this);
            },
            closestPointToPoint: function (p, target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
                    target = new Vector3();
                }

                var a = this.a,
                    b = this.b,
                    c = this.c;
                var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
                // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
                // under the accompanying license; see chapter 5.1.5 for detailed explanation.
                // basically, we're distinguishing which of the voronoi regions of the triangle
                // the point lies in with the minimum amount of redundant computation.

                _vab.subVectors(b, a);

                _vac.subVectors(c, a);

                _vap.subVectors(p, a);

                var d1 = _vab.dot(_vap);

                var d2 = _vac.dot(_vap);

                if (d1 <= 0 && d2 <= 0) {
                    // vertex region of A; barycentric coords (1, 0, 0)
                    return target.copy(a);
                }

                _vbp.subVectors(p, b);

                var d3 = _vab.dot(_vbp);

                var d4 = _vac.dot(_vbp);

                if (d3 >= 0 && d4 <= d3) {
                    // vertex region of B; barycentric coords (0, 1, 0)
                    return target.copy(b);
                }

                var vc = d1 * d4 - d3 * d2;

                if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                    v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

                    return target.copy(a).addScaledVector(_vab, v);
                }

                _vcp.subVectors(p, c);

                var d5 = _vab.dot(_vcp);

                var d6 = _vac.dot(_vcp);

                if (d6 >= 0 && d5 <= d6) {
                    // vertex region of C; barycentric coords (0, 0, 1)
                    return target.copy(c);
                }

                var vb = d5 * d2 - d1 * d6;

                if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                    w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

                    return target.copy(a).addScaledVector(_vac, w);
                }

                var va = d3 * d6 - d5 * d4;

                if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
                    _vbc.subVectors(c, b);

                    w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

                    return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
                } // face region


                var denom = 1 / (va + vb + vc); // u = va * denom

                v = vb * denom;
                w = vc * denom;
                return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
            },
            equals: function (triangle) {
                return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
         *  color: <hex>,
         *  opacity: <float>,
         *  map: new THREE.Texture( <Image> ),
         *
         *  lightMap: new THREE.Texture( <Image> ),
         *  lightMapIntensity: <float>
         *
         *  aoMap: new THREE.Texture( <Image> ),
         *  aoMapIntensity: <float>
         *
         *  specularMap: new THREE.Texture( <Image> ),
         *
         *  alphaMap: new THREE.Texture( <Image> ),
         *
         *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
         *  combine: THREE.Multiply,
         *  reflectivity: <float>,
         *  refractionRatio: <float>,
         *
         *  depthTest: <bool>,
         *  depthWrite: <bool>,
         *
         *  wireframe: <boolean>,
         *  wireframeLinewidth: <float>,
         *
         *  skinning: <bool>,
         *  morphTargets: <bool>
         * }
         */

        function MeshBasicMaterial(parameters) {
            Material.call(this);
            this.type = 'MeshBasicMaterial';
            this.color = new Color(0xffffff); // emissive

            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.setValues(parameters);
        }

        MeshBasicMaterial.prototype = Object.create(Material.prototype);
        MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
        MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

        MeshBasicMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            return this;
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author jonobr1 / http://jonobr1.com/
         */

        var _inverseMatrix = new Matrix4();

        var _ray = new Ray();

        var _sphere$1 = new Sphere();

        var _vA = new Vector3();

        var _vB = new Vector3();

        var _vC = new Vector3();

        var _tempA = new Vector3();

        var _tempB = new Vector3();

        var _tempC = new Vector3();

        var _morphA = new Vector3();

        var _morphB = new Vector3();

        var _morphC = new Vector3();

        var _uvA = new Vector2();

        var _uvB = new Vector2();

        var _uvC = new Vector2();

        var _intersectionPoint = new Vector3();

        var _intersectionPointWorld = new Vector3();

        function Mesh(geometry, material) {
            Object3D.call(this);
            this.type = 'Mesh';
            this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
            this.material = material !== undefined ? material : new MeshBasicMaterial();
            this.updateMorphTargets();
        }

        Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Mesh,
            isMesh: true,
            copy: function (source) {
                Object3D.prototype.copy.call(this, source);

                if (source.morphTargetInfluences !== undefined) {
                    this.morphTargetInfluences = source.morphTargetInfluences.slice();
                }

                if (source.morphTargetDictionary !== undefined) {
                    this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
                }

                return this;
            },
            updateMorphTargets: function () {
                var geometry = this.geometry;
                var m, ml, name;

                if (geometry.isBufferGeometry) {
                    var morphAttributes = geometry.morphAttributes;
                    var keys = Object.keys(morphAttributes);

                    if (keys.length > 0) {
                        var morphAttribute = morphAttributes[keys[0]];

                        if (morphAttribute !== undefined) {
                            this.morphTargetInfluences = [];
                            this.morphTargetDictionary = {};

                            for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                                name = morphAttribute[m].name || String(m);
                                this.morphTargetInfluences.push(0);
                                this.morphTargetDictionary[name] = m;
                            }
                        }
                    }
                } else {
                    var morphTargets = geometry.morphTargets;

                    if (morphTargets !== undefined && morphTargets.length > 0) {
                        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                    }
                }
            },
            raycast: function (raycaster, intersects) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if (material === undefined) return; // Checking boundingSphere distance to ray

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                _sphere$1.copy(geometry.boundingSphere);

                _sphere$1.applyMatrix4(matrixWorld);

                if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

                _inverseMatrix.getInverse(matrixWorld);

                _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


                if (geometry.boundingBox !== null) {
                    if (_ray.intersectsBox(geometry.boundingBox) === false) return;
                }

                var intersection;

                if (geometry.isBufferGeometry) {
                    var a, b, c;
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var morphPosition = geometry.morphAttributes.position;
                    var morphTargetsRelative = geometry.morphTargetsRelative;
                    var uv = geometry.attributes.uv;
                    var uv2 = geometry.attributes.uv2;
                    var groups = geometry.groups;
                    var drawRange = geometry.drawRange;
                    var i, j, il, jl;
                    var group, groupMaterial;
                    var start, end;

                    if (index !== null) {
                        // indexed buffer geometry
                        if (Array.isArray(material)) {
                            for (i = 0, il = groups.length; i < il; i++) {
                                group = groups[i];
                                groupMaterial = material[group.materialIndex];
                                start = Math.max(group.start, drawRange.start);
                                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

                                for (j = start, jl = end; j < jl; j += 3) {
                                    a = index.getX(j);
                                    b = index.getX(j + 1);
                                    c = index.getX(j + 2);
                                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                                        intersection.face.materialIndex = group.materialIndex;
                                        intersects.push(intersection);
                                    }
                                }
                            }
                        } else {
                            start = Math.max(0, drawRange.start);
                            end = Math.min(index.count, drawRange.start + drawRange.count);

                            for (i = start, il = end; i < il; i += 3) {
                                a = index.getX(i);
                                b = index.getX(i + 1);
                                c = index.getX(i + 2);
                                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                                if (intersection) {
                                    intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

                                    intersects.push(intersection);
                                }
                            }
                        }
                    } else if (position !== undefined) {
                        // non-indexed buffer geometry
                        if (Array.isArray(material)) {
                            for (i = 0, il = groups.length; i < il; i++) {
                                group = groups[i];
                                groupMaterial = material[group.materialIndex];
                                start = Math.max(group.start, drawRange.start);
                                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

                                for (j = start, jl = end; j < jl; j += 3) {
                                    a = j;
                                    b = j + 1;
                                    c = j + 2;
                                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                                        intersection.face.materialIndex = group.materialIndex;
                                        intersects.push(intersection);
                                    }
                                }
                            }
                        } else {
                            start = Math.max(0, drawRange.start);
                            end = Math.min(position.count, drawRange.start + drawRange.count);

                            for (i = start, il = end; i < il; i += 3) {
                                a = i;
                                b = i + 1;
                                c = i + 2;
                                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                                if (intersection) {
                                    intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

                                    intersects.push(intersection);
                                }
                            }
                        }
                    }
                } else if (geometry.isGeometry) {
                    var fvA, fvB, fvC;
                    var isMultiMaterial = Array.isArray(material);
                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var uvs;
                    var faceVertexUvs = geometry.faceVertexUvs[0];
                    if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

                    for (var f = 0, fl = faces.length; f < fl; f++) {
                        var face = faces[f];
                        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                        if (faceMaterial === undefined) continue;
                        fvA = vertices[face.a];
                        fvB = vertices[face.b];
                        fvC = vertices[face.c];
                        intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

                        if (intersection) {
                            if (uvs && uvs[f]) {
                                var uvs_f = uvs[f];

                                _uvA.copy(uvs_f[0]);

                                _uvB.copy(uvs_f[1]);

                                _uvC.copy(uvs_f[2]);

                                intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
                            }

                            intersection.face = face;
                            intersection.faceIndex = f;
                            intersects.push(intersection);
                        }
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this);
            }
        });

        function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
            var intersect;

            if (material.side === BackSide) {
                intersect = ray.intersectTriangle(pC, pB, pA, true, point);
            } else {
                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
            }

            if (intersect === null) return null;

            _intersectionPointWorld.copy(point);

            _intersectionPointWorld.applyMatrix4(object.matrixWorld);

            var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
            if (distance < raycaster.near || distance > raycaster.far) return null;
            return {
                distance: distance,
                point: _intersectionPointWorld.clone(),
                object: object
            };
        }

        function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
            _vA.fromBufferAttribute(position, a);

            _vB.fromBufferAttribute(position, b);

            _vC.fromBufferAttribute(position, c);

            var morphInfluences = object.morphTargetInfluences;

            if (material.morphTargets && morphPosition && morphInfluences) {
                _morphA.set(0, 0, 0);

                _morphB.set(0, 0, 0);

                _morphC.set(0, 0, 0);

                for (var i = 0, il = morphPosition.length; i < il; i++) {
                    var influence = morphInfluences[i];
                    var morphAttribute = morphPosition[i];
                    if (influence === 0) continue;

                    _tempA.fromBufferAttribute(morphAttribute, a);

                    _tempB.fromBufferAttribute(morphAttribute, b);

                    _tempC.fromBufferAttribute(morphAttribute, c);

                    if (morphTargetsRelative) {
                        _morphA.addScaledVector(_tempA, influence);

                        _morphB.addScaledVector(_tempB, influence);

                        _morphC.addScaledVector(_tempC, influence);
                    } else {
                        _morphA.addScaledVector(_tempA.sub(_vA), influence);

                        _morphB.addScaledVector(_tempB.sub(_vB), influence);

                        _morphC.addScaledVector(_tempC.sub(_vC), influence);
                    }
                }

                _vA.add(_morphA);

                _vB.add(_morphB);

                _vC.add(_morphC);
            }

            var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

            if (intersection) {
                if (uv) {
                    _uvA.fromBufferAttribute(uv, a);

                    _uvB.fromBufferAttribute(uv, b);

                    _uvC.fromBufferAttribute(uv, c);

                    intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
                }

                if (uv2) {
                    _uvA.fromBufferAttribute(uv2, a);

                    _uvB.fromBufferAttribute(uv2, b);

                    _uvC.fromBufferAttribute(uv2, c);

                    intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
                }

                var face = new Face3(a, b, c);
                Triangle.getNormal(_vA, _vB, _vC, face.normal);
                intersection.face = face;
            }

            return intersection;
        }

        var alphamap_fragment = /* glsl */
            `
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`	;

        var alphamap_pars_fragment = /* glsl */
            `
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`	;

        var alphatest_fragment = /* glsl */
            `
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`	;

        var aomap_fragment = /* glsl */
            `
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`	;

        var aomap_pars_fragment = /* glsl */
            `
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`	;

        var begin_vertex = /* glsl */
            `
vec3 transformed = vec3( position );
`	;

        var beginnormal_vertex = /* glsl */
            `
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`	;

        var bsdfs = /* glsl */
            `

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)(v) / 4(n)(n)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`	;

        var bumpmap_pars_fragment = /* glsl */
            `
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 );

		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`	;

        var clipping_planes_fragment = /* glsl */
            `
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;

	}

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;

		}

		if ( clipped ) discard;

	#endif

#endif
`	;

        var clipping_planes_pars_fragment = /* glsl */
            `
#if NUM_CLIPPING_PLANES > 0

	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )
		varying vec3 vViewPosition;
	#endif

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`	;

        var clipping_planes_pars_vertex = /* glsl */
            `
#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )
	varying vec3 vViewPosition;
#endif
`	;

        var clipping_planes_vertex = /* glsl */
            `
#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )
	vViewPosition = - mvPosition.xyz;
#endif
`	;

        var color_fragment = /* glsl */
            `
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif
`	;

        var color_pars_fragment = /* glsl */
            `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`	;

        var color_pars_vertex = /* glsl */
            `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`	;

        var color_vertex = /* glsl */
            `
#ifdef USE_COLOR

	vColor.xyz = color.xyz;

#endif
`	;

        var common = /* glsl */
            `
#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

  return m[ 2 ][ 3 ] == - 1.0;

}
`	;

        var cube_uv_reflection_fragment = /* glsl */
            `
#ifdef ENVMAP_TYPE_CUBE_UV

#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0

// These shader functions convert between the UV coordinates of a single face of
// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
// sampling a textureCube (not generally normalized).

float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}

vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x);
    } else if (face == 1.0) {
      uv = vec2(direction.x, -direction.z) / abs(direction.y);
    } else if (face == 2.0) {
      uv = direction.xy / abs(direction.z);
    } else if (face == 3.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x);
    } else if (face == 4.0) {
      uv = direction.xz / abs(direction.y);
    } else {
      uv = vec2(-direction.x, direction.y) / abs(direction.z);
    }
    return 0.5 * (uv + 1.0);
}

vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);

  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);

  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;

  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}

// These defines must match with PMREMGenerator

#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0

float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
  }
  return mip;
}

vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);

  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif
`	;

        var defaultnormal_vertex = /* glsl */
            `
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`	;

        var displacementmap_pars_vertex = /* glsl */
            `
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`	;

        var displacementmap_vertex = /* glsl */
            `
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`	;

        var emissivemap_fragment = /* glsl */
            `
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`	;

        var emissivemap_pars_fragment = /* glsl */
            `
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`	;

        var encodings_fragment = /* glsl */
            `
gl_FragColor = linearToOutputTexel( gl_FragColor );
`	;

        var encodings_pars_fragment = /* glsl */
            `
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`	;

        var envmap_fragment = /* glsl */
            `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		}  else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#elif defined( ENVMAP_TYPE_EQUIREC )

		vec2 sampleUV;

		reflectVec = normalize( reflectVec );

		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;

		vec4 envColor = texture2D( envMap, sampleUV );

	#elif defined( ENVMAP_TYPE_SPHERE )

		reflectVec = normalize( reflectVec );

		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );

		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`	;

        var envmap_common_pars_fragment = /* glsl */
            `
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif
`	;

        var envmap_pars_fragment = /* glsl */
            `
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`	;

        var envmap_pars_vertex = /* glsl */
            `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`	;

        var envmap_vertex = /* glsl */
            `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`	;

        var fog_vertex = /* glsl */
            `
#ifdef USE_FOG

	fogDepth = -mvPosition.z;

#endif
`	;

        var fog_pars_vertex = /* glsl */
            `
#ifdef USE_FOG

	varying float fogDepth;

#endif
`	;

        var fog_fragment = /* glsl */
            `
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`	;

        var fog_pars_fragment = /* glsl */
            `
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`	;

        var gradientmap_pars_fragment = /* glsl */
            `

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}

`	;

        var lightmap_fragment = /* glsl */
            `
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`	;

        var lightmap_pars_fragment = /* glsl */
            `
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`	;

        var lights_lambert_vertex = /* glsl */
            `
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );

#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}

#endif
`	;

        var lights_pars_begin = /* glsl */
            `
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif


	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0

		struct PointLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0

		struct SpotLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`	;

        var envmap_physical_pars_fragment = /* glsl */
            `
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

		  vec3 reflectVec = reflect( -viewDir, normal );

		  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#elif defined( ENVMAP_TYPE_EQUIREC )

			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );

			#else

				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_SPHERE )

			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );

			#else

				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`	;

        var lights_toon_fragment = /* glsl */
            `
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`	;

        var lights_toon_pars_fragment = /* glsl */
            `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`	;

        var lights_phong_fragment = /* glsl */
            `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`	;

        var lights_phong_pars_fragment = /* glsl */
            `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`	;

        var lights_physical_fragment = /* glsl */
            `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = saturate( clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif
#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`	;

        var lights_physical_pars_fragment = /* glsl */
            `
struct PhysicalMaterial {

	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`	;

        var lights_fragment_begin = /* glsl */
            `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`	;

        var lights_fragment_maps = /* glsl */
            `
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`	;

        var lights_fragment_end = /* glsl */
            `
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`	;

        var logdepthbuf_fragment = /* glsl */
            `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`	;

        var logdepthbuf_pars_fragment = /* glsl */
            `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`	;

        var logdepthbuf_pars_vertex = /* glsl */
            `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`	;

        var logdepthbuf_vertex = /* glsl */
            `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`	;

        var map_fragment = /* glsl */
            `
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`	;

        var map_pars_fragment = /* glsl */
            `
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`	;

        var map_particle_fragment = /* glsl */
            `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`	;

        var map_particle_pars_fragment = /* glsl */
            `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`	;

        var metalnessmap_fragment = /* glsl */
            `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`	;

        var metalnessmap_pars_fragment = /* glsl */
            `
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`	;

        var morphnormal_vertex = /* glsl */
            `
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`	;

        var morphtarget_pars_vertex = /* glsl */
            `
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

	uniform float morphTargetInfluences[ 8 ];

	#else

	uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`	;

        var morphtarget_vertex = /* glsl */
            `
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

	transformed += morphTarget4 * morphTargetInfluences[ 4 ];
	transformed += morphTarget5 * morphTargetInfluences[ 5 ];
	transformed += morphTarget6 * morphTargetInfluences[ 6 ];
	transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`	;

        var normal_fragment_begin = /* glsl */
            `
#ifdef FLAT_SHADED

	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`	;

        var normal_fragment_maps = /* glsl */
            `

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );

#endif
`	;

        var normalmap_pars_fragment = /* glsl */
            `
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Per-Pixel Tangent Space Normal Mapping
	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );

		mat3 tsn = mat3( S, T, N );

		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		return normalize( tsn * mapN );

	}

#endif
`	;

        var clearcoat_normal_fragment_begin = /* glsl */
            `
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`	;

        var clearcoat_normal_fragment_maps = /* glsl */
            `
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );

	#endif

#endif
`	;

        var clearcoat_normalmap_pars_fragment = /* glsl */
            `
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`	;

        var packing = /* glsl */
            `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`	;

        var premultiplied_alpha_fragment = /* glsl */
            `
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`	;

        var project_vertex = /* glsl */
            `
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`	;

        var dithering_fragment = /* glsl */
            `
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`	;

        var dithering_pars_fragment = /* glsl */
            `
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`	;

        var roughnessmap_fragment = /* glsl */
            `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`	;

        var roughnessmap_pars_fragment = /* glsl */
            `
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`	;

        var shadowmap_pars_fragment = /* glsl */
            `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`	;

        var shadowmap_pars_vertex = /* glsl */
            `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`	;

        var shadowmap_vertex = /* glsl */
            `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;

	}

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;

	}

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;

	}

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`	;

        var shadowmask_pars_fragment = /* glsl */
            `
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`	;

        var skinbase_vertex = /* glsl */
            `
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`	;

        var skinning_pars_vertex = /* glsl */
            `
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`	;

        var skinning_vertex = /* glsl */
            `
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`	;

        var skinnormal_vertex = /* glsl */
            `
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`	;

        var specularmap_fragment = /* glsl */
            `
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`	;

        var specularmap_pars_fragment = /* glsl */
            `
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`	;

        var tonemapping_fragment = /* glsl */
            `
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`	;

        var tonemapping_pars_fragment = /* glsl */
            `
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicgames.com/archives/75
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {

	// John Hable's filmic operator from Uncharted 2 video game
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );

}

// source: http://filmicgames.com/archives/75
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACESFilmicToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );

}
`	;

        var uv_pars_fragment = /* glsl */
            `
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`	;

        var uv_pars_vertex = /* glsl */
            `
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`	;

        var uv_vertex = /* glsl */
            `
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`	;

        var uv2_pars_fragment = /* glsl */
            `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`	;

        var uv2_pars_vertex = /* glsl */
            `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`	;

        var uv2_vertex = /* glsl */
            `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`	;

        var worldpos_vertex = /* glsl */
            `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`	;

        var background_frag = /* glsl */
            `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`	;

        var background_vert = /* glsl */
            `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`	;

        var cube_frag = /* glsl */
            `

#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`	;

        var cube_vert = /* glsl */
            `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`	;

        var depth_frag = /* glsl */
            `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`	;

        var depth_vert = /* glsl */
            `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`	;

        var distanceRGBA_frag = /* glsl */
            `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`	;

        var distanceRGBA_vert = /* glsl */
            `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`	;

        var equirect_frag = /* glsl */
            `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV;

	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`	;

        var equirect_vert = /* glsl */
            `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`	;

        var linedashed_frag = /* glsl */
            `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`	;

        var linedashed_vert = /* glsl */
            `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>

	vLineDistance = scale * lineDistance;

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`	;

        var meshbasic_frag = /* glsl */
            `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`	;

        var meshbasic_vert = /* glsl */
            `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`	;

        var meshlambert_frag = /* glsl */
            `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`	;

        var meshlambert_vert = /* glsl */
            `
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`	;

        var meshmatcap_frag = /* glsl */
            `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`	;

        var meshmatcap_vert = /* glsl */
            `
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`	;

        var meshtoon_frag = /* glsl */
            `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`	;

        var meshtoon_vert = /* glsl */
            `
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`	;

        var meshphong_frag = /* glsl */
            `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`	;

        var meshphong_vert = /* glsl */
            `
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`	;

        var meshphysical_frag = /* glsl */
            `
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSPARENCY
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSPARENCY
	uniform float transparency;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transparency model
	#ifdef TRANSPARENCY
		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`	;

        var meshphysical_vert = /* glsl */
            `
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`	;

        var normal_frag = /* glsl */
            `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`	;

        var normal_vert = /* glsl */
            `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`	;

        var points_frag = /* glsl */
            `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`	;

        var points_vert = /* glsl */
            `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`	;

        var shadow_frag = /* glsl */
            `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`	;

        var shadow_vert = /* glsl */
            `
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`	;

        var sprite_frag = /* glsl */
            `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`	;

        var sprite_vert = /* glsl */
            `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`	;

        var ShaderChunk = {
            alphamap_fragment: alphamap_fragment,
            alphamap_pars_fragment: alphamap_pars_fragment,
            alphatest_fragment: alphatest_fragment,
            aomap_fragment: aomap_fragment,
            aomap_pars_fragment: aomap_pars_fragment,
            begin_vertex: begin_vertex,
            beginnormal_vertex: beginnormal_vertex,
            bsdfs: bsdfs,
            bumpmap_pars_fragment: bumpmap_pars_fragment,
            clipping_planes_fragment: clipping_planes_fragment,
            clipping_planes_pars_fragment: clipping_planes_pars_fragment,
            clipping_planes_pars_vertex: clipping_planes_pars_vertex,
            clipping_planes_vertex: clipping_planes_vertex,
            color_fragment: color_fragment,
            color_pars_fragment: color_pars_fragment,
            color_pars_vertex: color_pars_vertex,
            color_vertex: color_vertex,
            common: common,
            cube_uv_reflection_fragment: cube_uv_reflection_fragment,
            defaultnormal_vertex: defaultnormal_vertex,
            displacementmap_pars_vertex: displacementmap_pars_vertex,
            displacementmap_vertex: displacementmap_vertex,
            emissivemap_fragment: emissivemap_fragment,
            emissivemap_pars_fragment: emissivemap_pars_fragment,
            encodings_fragment: encodings_fragment,
            encodings_pars_fragment: encodings_pars_fragment,
            envmap_fragment: envmap_fragment,
            envmap_common_pars_fragment: envmap_common_pars_fragment,
            envmap_pars_fragment: envmap_pars_fragment,
            envmap_pars_vertex: envmap_pars_vertex,
            envmap_physical_pars_fragment: envmap_physical_pars_fragment,
            envmap_vertex: envmap_vertex,
            fog_vertex: fog_vertex,
            fog_pars_vertex: fog_pars_vertex,
            fog_fragment: fog_fragment,
            fog_pars_fragment: fog_pars_fragment,
            gradientmap_pars_fragment: gradientmap_pars_fragment,
            lightmap_fragment: lightmap_fragment,
            lightmap_pars_fragment: lightmap_pars_fragment,
            lights_lambert_vertex: lights_lambert_vertex,
            lights_pars_begin: lights_pars_begin,
            lights_toon_fragment: lights_toon_fragment,
            lights_toon_pars_fragment: lights_toon_pars_fragment,
            lights_phong_fragment: lights_phong_fragment,
            lights_phong_pars_fragment: lights_phong_pars_fragment,
            lights_physical_fragment: lights_physical_fragment,
            lights_physical_pars_fragment: lights_physical_pars_fragment,
            lights_fragment_begin: lights_fragment_begin,
            lights_fragment_maps: lights_fragment_maps,
            lights_fragment_end: lights_fragment_end,
            logdepthbuf_fragment: logdepthbuf_fragment,
            logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
            logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
            logdepthbuf_vertex: logdepthbuf_vertex,
            map_fragment: map_fragment,
            map_pars_fragment: map_pars_fragment,
            map_particle_fragment: map_particle_fragment,
            map_particle_pars_fragment: map_particle_pars_fragment,
            metalnessmap_fragment: metalnessmap_fragment,
            metalnessmap_pars_fragment: metalnessmap_pars_fragment,
            morphnormal_vertex: morphnormal_vertex,
            morphtarget_pars_vertex: morphtarget_pars_vertex,
            morphtarget_vertex: morphtarget_vertex,
            normal_fragment_begin: normal_fragment_begin,
            normal_fragment_maps: normal_fragment_maps,
            normalmap_pars_fragment: normalmap_pars_fragment,
            clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
            clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
            clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
            packing: packing,
            premultiplied_alpha_fragment: premultiplied_alpha_fragment,
            project_vertex: project_vertex,
            dithering_fragment: dithering_fragment,
            dithering_pars_fragment: dithering_pars_fragment,
            roughnessmap_fragment: roughnessmap_fragment,
            roughnessmap_pars_fragment: roughnessmap_pars_fragment,
            shadowmap_pars_fragment: shadowmap_pars_fragment,
            shadowmap_pars_vertex: shadowmap_pars_vertex,
            shadowmap_vertex: shadowmap_vertex,
            shadowmask_pars_fragment: shadowmask_pars_fragment,
            skinbase_vertex: skinbase_vertex,
            skinning_pars_vertex: skinning_pars_vertex,
            skinning_vertex: skinning_vertex,
            skinnormal_vertex: skinnormal_vertex,
            specularmap_fragment: specularmap_fragment,
            specularmap_pars_fragment: specularmap_pars_fragment,
            tonemapping_fragment: tonemapping_fragment,
            tonemapping_pars_fragment: tonemapping_pars_fragment,
            uv_pars_fragment: uv_pars_fragment,
            uv_pars_vertex: uv_pars_vertex,
            uv_vertex: uv_vertex,
            uv2_pars_fragment: uv2_pars_fragment,
            uv2_pars_vertex: uv2_pars_vertex,
            uv2_vertex: uv2_vertex,
            worldpos_vertex: worldpos_vertex,
            background_frag: background_frag,
            background_vert: background_vert,
            cube_frag: cube_frag,
            cube_vert: cube_vert,
            depth_frag: depth_frag,
            depth_vert: depth_vert,
            distanceRGBA_frag: distanceRGBA_frag,
            distanceRGBA_vert: distanceRGBA_vert,
            equirect_frag: equirect_frag,
            equirect_vert: equirect_vert,
            linedashed_frag: linedashed_frag,
            linedashed_vert: linedashed_vert,
            meshbasic_frag: meshbasic_frag,
            meshbasic_vert: meshbasic_vert,
            meshlambert_frag: meshlambert_frag,
            meshlambert_vert: meshlambert_vert,
            meshmatcap_frag: meshmatcap_frag,
            meshmatcap_vert: meshmatcap_vert,
            meshtoon_frag: meshtoon_frag,
            meshtoon_vert: meshtoon_vert,
            meshphong_frag: meshphong_frag,
            meshphong_vert: meshphong_vert,
            meshphysical_frag: meshphysical_frag,
            meshphysical_vert: meshphysical_vert,
            normal_frag: normal_frag,
            normal_vert: normal_vert,
            points_frag: points_frag,
            points_vert: points_vert,
            shadow_frag: shadow_frag,
            shadow_vert: shadow_vert,
            sprite_frag: sprite_frag,
            sprite_vert: sprite_vert
        };

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         */

        var ShaderLib = {
            basic: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
                vertexShader: ShaderChunk.meshbasic_vert,
                fragmentShader: ShaderChunk.meshbasic_frag
            },
            lambert: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                    emissive: {
                        value: new Color(0x000000)
                    }
                }]),
                vertexShader: ShaderChunk.meshlambert_vert,
                fragmentShader: ShaderChunk.meshlambert_frag
            },
            phong: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
                    emissive: {
                        value: new Color(0x000000)
                    },
                    specular: {
                        value: new Color(0x111111)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ShaderChunk.meshphong_vert,
                fragmentShader: ShaderChunk.meshphong_frag
            },
            standard: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                    emissive: {
                        value: new Color(0x000000)
                    },
                    roughness: {
                        value: 0.5
                    },
                    metalness: {
                        value: 0.5
                    },
                    envMapIntensity: {
                        value: 1
                    } // temporary

                }]),
                vertexShader: ShaderChunk.meshphysical_vert,
                fragmentShader: ShaderChunk.meshphysical_frag
            },
            toon: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                    emissive: {
                        value: new Color(0x000000)
                    },
                    specular: {
                        value: new Color(0x111111)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ShaderChunk.meshtoon_vert,
                fragmentShader: ShaderChunk.meshtoon_frag
            },
            matcap: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ShaderChunk.meshmatcap_vert,
                fragmentShader: ShaderChunk.meshmatcap_frag
            },
            points: {
                uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
                vertexShader: ShaderChunk.points_vert,
                fragmentShader: ShaderChunk.points_frag
            },
            dashed: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ShaderChunk.linedashed_vert,
                fragmentShader: ShaderChunk.linedashed_frag
            },
            depth: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
                vertexShader: ShaderChunk.depth_vert,
                fragmentShader: ShaderChunk.depth_frag
            },
            normal: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                    opacity: {
                        value: 1.0
                    }
                }]),
                vertexShader: ShaderChunk.normal_vert,
                fragmentShader: ShaderChunk.normal_frag
            },
            sprite: {
                uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
                vertexShader: ShaderChunk.sprite_vert,
                fragmentShader: ShaderChunk.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Matrix3()
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: ShaderChunk.background_vert,
                fragmentShader: ShaderChunk.background_frag
            },

            /* -------------------------------------------------------------------------
	  //	Cube map shader
	   ------------------------------------------------------------------------- */
            cube: {
                uniforms: mergeUniforms([UniformsLib.envmap, {
                    opacity: {
                        value: 1.0
                    }
                }]),
                vertexShader: ShaderChunk.cube_vert,
                fragmentShader: ShaderChunk.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ShaderChunk.equirect_vert,
                fragmentShader: ShaderChunk.equirect_frag
            },
            distanceRGBA: {
                uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
                    referencePosition: {
                        value: new Vector3()
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1000
                    }
                }]),
                vertexShader: ShaderChunk.distanceRGBA_vert,
                fragmentShader: ShaderChunk.distanceRGBA_frag
            },
            shadow: {
                uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
                    color: {
                        value: new Color(0x00000)
                    },
                    opacity: {
                        value: 1.0
                    }
                }]),
                vertexShader: ShaderChunk.shadow_vert,
                fragmentShader: ShaderChunk.shadow_frag
            }
        };
        ShaderLib.physical = {
            uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
                transparency: {
                    value: 0
                },
                clearcoat: {
                    value: 0
                },
                clearcoatRoughness: {
                    value: 0
                },
                sheen: {
                    value: new Color(0x000000)
                },
                clearcoatNormalScale: {
                    value: new Vector2(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                }
            }]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
            var clearColor = new Color(0x000000);
            var clearAlpha = 0;
            var planeMesh;
            var boxMesh;
            var currentBackground = null;
            var currentBackgroundVersion = 0;
            var currentTonemapping = null;

            function render(renderList, scene, camera, forceClear) {
                var background = scene.background; // Ignore background in AR
                // TODO: Reconsider this.

                var xr = renderer.xr;
                var session = xr.getSession && xr.getSession();

                if (session && session.environmentBlendMode === 'additive') {
                    background = null;
                }

                if (background === null) {
                    setClear(clearColor, clearAlpha);
                } else if (background && background.isColor) {
                    setClear(background, 1);
                    forceClear = true;
                }

                if (renderer.autoClear || forceClear) {
                    renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
                }

                if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
                    if (boxMesh === undefined) {
                        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                            type: 'BackgroundCubeMaterial',
                            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                            vertexShader: ShaderLib.cube.vertexShader,
                            fragmentShader: ShaderLib.cube.fragmentShader,
                            side: BackSide,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        }));
                        boxMesh.geometry.deleteAttribute('normal');
                        boxMesh.geometry.deleteAttribute('uv');

                        boxMesh.onBeforeRender = function (renderer, scene, camera) {
                            this.matrixWorld.copyPosition(camera.matrixWorld);
                        }; // enable code injection for non-built-in material


                        Object.defineProperty(boxMesh.material, 'envMap', {
                            get: function () {
                                return this.uniforms.envMap.value;
                            }
                        });
                        objects.update(boxMesh);
                    }

                    var texture = background.isWebGLCubeRenderTarget ? background.texture : background;
                    boxMesh.material.uniforms.envMap.value = texture;
                    boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;

                    if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
                        boxMesh.material.needsUpdate = true;
                        currentBackground = background;
                        currentBackgroundVersion = texture.version;
                        currentTonemapping = renderer.toneMapping;
                    } // push to the pre-sorted opaque render list


                    renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
                } else if (background && background.isTexture) {
                    if (planeMesh === undefined) {
                        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                            type: 'BackgroundMaterial',
                            uniforms: cloneUniforms(ShaderLib.background.uniforms),
                            vertexShader: ShaderLib.background.vertexShader,
                            fragmentShader: ShaderLib.background.fragmentShader,
                            side: FrontSide,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        }));
                        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

                        Object.defineProperty(planeMesh.material, 'map', {
                            get: function () {
                                return this.uniforms.t2D.value;
                            }
                        });
                        objects.update(planeMesh);
                    }

                    planeMesh.material.uniforms.t2D.value = background;

                    if (background.matrixAutoUpdate === true) {
                        background.updateMatrix();
                    }

                    planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

                    if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                        planeMesh.material.needsUpdate = true;
                        currentBackground = background;
                        currentBackgroundVersion = background.version;
                        currentTonemapping = renderer.toneMapping;
                    } // push to the pre-sorted opaque render list


                    renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
                }
            }

            function setClear(color, alpha) {
                state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
            }

            return {
                getClearColor: function () {
                    return clearColor;
                },
                setClearColor: function (color, alpha) {
                    clearColor.set(color);
                    clearAlpha = alpha !== undefined ? alpha : 1;
                    setClear(clearColor, clearAlpha);
                },
                getClearAlpha: function () {
                    return clearAlpha;
                },
                setClearAlpha: function (alpha) {
                    clearAlpha = alpha;
                    setClear(clearColor, clearAlpha);
                },
                render: render
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLBufferRenderer(gl, extensions, info, capabilities) {
            var isWebGL2 = capabilities.isWebGL2;
            var mode;

            function setMode(value) {
                mode = value;
            }

            function render(start, count) {
                gl.drawArrays(mode, start, count);
                info.update(count, mode);
            }

            function renderInstances(geometry, start, count, primcount) {
                if (primcount === 0) return;
                var extension, methodName;

                if (isWebGL2) {
                    extension = gl;
                    methodName = 'drawArraysInstanced';
                } else {
                    extension = extensions.get('ANGLE_instanced_arrays');
                    methodName = 'drawArraysInstancedANGLE';

                    if (extension === null) {
                        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                        return;
                    }
                }

                extension[methodName](mode, start, count, primcount);
                info.update(count, mode, primcount);
            } //


            this.setMode = setMode;
            this.render = render;
            this.renderInstances = renderInstances;
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLCapabilities(gl, extensions, parameters) {
            var maxAnisotropy;

            function getMaxAnisotropy() {
                if (maxAnisotropy !== undefined) return maxAnisotropy;
                var extension = extensions.get('EXT_texture_filter_anisotropic');

                if (extension !== null) {
                    maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                } else {
                    maxAnisotropy = 0;
                }

                return maxAnisotropy;
            }

            function getMaxPrecision(precision) {
                if (precision === 'highp') {
                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                        return 'highp';
                    }

                    precision = 'mediump';
                }

                if (precision === 'mediump') {
                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                        return 'mediump';
                    }
                }

                return 'lowp';
            }
            /* eslint-disable no-undef */


            var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
            /* eslint-enable no-undef */

            var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
            var maxPrecision = getMaxPrecision(precision);

            if (maxPrecision !== precision) {
                console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
                precision = maxPrecision;
            }

            var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            var vertexTextures = maxVertexTextures > 0;
            var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
            var floatVertexTextures = vertexTextures && floatFragmentTextures;
            var maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
            return {
                isWebGL2: isWebGL2,
                getMaxAnisotropy: getMaxAnisotropy,
                getMaxPrecision: getMaxPrecision,
                precision: precision,
                logarithmicDepthBuffer: logarithmicDepthBuffer,
                maxTextures: maxTextures,
                maxVertexTextures: maxVertexTextures,
                maxTextureSize: maxTextureSize,
                maxCubemapSize: maxCubemapSize,
                maxAttributes: maxAttributes,
                maxVertexUniforms: maxVertexUniforms,
                maxVaryings: maxVaryings,
                maxFragmentUniforms: maxFragmentUniforms,
                vertexTextures: vertexTextures,
                floatFragmentTextures: floatFragmentTextures,
                floatVertexTextures: floatVertexTextures,
                maxSamples: maxSamples
            };
        }

        /**
         * @author tschw
         */

        function WebGLClipping() {
            var scope = this,
                globalState = null,
                numGlobalPlanes = 0,
                localClippingEnabled = false,
                renderingShadows = false,
                plane = new Plane(),
                viewNormalMatrix = new Matrix3(),
                uniform = {
                    value: null,
                    needsUpdate: false
                };
            this.uniform = uniform;
            this.numPlanes = 0;
            this.numIntersection = 0;

            this.init = function (planes, enableLocalClipping, camera) {
                var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
                    // run another frame in order to reset the state:
                    numGlobalPlanes !== 0 || localClippingEnabled;
                localClippingEnabled = enableLocalClipping;
                globalState = projectPlanes(planes, camera, 0);
                numGlobalPlanes = planes.length;
                return enabled;
            };

            this.beginShadows = function () {
                renderingShadows = true;
                projectPlanes(null);
            };

            this.endShadows = function () {
                renderingShadows = false;
                resetGlobalState();
            };

            this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
                if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                    // there's no local clipping
                    if (renderingShadows) {
                        // there's no global clipping
                        projectPlanes(null);
                    } else {
                        resetGlobalState();
                    }
                } else {
                    var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                        lGlobal = nGlobal * 4,
                        dstArray = cache.clippingState || null;
                    uniform.value = dstArray; // ensure unique state

                    dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

                    for (var i = 0; i !== lGlobal; ++i) {
                        dstArray[i] = globalState[i];
                    }

                    cache.clippingState = dstArray;
                    this.numIntersection = clipIntersection ? this.numPlanes : 0;
                    this.numPlanes += nGlobal;
                }
            };

            function resetGlobalState() {
                if (uniform.value !== globalState) {
                    uniform.value = globalState;
                    uniform.needsUpdate = numGlobalPlanes > 0;
                }

                scope.numPlanes = numGlobalPlanes;
                scope.numIntersection = 0;
            }

            function projectPlanes(planes, camera, dstOffset, skipTransform) {
                var nPlanes = planes !== null ? planes.length : 0,
                    dstArray = null;

                if (nPlanes !== 0) {
                    dstArray = uniform.value;

                    if (skipTransform !== true || dstArray === null) {
                        var flatSize = dstOffset + nPlanes * 4,
                            viewMatrix = camera.matrixWorldInverse;
                        viewNormalMatrix.getNormalMatrix(viewMatrix);

                        if (dstArray === null || dstArray.length < flatSize) {
                            dstArray = new Float32Array(flatSize);
                        }

                        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                            plane.normal.toArray(dstArray, i4);
                            dstArray[i4 + 3] = plane.constant;
                        }
                    }

                    uniform.value = dstArray;
                    uniform.needsUpdate = true;
                }

                scope.numPlanes = nPlanes;
                scope.numIntersection = 0;
                return dstArray;
            }
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLExtensions(gl) {
            var extensions = {};
            return {
                get: function (name) {
                    if (extensions[name] !== undefined) {
                        return extensions[name];
                    }

                    var extension;

                    switch (name) {
                        case 'WEBGL_depth_texture':
                            extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                            break;

                        case 'EXT_texture_filter_anisotropic':
                            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                            break;

                        case 'WEBGL_compressed_texture_s3tc':
                            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                            break;

                        case 'WEBGL_compressed_texture_pvrtc':
                            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                            break;

                        default:
                            extension = gl.getExtension(name);
                    }

                    if (extension === null) {
                        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                    }

                    extensions[name] = extension;
                    return extension;
                }
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLGeometries(gl, attributes, info) {
            var geometries = new WeakMap();
            var wireframeAttributes = new WeakMap();

            function onGeometryDispose(event) {
                var geometry = event.target;
                var buffergeometry = geometries.get(geometry);

                if (buffergeometry.index !== null) {
                    attributes.remove(buffergeometry.index);
                }

                for (var name in buffergeometry.attributes) {
                    attributes.remove(buffergeometry.attributes[name]);
                }

                geometry.removeEventListener('dispose', onGeometryDispose);
                geometries.delete(geometry);
                var attribute = wireframeAttributes.get(buffergeometry);

                if (attribute) {
                    attributes.remove(attribute);
                    wireframeAttributes.delete(buffergeometry);
                } //


                info.memory.geometries--;
            }

            function get(object, geometry) {
                var buffergeometry = geometries.get(geometry);
                if (buffergeometry) return buffergeometry;
                geometry.addEventListener('dispose', onGeometryDispose);

                if (geometry.isBufferGeometry) {
                    buffergeometry = geometry;
                } else if (geometry.isGeometry) {
                    if (geometry._bufferGeometry === undefined) {
                        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                    }

                    buffergeometry = geometry._bufferGeometry;
                }

                geometries.set(geometry, buffergeometry);
                info.memory.geometries++;
                return buffergeometry;
            }

            function update(geometry) {
                var index = geometry.index;
                var geometryAttributes = geometry.attributes;

                if (index !== null) {
                    attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
                }

                for (var name in geometryAttributes) {
                    attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
                } // morph targets


                var morphAttributes = geometry.morphAttributes;

                for (var name in morphAttributes) {
                    var array = morphAttributes[name];

                    for (var i = 0, l = array.length; i < l; i++) {
                        attributes.update(array[i], gl.ARRAY_BUFFER);
                    }
                }
            }

            function updateWireframeAttribute(geometry) {
                var indices = [];
                var geometryIndex = geometry.index;
                var geometryPosition = geometry.attributes.position;
                var version = 0;

                if (geometryIndex !== null) {
                    var array = geometryIndex.array;
                    version = geometryIndex.version;

                    for (var i = 0, l = array.length; i < l; i += 3) {
                        var a = array[i + 0];
                        var b = array[i + 1];
                        var c = array[i + 2];
                        indices.push(a, b, b, c, c, a);
                    }
                } else {
                    var array = geometryPosition.array;
                    version = geometryPosition.version;

                    for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                        var a = i + 0;
                        var b = i + 1;
                        var c = i + 2;
                        indices.push(a, b, b, c, c, a);
                    }
                }

                var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
                attribute.version = version;
                attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER); //

                var previousAttribute = wireframeAttributes.get(geometry);
                if (previousAttribute) attributes.remove(previousAttribute); //

                wireframeAttributes.set(geometry, attribute);
            }

            function getWireframeAttribute(geometry) {
                var currentAttribute = wireframeAttributes.get(geometry);

                if (currentAttribute) {
                    var geometryIndex = geometry.index;

                    if (geometryIndex !== null) {
                        // if the attribute is obsolete, create a new one
                        if (currentAttribute.version < geometryIndex.version) {
                            updateWireframeAttribute(geometry);
                        }
                    }
                } else {
                    updateWireframeAttribute(geometry);
                }

                return wireframeAttributes.get(geometry);
            }

            return {
                get: get,
                update: update,
                getWireframeAttribute: getWireframeAttribute
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
            var isWebGL2 = capabilities.isWebGL2;
            var mode;

            function setMode(value) {
                mode = value;
            }

            var type, bytesPerElement;

            function setIndex(value) {
                type = value.type;
                bytesPerElement = value.bytesPerElement;
            }

            function render(start, count) {
                gl.drawElements(mode, count, type, start * bytesPerElement);
                info.update(count, mode);
            }

            function renderInstances(geometry, start, count, primcount) {
                if (primcount === 0) return;
                var extension, methodName;

                if (isWebGL2) {
                    extension = gl;
                    methodName = 'drawElementsInstanced';
                } else {
                    extension = extensions.get('ANGLE_instanced_arrays');
                    methodName = 'drawElementsInstancedANGLE';

                    if (extension === null) {
                        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                        return;
                    }
                }

                extension[methodName](mode, count, type, start * bytesPerElement, primcount);
                info.update(count, mode, primcount);
            } //


            this.setMode = setMode;
            this.setIndex = setIndex;
            this.render = render;
            this.renderInstances = renderInstances;
        }

        /**
         * @author Mugen87 / https://github.com/Mugen87
         */
        function WebGLInfo(gl) {
            var memory = {
                geometries: 0,
                textures: 0
            };
            var render = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };

            function update(count, mode, instanceCount) {
                instanceCount = instanceCount || 1;
                render.calls++;

                switch (mode) {
                    case gl.TRIANGLES:
                        render.triangles += instanceCount * (count / 3);
                        break;

                    case gl.LINES:
                        render.lines += instanceCount * (count / 2);
                        break;

                    case gl.LINE_STRIP:
                        render.lines += instanceCount * (count - 1);
                        break;

                    case gl.LINE_LOOP:
                        render.lines += instanceCount * count;
                        break;

                    case gl.POINTS:
                        render.points += instanceCount * count;
                        break;

                    default:
                        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                        break;
                }
            }

            function reset() {
                render.frame++;
                render.calls = 0;
                render.triangles = 0;
                render.points = 0;
                render.lines = 0;
            }

            return {
                memory: memory,
                render: render,
                programs: null,
                autoReset: true,
                reset: reset,
                update: update
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function absNumericalSort(a, b) {
            return Math.abs(b[1]) - Math.abs(a[1]);
        }

        function WebGLMorphtargets(gl) {
            var influencesList = {};
            var morphInfluences = new Float32Array(8);

            function update(object, geometry, material, program) {
                var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
                // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

                var length = objectInfluences === undefined ? 0 : objectInfluences.length;
                var influences = influencesList[geometry.id];

                if (influences === undefined) {
                    // initialise list
                    influences = [];

                    for (var i = 0; i < length; i++) {
                        influences[i] = [i, 0];
                    }

                    influencesList[geometry.id] = influences;
                }

                var morphTargets = material.morphTargets && geometry.morphAttributes.position;
                var morphNormals = material.morphNormals && geometry.morphAttributes.normal; // Remove current morphAttributes

                for (var i = 0; i < length; i++) {
                    var influence = influences[i];

                    if (influence[1] !== 0) {
                        if (morphTargets) geometry.deleteAttribute('morphTarget' + i);
                        if (morphNormals) geometry.deleteAttribute('morphNormal' + i);
                    }
                } // Collect influences


                for (var i = 0; i < length; i++) {
                    var influence = influences[i];
                    influence[0] = i;
                    influence[1] = objectInfluences[i];
                }

                influences.sort(absNumericalSort); // Add morphAttributes

                var morphInfluencesSum = 0;

                for (var i = 0; i < 8; i++) {
                    var influence = influences[i];

                    if (influence) {
                        var index = influence[0];
                        var value = influence[1];

                        if (value) {
                            if (morphTargets) geometry.setAttribute('morphTarget' + i, morphTargets[index]);
                            if (morphNormals) geometry.setAttribute('morphNormal' + i, morphNormals[index]);
                            morphInfluences[i] = value;
                            morphInfluencesSum += value;
                            continue;
                        }
                    }

                    morphInfluences[i] = 0;
                } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
                // This allows us to switch between absolute morphs and relative morphs without changing shader code
                // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


                var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
                program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
            }

            return {
                update: update
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLObjects(gl, geometries, attributes, info) {
            var updateMap = new WeakMap();

            function update(object) {
                var frame = info.render.frame;
                var geometry = object.geometry;
                var buffergeometry = geometries.get(object, geometry); // Update once per frame

                if (updateMap.get(buffergeometry) !== frame) {
                    if (geometry.isGeometry) {
                        buffergeometry.updateFromObject(object);
                    }

                    geometries.update(buffergeometry);
                    updateMap.set(buffergeometry, frame);
                }

                if (object.isInstancedMesh) {
                    attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
                }

                return buffergeometry;
            }

            function dispose() {
                updateMap = new WeakMap();
            }

            return {
                update: update,
                dispose: dispose
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            images = images !== undefined ? images : [];
            mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
            format = format !== undefined ? format : RGBFormat;
            Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.flipY = false;
        }

        CubeTexture.prototype = Object.create(Texture.prototype);
        CubeTexture.prototype.constructor = CubeTexture;
        CubeTexture.prototype.isCubeTexture = true;
        Object.defineProperty(CubeTexture.prototype, 'images', {
            get: function () {
                return this.image;
            },
            set: function (value) {
                this.image = value;
            }
        });

        /**
         * @author Takahiro https://github.com/takahirox
         */

        function DataTexture2DArray(data, width, height, depth) {
            Texture.call(this, null);
            this.image = {
                data: data || null,
                width: width || 1,
                height: height || 1,
                depth: depth || 1
            };
            this.magFilter = NearestFilter;
            this.minFilter = NearestFilter;
            this.wrapR = ClampToEdgeWrapping;
            this.generateMipmaps = false;
            this.flipY = false;
            this.needsUpdate = true;
        }

        DataTexture2DArray.prototype = Object.create(Texture.prototype);
        DataTexture2DArray.prototype.constructor = DataTexture2DArray;
        DataTexture2DArray.prototype.isDataTexture2DArray = true;

        /**
         * @author Artur Trzesiok
         */

        function DataTexture3D(data, width, height, depth) {
            // We're going to add .setXXX() methods for setting properties later.
            // Users can still set in DataTexture3D directly.
            //
            //	var texture = new THREE.DataTexture3D( data, width, height, depth );
            // 	texture.anisotropy = 16;
            //
            // See #14839
            Texture.call(this, null);
            this.image = {
                data: data || null,
                width: width || 1,
                height: height || 1,
                depth: depth || 1
            };
            this.magFilter = NearestFilter;
            this.minFilter = NearestFilter;
            this.wrapR = ClampToEdgeWrapping;
            this.generateMipmaps = false;
            this.flipY = false;
            this.needsUpdate = true;
        }

        DataTexture3D.prototype = Object.create(Texture.prototype);
        DataTexture3D.prototype.constructor = DataTexture3D;
        DataTexture3D.prototype.isDataTexture3D = true;

        /**
         * @author tschw
         * @author Mugen87 / https://github.com/Mugen87
         * @author mrdoob / http://mrdoob.com/
         *
         * Uniforms of a program.
         * Those form a tree structure with a special top-level container for the root,
         * which you get by calling 'new WebGLUniforms( gl, program )'.
         *
         *
         * Properties of inner nodes including the top-level container:
         *
         * .seq - array of nested uniforms
         * .map - nested uniforms by name
         *
         *
         * Methods of all nodes except the top-level container:
         *
         * .setValue( gl, value, [textures] )
         *
         * 		uploads a uniform value(s)
         *  	the 'textures' parameter is needed for sampler uniforms
         *
         *
         * Static methods of the top-level container (textures factorizations):
         *
         * .upload( gl, seq, values, textures )
         *
         * 		sets uniforms in 'seq' to 'values[id].value'
         *
         * .seqWithValue( seq, values ) : filteredSeq
         *
         * 		filters 'seq' entries with corresponding entry in values
         *
         *
         * Methods of the top-level container (textures factorizations):
         *
         * .setValue( gl, name, value, textures )
         *
         * 		sets uniform with  name 'name' to 'value'
         *
         * .setOptional( gl, obj, prop )
         *
         * 		like .set for an optional property of the object
         *
         */
        var emptyTexture = new Texture();
        var emptyTexture2dArray = new DataTexture2DArray();
        var emptyTexture3d = new DataTexture3D();
        var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
        // Array Caches (provide typed arrays for temporary by size)

        var arrayCacheF32 = [];
        var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

        var mat4array = new Float32Array(16);
        var mat3array = new Float32Array(9);
        var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

        function flatten(array, nBlocks, blockSize) {
            var firstElem = array[0];
            if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
            // see http://jacksondunstan.com/articles/983

            var n = nBlocks * blockSize,
                r = arrayCacheF32[n];

            if (r === undefined) {
                r = new Float32Array(n);
                arrayCacheF32[n] = r;
            }

            if (nBlocks !== 0) {
                firstElem.toArray(r, 0);

                for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                    offset += blockSize;
                    array[i].toArray(r, offset);
                }
            }

            return r;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;

            for (var i = 0, l = a.length; i < l; i++) {
                if (a[i] !== b[i]) return false;
            }

            return true;
        }

        function copyArray(a, b) {
            for (var i = 0, l = b.length; i < l; i++) {
                a[i] = b[i];
            }
        } // Texture unit allocation


        function allocTexUnits(textures, n) {
            var r = arrayCacheI32[n];

            if (r === undefined) {
                r = new Int32Array(n);
                arrayCacheI32[n] = r;
            }

            for (var i = 0; i !== n; ++i) r[i] = textures.allocateTextureUnit();

            return r;
        } // --- Setters ---
        // Note: Defining these methods externally, because they come in a bunch
        // and this way their names minify.
        // Single scalar


        function setValueV1f(gl, v) {
            var cache = this.cache;
            if (cache[0] === v) return;
            gl.uniform1f(this.addr, v);
            cache[0] = v;
        } // Single float vector (from flat array or THREE.VectorN)


        function setValueV2f(gl, v) {
            var cache = this.cache;

            if (v.x !== undefined) {
                if (cache[0] !== v.x || cache[1] !== v.y) {
                    gl.uniform2f(this.addr, v.x, v.y);
                    cache[0] = v.x;
                    cache[1] = v.y;
                }
            } else {
                if (arraysEqual(cache, v)) return;
                gl.uniform2fv(this.addr, v);
                copyArray(cache, v);
            }
        }

        function setValueV3f(gl, v) {
            var cache = this.cache;

            if (v.x !== undefined) {
                if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                    gl.uniform3f(this.addr, v.x, v.y, v.z);
                    cache[0] = v.x;
                    cache[1] = v.y;
                    cache[2] = v.z;
                }
            } else if (v.r !== undefined) {
                if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                    gl.uniform3f(this.addr, v.r, v.g, v.b);
                    cache[0] = v.r;
                    cache[1] = v.g;
                    cache[2] = v.b;
                }
            } else {
                if (arraysEqual(cache, v)) return;
                gl.uniform3fv(this.addr, v);
                copyArray(cache, v);
            }
        }

        function setValueV4f(gl, v) {
            var cache = this.cache;

            if (v.x !== undefined) {
                if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                    gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                    cache[0] = v.x;
                    cache[1] = v.y;
                    cache[2] = v.z;
                    cache[3] = v.w;
                }
            } else {
                if (arraysEqual(cache, v)) return;
                gl.uniform4fv(this.addr, v);
                copyArray(cache, v);
            }
        } // Single matrix (from flat array or MatrixN)


        function setValueM2(gl, v) {
            var cache = this.cache;
            var elements = v.elements;

            if (elements === undefined) {
                if (arraysEqual(cache, v)) return;
                gl.uniformMatrix2fv(this.addr, false, v);
                copyArray(cache, v);
            } else {
                if (arraysEqual(cache, elements)) return;
                mat2array.set(elements);
                gl.uniformMatrix2fv(this.addr, false, mat2array);
                copyArray(cache, elements);
            }
        }

        function setValueM3(gl, v) {
            var cache = this.cache;
            var elements = v.elements;

            if (elements === undefined) {
                if (arraysEqual(cache, v)) return;
                gl.uniformMatrix3fv(this.addr, false, v);
                copyArray(cache, v);
            } else {
                if (arraysEqual(cache, elements)) return;
                mat3array.set(elements);
                gl.uniformMatrix3fv(this.addr, false, mat3array);
                copyArray(cache, elements);
            }
        }

        function setValueM4(gl, v) {
            var cache = this.cache;
            var elements = v.elements;

            if (elements === undefined) {
                if (arraysEqual(cache, v)) return;
                gl.uniformMatrix4fv(this.addr, false, v);
                copyArray(cache, v);
            } else {
                if (arraysEqual(cache, elements)) return;
                mat4array.set(elements);
                gl.uniformMatrix4fv(this.addr, false, mat4array);
                copyArray(cache, elements);
            }
        } // Single texture (2D / Cube)


        function setValueT1(gl, v, textures) {
            var cache = this.cache;
            var unit = textures.allocateTextureUnit();

            if (cache[0] !== unit) {
                gl.uniform1i(this.addr, unit);
                cache[0] = unit;
            }

            textures.safeSetTexture2D(v || emptyTexture, unit);
        }

        function setValueT2DArray1(gl, v, textures) {
            var cache = this.cache;
            var unit = textures.allocateTextureUnit();

            if (cache[0] !== unit) {
                gl.uniform1i(this.addr, unit);
                cache[0] = unit;
            }

            textures.setTexture2DArray(v || emptyTexture2dArray, unit);
        }

        function setValueT3D1(gl, v, textures) {
            var cache = this.cache;
            var unit = textures.allocateTextureUnit();

            if (cache[0] !== unit) {
                gl.uniform1i(this.addr, unit);
                cache[0] = unit;
            }

            textures.setTexture3D(v || emptyTexture3d, unit);
        }

        function setValueT6(gl, v, textures) {
            var cache = this.cache;
            var unit = textures.allocateTextureUnit();

            if (cache[0] !== unit) {
                gl.uniform1i(this.addr, unit);
                cache[0] = unit;
            }

            textures.safeSetTextureCube(v || emptyCubeTexture, unit);
        } // Integer / Boolean vectors or arrays thereof (always flat arrays)


        function setValueV1i(gl, v) {
            var cache = this.cache;
            if (cache[0] === v) return;
            gl.uniform1i(this.addr, v);
            cache[0] = v;
        }

        function setValueV2i(gl, v) {
            var cache = this.cache;
            if (arraysEqual(cache, v)) return;
            gl.uniform2iv(this.addr, v);
            copyArray(cache, v);
        }

        function setValueV3i(gl, v) {
            var cache = this.cache;
            if (arraysEqual(cache, v)) return;
            gl.uniform3iv(this.addr, v);
            copyArray(cache, v);
        }

        function setValueV4i(gl, v) {
            var cache = this.cache;
            if (arraysEqual(cache, v)) return;
            gl.uniform4iv(this.addr, v);
            copyArray(cache, v);
        } // uint


        function setValueV1ui(gl, v) {
            var cache = this.cache;
            if (cache[0] === v) return;
            gl.uniform1ui(this.addr, v);
            cache[0] = v;
        } // Helper to pick the right setter for the singular case


        function getSingularSetter(type) {
            switch (type) {
                case 0x1406:
                    return setValueV1f;
                // FLOAT

                case 0x8b50:
                    return setValueV2f;
                // _VEC2

                case 0x8b51:
                    return setValueV3f;
                // _VEC3

                case 0x8b52:
                    return setValueV4f;
                // _VEC4

                case 0x8b5a:
                    return setValueM2;
                // _MAT2

                case 0x8b5b:
                    return setValueM3;
                // _MAT3

                case 0x8b5c:
                    return setValueM4;
                // _MAT4

                case 0x1404:
                case 0x8b56:
                    return setValueV1i;
                // INT, BOOL

                case 0x8b53:
                case 0x8b57:
                    return setValueV2i;
                // _VEC2

                case 0x8b54:
                case 0x8b58:
                    return setValueV3i;
                // _VEC3

                case 0x8b55:
                case 0x8b59:
                    return setValueV4i;
                // _VEC4

                case 0x1405:
                    return setValueV1ui;
                // UINT

                case 0x8b5e: // SAMPLER_2D

                case 0x8d66: // SAMPLER_EXTERNAL_OES

                case 0x8dca: // INT_SAMPLER_2D

                case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

                case 0x8b62:
                    // SAMPLER_2D_SHADOW
                    return setValueT1;

                case 0x8b5f: // SAMPLER_3D

                case 0x8dcb: // INT_SAMPLER_3D

                case 0x8dd3:
                    // UNSIGNED_INT_SAMPLER_3D
                    return setValueT3D1;

                case 0x8b60: // SAMPLER_CUBE

                case 0x8dcc: // INT_SAMPLER_CUBE

                case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

                case 0x8dc5:
                    // SAMPLER_CUBE_SHADOW
                    return setValueT6;

                case 0x8dc1: // SAMPLER_2D_ARRAY

                case 0x8dcf: // INT_SAMPLER_2D_ARRAY

                case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

                case 0x8dc4:
                    // SAMPLER_2D_ARRAY_SHADOW
                    return setValueT2DArray1;
            }
        } // Array of scalars


        function setValueV1fArray(gl, v) {
            gl.uniform1fv(this.addr, v);
        } // Integer / Boolean vectors or arrays thereof (always flat arrays)


        function setValueV1iArray(gl, v) {
            gl.uniform1iv(this.addr, v);
        }

        function setValueV2iArray(gl, v) {
            gl.uniform2iv(this.addr, v);
        }

        function setValueV3iArray(gl, v) {
            gl.uniform3iv(this.addr, v);
        }

        function setValueV4iArray(gl, v) {
            gl.uniform4iv(this.addr, v);
        } // Array of vectors (flat or from THREE classes)


        function setValueV2fArray(gl, v) {
            var data = flatten(v, this.size, 2);
            gl.uniform2fv(this.addr, data);
        }

        function setValueV3fArray(gl, v) {
            var data = flatten(v, this.size, 3);
            gl.uniform3fv(this.addr, data);
        }

        function setValueV4fArray(gl, v) {
            var data = flatten(v, this.size, 4);
            gl.uniform4fv(this.addr, data);
        } // Array of matrices (flat or from THREE clases)


        function setValueM2Array(gl, v) {
            var data = flatten(v, this.size, 4);
            gl.uniformMatrix2fv(this.addr, false, data);
        }

        function setValueM3Array(gl, v) {
            var data = flatten(v, this.size, 9);
            gl.uniformMatrix3fv(this.addr, false, data);
        }

        function setValueM4Array(gl, v) {
            var data = flatten(v, this.size, 16);
            gl.uniformMatrix4fv(this.addr, false, data);
        } // Array of textures (2D / Cube)


        function setValueT1Array(gl, v, textures) {
            var n = v.length;
            var units = allocTexUnits(textures, n);
            gl.uniform1iv(this.addr, units);

            for (var i = 0; i !== n; ++i) {
                textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
            }
        }

        function setValueT6Array(gl, v, textures) {
            var n = v.length;
            var units = allocTexUnits(textures, n);
            gl.uniform1iv(this.addr, units);

            for (var i = 0; i !== n; ++i) {
                textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
            }
        } // Helper to pick the right setter for a pure (bottom-level) array


        function getPureArraySetter(type) {
            switch (type) {
                case 0x1406:
                    return setValueV1fArray;
                // FLOAT

                case 0x8b50:
                    return setValueV2fArray;
                // _VEC2

                case 0x8b51:
                    return setValueV3fArray;
                // _VEC3

                case 0x8b52:
                    return setValueV4fArray;
                // _VEC4

                case 0x8b5a:
                    return setValueM2Array;
                // _MAT2

                case 0x8b5b:
                    return setValueM3Array;
                // _MAT3

                case 0x8b5c:
                    return setValueM4Array;
                // _MAT4

                case 0x1404:
                case 0x8b56:
                    return setValueV1iArray;
                // INT, BOOL

                case 0x8b53:
                case 0x8b57:
                    return setValueV2iArray;
                // _VEC2

                case 0x8b54:
                case 0x8b58:
                    return setValueV3iArray;
                // _VEC3

                case 0x8b55:
                case 0x8b59:
                    return setValueV4iArray;
                // _VEC4

                case 0x8b5e: // SAMPLER_2D

                case 0x8d66: // SAMPLER_EXTERNAL_OES

                case 0x8dca: // INT_SAMPLER_2D

                case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

                case 0x8b62:
                    // SAMPLER_2D_SHADOW
                    return setValueT1Array;

                case 0x8b60: // SAMPLER_CUBE

                case 0x8dcc: // INT_SAMPLER_CUBE

                case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

                case 0x8dc5:
                    // SAMPLER_CUBE_SHADOW
                    return setValueT6Array;
            }
        } // --- Uniform Classes ---


        function SingleUniform(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.cache = [];
            this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
        }

        function PureArrayUniform(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.cache = [];
            this.size = activeInfo.size;
            this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
        }

        PureArrayUniform.prototype.updateCache = function (data) {
            var cache = this.cache;

            if (data instanceof Float32Array && cache.length !== data.length) {
                this.cache = new Float32Array(data.length);
            }

            copyArray(cache, data);
        };

        function StructuredUniform(id) {
            this.id = id;
            this.seq = [];
            this.map = {};
        }

        StructuredUniform.prototype.setValue = function (gl, value, textures) {
            var seq = this.seq;

            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                u.setValue(gl, value[u.id], textures);
            }
        }; // --- Top-level ---
        // Parser - builds up the property tree from the path strings


        var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
        // 	- the identifier (member name or array index)
        //  - followed by an optional right bracket (found when array index)
        //  - followed by an optional left bracket or dot (type of subscript)
        //
        // Note: These portions can be read in a non-overlapping fashion and
        // allow straightforward parsing of the hierarchy that WebGL encodes
        // in the uniform names.

        function addUniform(container, uniformObject) {
            container.seq.push(uniformObject);
            container.map[uniformObject.id] = uniformObject;
        }

        function parseUniform(activeInfo, addr, container) {
            var path = activeInfo.name,
                pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

            RePathPart.lastIndex = 0;

            while (true) {
                var match = RePathPart.exec(path),
                    matchEnd = RePathPart.lastIndex,
                    id = match[1],
                    idIsIndex = match[2] === ']',
                    subscript = match[3];
                if (idIsIndex) id = id | 0; // convert to integer

                if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                    // bare name or "pure" bottom-level array "[0]" suffix
                    addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                    break;
                } else {
                    // step into inner node / create it in case it doesn't exist
                    var map = container.map,
                        next = map[id];

                    if (next === undefined) {
                        next = new StructuredUniform(id);
                        addUniform(container, next);
                    }

                    container = next;
                }
            }
        } // Root Container


        function WebGLUniforms(gl, program) {
            this.seq = [];
            this.map = {};
            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

            for (var i = 0; i < n; ++i) {
                var info = gl.getActiveUniform(program, i),
                    addr = gl.getUniformLocation(program, info.name);
                parseUniform(info, addr, this);
            }
        }

        WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
            var u = this.map[name];
            if (u !== undefined) u.setValue(gl, value, textures);
        };

        WebGLUniforms.prototype.setOptional = function (gl, object, name) {
            var v = object[name];
            if (v !== undefined) this.setValue(gl, name, v);
        }; // Static interface


        WebGLUniforms.upload = function (gl, seq, values, textures) {
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i],
                    v = values[u.id];

                if (v.needsUpdate !== false) {
                    // note: always updating when .needsUpdate is undefined
                    u.setValue(gl, v.value, textures);
                }
            }
        };

        WebGLUniforms.seqWithValue = function (seq, values) {
            var r = [];

            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                if (u.id in values) r.push(u);
            }

            return r;
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function WebGLShader(gl, type, string) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, string);
            gl.compileShader(shader);
            return shader;
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        var programIdCount = 0;

        function addLineNumbers(string) {
            var lines = string.split('\n');

            for (var i = 0; i < lines.length; i++) {
                lines[i] = i + 1 + ': ' + lines[i];
            }

            return lines.join('\n');
        }

        function getEncodingComponents(encoding) {
            switch (encoding) {
                case LinearEncoding:
                    return ['Linear', '( value )'];

                case sRGBEncoding:
                    return ['sRGB', '( value )'];

                case RGBEEncoding:
                    return ['RGBE', '( value )'];

                case RGBM7Encoding:
                    return ['RGBM', '( value, 7.0 )'];

                case RGBM16Encoding:
                    return ['RGBM', '( value, 16.0 )'];

                case RGBDEncoding:
                    return ['RGBD', '( value, 256.0 )'];

                case GammaEncoding:
                    return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

                case LogLuvEncoding:
                    return ['LogLuv', '( value )'];

                default:
                    throw new Error('unsupported encoding: ' + encoding);
            }
        }

        function getShaderErrors(gl, shader, type) {
            var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            var log = gl.getShaderInfoLog(shader).trim();
            if (status && log === '') return ''; // --enable-privileged-webgl-extension
            // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

            var source = gl.getShaderSource(shader);
            return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
        }

        function getTexelDecodingFunction(functionName, encoding) {
            var components = getEncodingComponents(encoding);
            return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
        }

        function getTexelEncodingFunction(functionName, encoding) {
            var components = getEncodingComponents(encoding);
            return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
        }

        function getToneMappingFunction(functionName, toneMapping) {
            var toneMappingName;

            switch (toneMapping) {
                case LinearToneMapping:
                    toneMappingName = 'Linear';
                    break;

                case ReinhardToneMapping:
                    toneMappingName = 'Reinhard';
                    break;

                case Uncharted2ToneMapping:
                    toneMappingName = 'Uncharted2';
                    break;

                case CineonToneMapping:
                    toneMappingName = 'OptimizedCineon';
                    break;

                case ACESFilmicToneMapping:
                    toneMappingName = 'ACESFilmic';
                    break;

                default:
                    throw new Error('unsupported toneMapping: ' + toneMapping);
            }

            return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
        }

        function generateExtensions(parameters) {
            var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
            return chunks.filter(filterEmptyLine).join('\n');
        }

        function generateDefines(defines) {
            var chunks = [];

            for (var name in defines) {
                var value = defines[name];
                if (value === false) continue;
                chunks.push('#define ' + name + ' ' + value);
            }

            return chunks.join('\n');
        }

        function fetchAttributeLocations(gl, program) {
            var attributes = {};
            var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

            for (var i = 0; i < n; i++) {
                var info = gl.getActiveAttrib(program, i);
                var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

                attributes[name] = gl.getAttribLocation(program, name);
            }

            return attributes;
        }

        function filterEmptyLine(string) {
            return string !== '';
        }

        function replaceLightNums(string, parameters) {
            return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
        }

        function replaceClippingPlaneNums(string, parameters) {
            return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
        } // Resolve Includes


        var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function resolveIncludes(string) {
            return string.replace(includePattern, includeReplacer);
        }

        function includeReplacer(match, include) {
            var string = ShaderChunk[include];

            if (string === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }

            return resolveIncludes(string);
        } // Unroll Loops


        var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

        function unrollLoops(string) {
            return string.replace(loopPattern, loopReplacer);
        }

        function loopReplacer(match, start, end, snippet) {
            var string = '';

            for (var i = parseInt(start); i < parseInt(end); i++) {
                string += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
            }

            return string;
        } //


        function generatePrecision(parameters) {
            var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

            if (parameters.precision === "highp") {
                precisionstring += "\n#define HIGH_PRECISION";
            } else if (parameters.precision === "mediump") {
                precisionstring += "\n#define MEDIUM_PRECISION";
            } else if (parameters.precision === "lowp") {
                precisionstring += "\n#define LOW_PRECISION";
            }

            return precisionstring;
        }

        function generateShadowMapTypeDefine(parameters) {
            var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

            if (parameters.shadowMapType === PCFShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
            } else if (parameters.shadowMapType === PCFSoftShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
            } else if (parameters.shadowMapType === VSMShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
            }

            return shadowMapTypeDefine;
        }

        function generateEnvMapTypeDefine(parameters) {
            var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

            if (parameters.envMap) {
                switch (parameters.envMapMode) {
                    case CubeReflectionMapping:
                    case CubeRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                        break;

                    case CubeUVReflectionMapping:
                    case CubeUVRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                        break;

                    case EquirectangularReflectionMapping:
                    case EquirectangularRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                        break;

                    case SphericalReflectionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                        break;
                }
            }

            return envMapTypeDefine;
        }

        function generateEnvMapModeDefine(parameters) {
            var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

            if (parameters.envMap) {
                switch (parameters.envMapMode) {
                    case CubeRefractionMapping:
                    case EquirectangularRefractionMapping:
                        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                        break;
                }
            }

            return envMapModeDefine;
        }

        function generateEnvMapBlendingDefine(parameters) {
            var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

            if (parameters.envMap) {
                switch (parameters.combine) {
                    case MultiplyOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                        break;

                    case MixOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                        break;

                    case AddOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                        break;
                }
            }

            return envMapBlendingDefine;
        }

        function WebGLProgram(renderer, cacheKey, parameters) {
            var gl = renderer.getContext();
            var defines = parameters.defines;
            var vertexShader = parameters.vertexShader;
            var fragmentShader = parameters.fragmentShader;
            var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
            var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
            var envMapModeDefine = generateEnvMapModeDefine(parameters);
            var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
            var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
            var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
            var customDefines = generateDefines(defines);
            var program = gl.createProgram();
            var prefixVertex, prefixFragment;

            if (parameters.isRawShaderMaterial) {
                prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

                if (prefixVertex.length > 0) {
                    prefixVertex += '\n';
                }

                prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

                if (prefixFragment.length > 0) {
                    prefixFragment += '\n';
                }
            } else {
                prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', ' attribute mat4 instanceMatrix;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
                prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
                    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
                    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
                    parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMapEncoding ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
            }

            vertexShader = resolveIncludes(vertexShader);
            vertexShader = replaceLightNums(vertexShader, parameters);
            vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
            fragmentShader = resolveIncludes(fragmentShader);
            fragmentShader = replaceLightNums(fragmentShader, parameters);
            fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);

            if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
                var isGLSL3ShaderMaterial = false;
                var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

                if (parameters.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
                    isGLSL3ShaderMaterial = true;
                    vertexShader = vertexShader.replace(versionRegex, '');
                    fragmentShader = fragmentShader.replace(versionRegex, '');
                } // GLSL 3.0 conversion


                prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
                prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
            }

            var vertexGlsl = prefixVertex + vertexShader;
            var fragmentGlsl = prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
            // console.log( '*FRAGMENT*', fragmentGlsl );

            var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
            var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
            gl.attachShader(program, glVertexShader);
            gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

            if (parameters.index0AttributeName !== undefined) {
                gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
            } else if (parameters.morphTargets === true) {
                // programs with morphTargets displace position out of attribute 0
                gl.bindAttribLocation(program, 0, 'position');
            }

            gl.linkProgram(program); // check for link errors

            if (renderer.debug.checkShaderErrors) {
                var programLog = gl.getProgramInfoLog(program).trim();
                var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
                var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
                var runnable = true;
                var haveDiagnostics = true;

                if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                    runnable = false;
                    var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                    var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                    console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
                } else if (programLog !== '') {
                    console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
                } else if (vertexLog === '' || fragmentLog === '') {
                    haveDiagnostics = false;
                }

                if (haveDiagnostics) {
                    this.diagnostics = {
                        runnable: runnable,
                        programLog: programLog,
                        vertexShader: {
                            log: vertexLog,
                            prefix: prefixVertex
                        },
                        fragmentShader: {
                            log: fragmentLog,
                            prefix: prefixFragment
                        }
                    };
                }
            } // clean up


            gl.detachShader(program, glVertexShader);
            gl.detachShader(program, glFragmentShader);
            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader); // set up caching for uniform locations

            var cachedUniforms;

            this.getUniforms = function () {
                if (cachedUniforms === undefined) {
                    cachedUniforms = new WebGLUniforms(gl, program);
                }

                return cachedUniforms;
            }; // set up caching for attribute locations


            var cachedAttributes;

            this.getAttributes = function () {
                if (cachedAttributes === undefined) {
                    cachedAttributes = fetchAttributeLocations(gl, program);
                }

                return cachedAttributes;
            }; // free resource


            this.destroy = function () {
                gl.deleteProgram(program);
                this.program = undefined;
            }; //


            this.name = parameters.shaderName;
            this.id = programIdCount++;
            this.cacheKey = cacheKey;
            this.usedTimes = 1;
            this.program = program;
            this.vertexShader = glVertexShader;
            this.fragmentShader = glFragmentShader;
            return this;
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLPrograms(renderer, extensions, capabilities) {
            var programs = [];
            var isWebGL2 = capabilities.isWebGL2;
            var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
            var floatVertexTextures = capabilities.floatVertexTextures;
            var precision = capabilities.precision;
            var maxVertexUniforms = capabilities.maxVertexUniforms;
            var vertexTextures = capabilities.vertexTextures;
            var shaderIDs = {
                MeshDepthMaterial: 'depth',
                MeshDistanceMaterial: 'distanceRGBA',
                MeshNormalMaterial: 'normal',
                MeshBasicMaterial: 'basic',
                MeshLambertMaterial: 'lambert',
                MeshPhongMaterial: 'phong',
                MeshToonMaterial: 'toon',
                MeshStandardMaterial: 'physical',
                MeshPhysicalMaterial: 'physical',
                MeshMatcapMaterial: 'matcap',
                LineBasicMaterial: 'basic',
                LineDashedMaterial: 'dashed',
                PointsMaterial: 'points',
                ShadowMaterial: 'shadow',
                SpriteMaterial: 'sprite'
            };
            var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

            function getShaderObject(material, shaderID) {
                var shaderobject;

                if (shaderID) {
                    var shader = ShaderLib[shaderID];
                    shaderobject = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {
                    shaderobject = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }

                return shaderobject;
            }

            function allocateBones(object) {
                var skeleton = object.skeleton;
                var bones = skeleton.bones;

                if (floatVertexTextures) {
                    return 1024;
                } else {
                    // default for when object is not specified
                    // ( for example when prebuilding shader to be used with multiple objects )
                    //
                    //  - leave some extra space for other uniforms
                    //  - limit here is ANGLE's 254 max uniform vectors
                    //    (up to 54 should be safe)
                    var nVertexUniforms = maxVertexUniforms;
                    var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                    var maxBones = Math.min(nVertexMatrices, bones.length);

                    if (maxBones < bones.length) {
                        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                        return 0;
                    }

                    return maxBones;
                }
            }

            function getTextureEncodingFromMap(map) {
                var encoding;

                if (!map) {
                    encoding = LinearEncoding;
                } else if (map.isTexture) {
                    encoding = map.encoding;
                } else if (map.isWebGLRenderTarget) {
                    console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                    encoding = map.texture.encoding;
                }

                return encoding;
            }

            this.getParameters = function (material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
                var fog = scene.fog;
                var environment = material.isMeshStandardMaterial ? scene.environment : null;
                var envMap = material.envMap || environment;
                var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
                // (not to blow over maxLights budget)

                var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;

                if (material.precision !== null) {
                    precision = capabilities.getMaxPrecision(material.precision);

                    if (precision !== material.precision) {
                        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                    }
                }

                var shaderobject = getShaderObject(material, shaderID);
                material.onBeforeCompile(shaderobject, renderer);
                var currentRenderTarget = renderer.getRenderTarget();
                var parameters = {
                    isWebGL2: isWebGL2,
                    shaderID: shaderID,
                    shaderName: shaderobject.name,
                    uniforms: shaderobject.uniforms,
                    vertexShader: shaderobject.vertexShader,
                    fragmentShader: shaderobject.fragmentShader,
                    defines: material.defines,
                    isRawShaderMaterial: material.isRawShaderMaterial,
                    isShaderMaterial: material.isShaderMaterial,
                    precision: precision,
                    instancing: object.isInstancedMesh === true,
                    supportsVertexTextures: vertexTextures,
                    outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
                    map: !!material.map,
                    mapEncoding: getTextureEncodingFromMap(material.map),
                    matcap: !!material.matcap,
                    matcapEncoding: getTextureEncodingFromMap(material.matcap),
                    envMap: !!envMap,
                    envMapMode: envMap && envMap.mapping,
                    envMapEncoding: getTextureEncodingFromMap(envMap),
                    envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
                    lightMap: !!material.lightMap,
                    lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
                    aoMap: !!material.aoMap,
                    emissiveMap: !!material.emissiveMap,
                    emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
                    bumpMap: !!material.bumpMap,
                    normalMap: !!material.normalMap,
                    objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                    tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                    clearcoatNormalMap: !!material.clearcoatNormalMap,
                    displacementMap: !!material.displacementMap,
                    roughnessMap: !!material.roughnessMap,
                    metalnessMap: !!material.metalnessMap,
                    specularMap: !!material.specularMap,
                    alphaMap: !!material.alphaMap,
                    gradientMap: !!material.gradientMap,
                    sheen: !!material.sheen,
                    combine: material.combine,
                    vertexTangents: material.normalMap && material.vertexTangents,
                    vertexColors: material.vertexColors,
                    vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
                    uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
                    fog: !!fog,
                    useFog: material.fog,
                    fogExp2: fog && fog.isFogExp2,
                    flatShading: material.flatShading,
                    sizeAttenuation: material.sizeAttenuation,
                    logarithmicDepthBuffer: logarithmicDepthBuffer,
                    skinning: material.skinning && maxBones > 0,
                    maxBones: maxBones,
                    useVertexTexture: floatVertexTextures,
                    morphTargets: material.morphTargets,
                    morphNormals: material.morphNormals,
                    maxMorphTargets: renderer.maxMorphTargets,
                    maxMorphNormals: renderer.maxMorphNormals,
                    numDirLights: lights.directional.length,
                    numPointLights: lights.point.length,
                    numSpotLights: lights.spot.length,
                    numRectAreaLights: lights.rectArea.length,
                    numHemiLights: lights.hemi.length,
                    numDirLightShadows: lights.directionalShadowMap.length,
                    numPointLightShadows: lights.pointShadowMap.length,
                    numSpotLightShadows: lights.spotShadowMap.length,
                    numClippingPlanes: nClipPlanes,
                    numClipIntersection: nClipIntersection,
                    dithering: material.dithering,
                    shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                    shadowMapType: renderer.shadowMap.type,
                    toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                    physicallyCorrectLights: renderer.physicallyCorrectLights,
                    premultipliedAlpha: material.premultipliedAlpha,
                    alphaTest: material.alphaTest,
                    doubleSided: material.side === DoubleSide,
                    flipSided: material.side === BackSide,
                    depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
                    index0AttributeName: material.index0AttributeName,
                    extensionDerivatives: material.extensions && material.extensions.derivatives,
                    extensionFragDepth: material.extensions && material.extensions.fragDepth,
                    extensionDrawbuffers: material.extensions && material.extensions.drawBuffers,
                    extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
                    rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
                    rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
                    onBeforeCompile: material.onBeforeCompile
                };
                return parameters;
            };

            this.getProgramCacheKey = function (parameters) {
                var array = [];

                if (parameters.shaderID) {
                    array.push(parameters.shaderID);
                } else {
                    array.push(parameters.fragmentShader);
                    array.push(parameters.vertexShader);
                }

                if (parameters.defines !== undefined) {
                    for (var name in parameters.defines) {
                        array.push(name);
                        array.push(parameters.defines[name]);
                    }
                }

                if (parameters.isRawShaderMaterial === undefined) {
                    for (var i = 0; i < parameterNames.length; i++) {
                        array.push(parameters[parameterNames[i]]);
                    }

                    array.push(renderer.outputEncoding);
                    array.push(renderer.gammaFactor);
                }

                array.push(parameters.onBeforeCompile.toString());
                return array.join();
            };

            this.acquireProgram = function (parameters, cacheKey) {
                var program; // Check if code has been already compiled

                for (var p = 0, pl = programs.length; p < pl; p++) {
                    var preexistingProgram = programs[p];

                    if (preexistingProgram.cacheKey === cacheKey) {
                        program = preexistingProgram;
                        ++program.usedTimes;
                        break;
                    }
                }

                if (program === undefined) {
                    program = new WebGLProgram(renderer, cacheKey, parameters);
                    programs.push(program);
                }

                return program;
            };

            this.releaseProgram = function (program) {
                if (--program.usedTimes === 0) {
                    // Remove from unordered set
                    var i = programs.indexOf(program);
                    programs[i] = programs[programs.length - 1];
                    programs.pop(); // Free WebGL resources

                    program.destroy();
                }
            }; // Exposed for resource monitoring & error feedback via renderer.info:


            this.programs = programs;
        }

        /**
         * @author fordacious / fordacious.github.io
         */
        function WebGLProperties() {
            var properties = new WeakMap();

            function get(object) {
                var map = properties.get(object);

                if (map === undefined) {
                    map = {};
                    properties.set(object, map);
                }

                return map;
            }

            function remove(object) {
                properties.delete(object);
            }

            function update(object, key, value) {
                properties.get(object)[key] = value;
            }

            function dispose() {
                properties = new WeakMap();
            }

            return {
                get: get,
                remove: remove,
                update: update,
                dispose: dispose
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function painterSortStable(a, b) {
            if (a.groupOrder !== b.groupOrder) {
                return a.groupOrder - b.groupOrder;
            } else if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.program !== b.program) {
                return a.program.id - b.program.id;
            } else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
            } else if (a.z !== b.z) {
                return a.z - b.z;
            } else {
                return a.id - b.id;
            }
        }

        function reversePainterSortStable(a, b) {
            if (a.groupOrder !== b.groupOrder) {
                return a.groupOrder - b.groupOrder;
            } else if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else {
                return a.id - b.id;
            }
        }

        function WebGLRenderList() {
            var renderItems = [];
            var renderItemsIndex = 0;
            var opaque = [];
            var transparent = [];
            var defaultProgram = {
                id: -1
            };

            function init() {
                renderItemsIndex = 0;
                opaque.length = 0;
                transparent.length = 0;
            }

            function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
                var renderItem = renderItems[renderItemsIndex];

                if (renderItem === undefined) {
                    renderItem = {
                        id: object.id,
                        object: object,
                        geometry: geometry,
                        material: material,
                        program: material.program || defaultProgram,
                        groupOrder: groupOrder,
                        renderOrder: object.renderOrder,
                        z: z,
                        group: group
                    };
                    renderItems[renderItemsIndex] = renderItem;
                } else {
                    renderItem.id = object.id;
                    renderItem.object = object;
                    renderItem.geometry = geometry;
                    renderItem.material = material;
                    renderItem.program = material.program || defaultProgram;
                    renderItem.groupOrder = groupOrder;
                    renderItem.renderOrder = object.renderOrder;
                    renderItem.z = z;
                    renderItem.group = group;
                }

                renderItemsIndex++;
                return renderItem;
            }

            function push(object, geometry, material, groupOrder, z, group) {
                var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                (material.transparent === true ? transparent : opaque).push(renderItem);
            }

            function unshift(object, geometry, material, groupOrder, z, group) {
                var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                (material.transparent === true ? transparent : opaque).unshift(renderItem);
            }

            function sort(customOpaqueSort, customTransparentSort) {
                if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
                if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
            }

            function finish() {
                // Clear references from inactive renderItems in the list
                for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
                    var renderItem = renderItems[i];
                    if (renderItem.id === null) break;
                    renderItem.id = null;
                    renderItem.object = null;
                    renderItem.geometry = null;
                    renderItem.material = null;
                    renderItem.program = null;
                    renderItem.group = null;
                }
            }

            return {
                opaque: opaque,
                transparent: transparent,
                init: init,
                push: push,
                unshift: unshift,
                finish: finish,
                sort: sort
            };
        }

        function WebGLRenderLists() {
            var lists = new WeakMap();

            function onSceneDispose(event) {
                var scene = event.target;
                scene.removeEventListener('dispose', onSceneDispose);
                lists.delete(scene);
            }

            function get(scene, camera) {
                var cameras = lists.get(scene);
                var list;

                if (cameras === undefined) {
                    list = new WebGLRenderList();
                    lists.set(scene, new WeakMap());
                    lists.get(scene).set(camera, list);
                    scene.addEventListener('dispose', onSceneDispose);
                } else {
                    list = cameras.get(camera);

                    if (list === undefined) {
                        list = new WebGLRenderList();
                        cameras.set(camera, list);
                    }
                }

                return list;
            }

            function dispose() {
                lists = new WeakMap();
            }

            return {
                get: get,
                dispose: dispose
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function UniformsCache() {
            var lights = {};
            return {
                get: function (light) {
                    if (lights[light.id] !== undefined) {
                        return lights[light.id];
                    }

                    var uniforms;

                    switch (light.type) {
                        case 'DirectionalLight':
                            uniforms = {
                                direction: new Vector3(),
                                color: new Color()
                            };
                            break;

                        case 'SpotLight':
                            uniforms = {
                                position: new Vector3(),
                                direction: new Vector3(),
                                color: new Color(),
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;

                        case 'PointLight':
                            uniforms = {
                                position: new Vector3(),
                                color: new Color(),
                                distance: 0,
                                decay: 0
                            };
                            break;

                        case 'HemisphereLight':
                            uniforms = {
                                direction: new Vector3(),
                                skyColor: new Color(),
                                groundColor: new Color()
                            };
                            break;

                        case 'RectAreaLight':
                            uniforms = {
                                color: new Color(),
                                position: new Vector3(),
                                halfWidth: new Vector3(),
                                halfHeight: new Vector3()
                            };
                            break;
                    }

                    lights[light.id] = uniforms;
                    return uniforms;
                }
            };
        }

        function ShadowUniformsCache() {
            var lights = {};
            return {
                get: function (light) {
                    if (lights[light.id] !== undefined) {
                        return lights[light.id];
                    }

                    var uniforms;

                    switch (light.type) {
                        case 'DirectionalLight':
                            uniforms = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2()
                            };
                            break;

                        case 'SpotLight':
                            uniforms = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2()
                            };
                            break;

                        case 'PointLight':
                            uniforms = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2(),
                                shadowCameraNear: 1,
                                shadowCameraFar: 1000
                            };
                            break;
                        // TODO (abelnation): set RectAreaLight shadow uniforms
                    }

                    lights[light.id] = uniforms;
                    return uniforms;
                }
            };
        }

        var nextVersion = 0;

        function shadowCastingLightsFirst(lightA, lightB) {
            return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
        }

        function WebGLLights() {
            var cache = new UniformsCache();
            var shadowCache = ShadowUniformsCache();
            var state = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };

            for (var i = 0; i < 9; i++) state.probe.push(new Vector3());

            var vector3 = new Vector3();
            var matrix4 = new Matrix4();
            var matrix42 = new Matrix4();

            function setup(lights, shadows, camera) {
                var r = 0,
                    g = 0,
                    b = 0;

                for (var i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

                var directionalLength = 0;
                var pointLength = 0;
                var spotLength = 0;
                var rectAreaLength = 0;
                var hemiLength = 0;
                var numDirectionalShadows = 0;
                var numPointShadows = 0;
                var numSpotShadows = 0;
                var viewMatrix = camera.matrixWorldInverse;
                lights.sort(shadowCastingLightsFirst);

                for (var i = 0, l = lights.length; i < l; i++) {
                    var light = lights[i];
                    var color = light.color;
                    var intensity = light.intensity;
                    var distance = light.distance;
                    var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

                    if (light.isAmbientLight) {
                        r += color.r * intensity;
                        g += color.g * intensity;
                        b += color.b * intensity;
                    } else if (light.isLightProbe) {
                        for (var j = 0; j < 9; j++) {
                            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                        }
                    } else if (light.isDirectionalLight) {
                        var uniforms = cache.get(light);
                        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        vector3.setFromMatrixPosition(light.target.matrixWorld);
                        uniforms.direction.sub(vector3);
                        uniforms.direction.transformDirection(viewMatrix);

                        if (light.castShadow) {
                            var shadow = light.shadow;
                            var shadowUniforms = shadowCache.get(light);
                            shadowUniforms.shadowBias = shadow.bias;
                            shadowUniforms.shadowRadius = shadow.radius;
                            shadowUniforms.shadowMapSize = shadow.mapSize;
                            state.directionalShadow[directionalLength] = shadowUniforms;
                            state.directionalShadowMap[directionalLength] = shadowMap;
                            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                            numDirectionalShadows++;
                        }

                        state.directional[directionalLength] = uniforms;
                        directionalLength++;
                    } else if (light.isSpotLight) {
                        var uniforms = cache.get(light);
                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix);
                        uniforms.color.copy(color).multiplyScalar(intensity);
                        uniforms.distance = distance;
                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        vector3.setFromMatrixPosition(light.target.matrixWorld);
                        uniforms.direction.sub(vector3);
                        uniforms.direction.transformDirection(viewMatrix);
                        uniforms.coneCos = Math.cos(light.angle);
                        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                        uniforms.decay = light.decay;

                        if (light.castShadow) {
                            var shadow = light.shadow;
                            var shadowUniforms = shadowCache.get(light);
                            shadowUniforms.shadowBias = shadow.bias;
                            shadowUniforms.shadowRadius = shadow.radius;
                            shadowUniforms.shadowMapSize = shadow.mapSize;
                            state.spotShadow[spotLength] = shadowUniforms;
                            state.spotShadowMap[spotLength] = shadowMap;
                            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                            numSpotShadows++;
                        }

                        state.spot[spotLength] = uniforms;
                        spotLength++;
                    } else if (light.isRectAreaLight) {
                        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted
                        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                        // (b) intensity is the brightness of the light

                        uniforms.color.copy(color).multiplyScalar(intensity);
                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

                        matrix42.identity();
                        matrix4.copy(light.matrixWorld);
                        matrix4.premultiply(viewMatrix);
                        matrix42.extractRotation(matrix4);
                        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                        uniforms.halfWidth.applyMatrix4(matrix42);
                        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
                        // uniforms.distance = distance;

                        state.rectArea[rectAreaLength] = uniforms;
                        rectAreaLength++;
                    } else if (light.isPointLight) {
                        var uniforms = cache.get(light);
                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix);
                        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                        uniforms.distance = light.distance;
                        uniforms.decay = light.decay;

                        if (light.castShadow) {
                            var shadow = light.shadow;
                            var shadowUniforms = shadowCache.get(light);
                            shadowUniforms.shadowBias = shadow.bias;
                            shadowUniforms.shadowRadius = shadow.radius;
                            shadowUniforms.shadowMapSize = shadow.mapSize;
                            shadowUniforms.shadowCameraNear = shadow.camera.near;
                            shadowUniforms.shadowCameraFar = shadow.camera.far;
                            state.pointShadow[pointLength] = shadowUniforms;
                            state.pointShadowMap[pointLength] = shadowMap;
                            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                            numPointShadows++;
                        }

                        state.point[pointLength] = uniforms;
                        pointLength++;
                    } else if (light.isHemisphereLight) {
                        var uniforms = cache.get(light);
                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        uniforms.direction.transformDirection(viewMatrix);
                        uniforms.direction.normalize();
                        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                        state.hemi[hemiLength] = uniforms;
                        hemiLength++;
                    }
                }

                state.ambient[0] = r;
                state.ambient[1] = g;
                state.ambient[2] = b;
                var hash = state.hash;

                if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
                    state.directional.length = directionalLength;
                    state.spot.length = spotLength;
                    state.rectArea.length = rectAreaLength;
                    state.point.length = pointLength;
                    state.hemi.length = hemiLength;
                    state.directionalShadow.length = numDirectionalShadows;
                    state.directionalShadowMap.length = numDirectionalShadows;
                    state.pointShadow.length = numPointShadows;
                    state.pointShadowMap.length = numPointShadows;
                    state.spotShadow.length = numSpotShadows;
                    state.spotShadowMap.length = numSpotShadows;
                    state.directionalShadowMatrix.length = numDirectionalShadows;
                    state.pointShadowMatrix.length = numPointShadows;
                    state.spotShadowMatrix.length = numSpotShadows;
                    hash.directionalLength = directionalLength;
                    hash.pointLength = pointLength;
                    hash.spotLength = spotLength;
                    hash.rectAreaLength = rectAreaLength;
                    hash.hemiLength = hemiLength;
                    hash.numDirectionalShadows = numDirectionalShadows;
                    hash.numPointShadows = numPointShadows;
                    hash.numSpotShadows = numSpotShadows;
                    state.version = nextVersion++;
                }
            }

            return {
                setup: setup,
                state: state
            };
        }

        /**
         * @author Mugen87 / https://github.com/Mugen87
         */

        function WebGLRenderState() {
            var lights = new WebGLLights();
            var lightsArray = [];
            var shadowsArray = [];

            function init() {
                lightsArray.length = 0;
                shadowsArray.length = 0;
            }

            function pushLight(light) {
                lightsArray.push(light);
            }

            function pushShadow(shadowLight) {
                shadowsArray.push(shadowLight);
            }

            function setupLights(camera) {
                lights.setup(lightsArray, shadowsArray, camera);
            }

            var state = {
                lightsArray: lightsArray,
                shadowsArray: shadowsArray,
                lights: lights
            };
            return {
                init: init,
                state: state,
                setupLights: setupLights,
                pushLight: pushLight,
                pushShadow: pushShadow
            };
        }

        function WebGLRenderStates() {
            var renderStates = new WeakMap();

            function onSceneDispose(event) {
                var scene = event.target;
                scene.removeEventListener('dispose', onSceneDispose);
                renderStates.delete(scene);
            }

            function get(scene, camera) {
                var renderState;

                if (renderStates.has(scene) === false) {
                    renderState = new WebGLRenderState();
                    renderStates.set(scene, new WeakMap());
                    renderStates.get(scene).set(camera, renderState);
                    scene.addEventListener('dispose', onSceneDispose);
                } else {
                    if (renderStates.get(scene).has(camera) === false) {
                        renderState = new WebGLRenderState();
                        renderStates.get(scene).set(camera, renderState);
                    } else {
                        renderState = renderStates.get(scene).get(camera);
                    }
                }

                return renderState;
            }

            function dispose() {
                renderStates = new WeakMap();
            }

            return {
                get: get,
                dispose: dispose
            };
        }

        /**
         * @author szimek / https://github.com/szimek/
         * @author alteredq / http://alteredqualia.com/
         * @author Marius Kintel / https://github.com/kintel
         */

        /*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

        function WebGLRenderTarget(width, height, options) {
            this.width = width;
            this.height = height;
            this.scissor = new Vector4(0, 0, width, height);
            this.scissorTest = false;
            this.viewport = new Vector4(0, 0, width, height);
            options = options || {};
            this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            this.texture.image = {};
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
            this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
            this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
            this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
        }

        WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            constructor: WebGLRenderTarget,
            isWebGLRenderTarget: true,
            setSize: function (width, height) {
                if (this.width !== width || this.height !== height) {
                    this.width = width;
                    this.height = height;
                    this.texture.image.width = width;
                    this.texture.image.height = height;
                    this.dispose();
                }

                this.viewport.set(0, 0, width, height);
                this.scissor.set(0, 0, width, height);
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (source) {
                this.width = source.width;
                this.height = source.height;
                this.viewport.copy(source.viewport);
                this.texture = source.texture.clone();
                this.depthBuffer = source.depthBuffer;
                this.stencilBuffer = source.stencilBuffer;
                this.depthTexture = source.depthTexture;
                return this;
            },
            dispose: function () {
                this.dispatchEvent({
                    type: 'dispose'
                });
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author bhouston / https://clara.io
         * @author WestLangley / http://github.com/WestLangley
         *
         * parameters = {
         *
         *  opacity: <float>,
         *
         *  map: new THREE.Texture( <Image> ),
         *
         *  alphaMap: new THREE.Texture( <Image> ),
         *
         *  displacementMap: new THREE.Texture( <Image> ),
         *  displacementScale: <float>,
         *  displacementBias: <float>,
         *
         *  wireframe: <boolean>,
         *  wireframeLinewidth: <float>
         * }
         */

        function MeshDepthMaterial(parameters) {
            Material.call(this);
            this.type = 'MeshDepthMaterial';
            this.depthPacking = BasicDepthPacking;
            this.skinning = false;
            this.morphTargets = false;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.setValues(parameters);
        }

        MeshDepthMaterial.prototype = Object.create(Material.prototype);
        MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
        MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

        MeshDepthMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.depthPacking = source.depthPacking;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
        };

        /**
         * @author WestLangley / http://github.com/WestLangley
         *
         * parameters = {
         *
         *  referencePosition: <float>,
         *  nearDistance: <float>,
         *  farDistance: <float>,
         *
         *  skinning: <bool>,
         *  morphTargets: <bool>,
         *
         *  map: new THREE.Texture( <Image> ),
         *
         *  alphaMap: new THREE.Texture( <Image> ),
         *
         *  displacementMap: new THREE.Texture( <Image> ),
         *  displacementScale: <float>,
         *  displacementBias: <float>
         *
         * }
         */

        function MeshDistanceMaterial(parameters) {
            Material.call(this);
            this.type = 'MeshDistanceMaterial';
            this.referencePosition = new Vector3();
            this.nearDistance = 1;
            this.farDistance = 1000;
            this.skinning = false;
            this.morphTargets = false;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.fog = false;
            this.setValues(parameters);
        }

        MeshDistanceMaterial.prototype = Object.create(Material.prototype);
        MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
        MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

        MeshDistanceMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.referencePosition.copy(source.referencePosition);
            this.nearDistance = source.nearDistance;
            this.farDistance = source.farDistance;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            return this;
        };

        var vsm_frag = /* glsl */
            `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

  float mean = 0.0;
  float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );

  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

    #ifdef HORIZONAL_PASS

      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

    #else

      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;

    #endif

  }

  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;

  float std_dev = sqrt( squared_mean - mean * mean );

  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`	;

        var vsm_vert = /* glsl */
            `

void main() {

	gl_Position = vec4( position, 1.0 );

}

`	;

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
            var _frustum = new Frustum(),
                _shadowMapSize = new Vector2(),
                _viewportSize = new Vector2(),
                _viewport = new Vector4(),
                _depthMaterials = [],
                _distanceMaterials = [],
                _materialCache = {};

            var shadowSide = {
                0: BackSide,
                1: FrontSide,
                2: DoubleSide
            };
            var shadowMaterialVertical = new ShaderMaterial({
                defines: {
                    SAMPLE_RATE: 2.0 / 8.0,
                    HALF_SAMPLE_RATE: 1.0 / 8.0
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Vector2()
                    },
                    radius: {
                        value: 4.0
                    }
                },
                vertexShader: vsm_vert,
                fragmentShader: vsm_frag
            });
            var shadowMaterialHorizonal = shadowMaterialVertical.clone();
            shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
            var fullScreenTri = new BufferGeometry();
            fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
            var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
            var scope = this;
            this.enabled = false;
            this.autoUpdate = true;
            this.needsUpdate = false;
            this.type = PCFShadowMap;

            this.render = function (lights, scene, camera) {
                if (scope.enabled === false) return;
                if (scope.autoUpdate === false && scope.needsUpdate === false) return;
                if (lights.length === 0) return;

                var currentRenderTarget = _renderer.getRenderTarget();

                var activeCubeFace = _renderer.getActiveCubeFace();

                var activeMipmapLevel = _renderer.getActiveMipmapLevel();

                var _state = _renderer.state; // Set GL state for depth map.

                _state.setBlending(NoBlending);

                _state.buffers.color.setClear(1, 1, 1, 1);

                _state.buffers.depth.setTest(true);

                _state.setScissorTest(false); // render depth map


                for (var i = 0, il = lights.length; i < il; i++) {
                    var light = lights[i];
                    var shadow = light.shadow;

                    if (shadow === undefined) {
                        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                        continue;
                    }

                    _shadowMapSize.copy(shadow.mapSize);

                    var shadowFrameExtents = shadow.getFrameExtents();

                    _shadowMapSize.multiply(shadowFrameExtents);

                    _viewportSize.copy(shadow.mapSize);

                    if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                        console.warn('THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing');

                        if (_shadowMapSize.x > maxTextureSize) {
                            _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                            shadow.mapSize.x = _viewportSize.x;
                        }

                        if (_shadowMapSize.y > maxTextureSize) {
                            _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                            shadow.mapSize.y = _viewportSize.y;
                        }
                    }

                    if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                        var pars = {
                            minFilter: LinearFilter,
                            magFilter: LinearFilter,
                            format: RGBAFormat
                        };
                        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                        shadow.map.texture.name = light.name + ".shadowMap";
                        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                        shadow.camera.updateProjectionMatrix();
                    }

                    if (shadow.map === null) {
                        var pars = {
                            minFilter: NearestFilter,
                            magFilter: NearestFilter,
                            format: RGBAFormat
                        };
                        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                        shadow.map.texture.name = light.name + ".shadowMap";
                        shadow.camera.updateProjectionMatrix();
                    }

                    _renderer.setRenderTarget(shadow.map);

                    _renderer.clear();

                    var viewportCount = shadow.getViewportCount();

                    for (var vp = 0; vp < viewportCount; vp++) {
                        var viewport = shadow.getViewport(vp);

                        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

                        _state.viewport(_viewport);

                        shadow.updateMatrices(light, vp);
                        _frustum = shadow.getFrustum();
                        renderObject(scene, camera, shadow.camera, light, this.type);
                    } // do blur pass for VSM


                    if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
                        VSMPass(shadow, camera);
                    }
                }

                scope.needsUpdate = false;

                _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
            };

            function VSMPass(shadow, camera) {
                var geometry = _objects.update(fullScreenMesh); // vertical pass


                shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
                shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
                shadowMaterialVertical.uniforms.radius.value = shadow.radius;

                _renderer.setRenderTarget(shadow.mapPass);

                _renderer.clear();

                _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizonal pass


                shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
                shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
                shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

                _renderer.setRenderTarget(shadow.map);

                _renderer.clear();

                _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
            }

            function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
                var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
                var material = _depthMaterials[index];

                if (material === undefined) {
                    material = new MeshDepthMaterial({
                        depthPacking: RGBADepthPacking,
                        morphTargets: useMorphing,
                        skinning: useSkinning
                    });
                    _depthMaterials[index] = material;
                }

                return material;
            }

            function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
                var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
                var material = _distanceMaterials[index];

                if (material === undefined) {
                    material = new MeshDistanceMaterial({
                        morphTargets: useMorphing,
                        skinning: useSkinning
                    });
                    _distanceMaterials[index] = material;
                }

                return material;
            }

            function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
                var geometry = object.geometry;
                var result = null;
                var getMaterialVariant = getDepthMaterialVariant;
                var customMaterial = object.customDepthMaterial;

                if (light.isPointLight === true) {
                    getMaterialVariant = getDistanceMaterialVariant;
                    customMaterial = object.customDistanceMaterial;
                }

                if (customMaterial === undefined) {
                    var useMorphing = false;

                    if (material.morphTargets === true) {
                        if (geometry.isBufferGeometry === true) {
                            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                        } else if (geometry.isGeometry === true) {
                            useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                        }
                    }

                    var useSkinning = false;

                    if (object.isSkinnedMesh === true) {
                        if (material.skinning === true) {
                            useSkinning = true;
                        } else {
                            console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                        }
                    }

                    var useInstancing = object.isInstancedMesh === true;
                    result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
                } else {
                    result = customMaterial;
                }

                if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                    // in this case we need a unique material instance reflecting the
                    // appropriate state
                    var keyA = result.uuid,
                        keyB = material.uuid;
                    var materialsForVariant = _materialCache[keyA];

                    if (materialsForVariant === undefined) {
                        materialsForVariant = {};
                        _materialCache[keyA] = materialsForVariant;
                    }

                    var cachedMaterial = materialsForVariant[keyB];

                    if (cachedMaterial === undefined) {
                        cachedMaterial = result.clone();
                        materialsForVariant[keyB] = cachedMaterial;
                    }

                    result = cachedMaterial;
                }

                result.visible = material.visible;
                result.wireframe = material.wireframe;

                if (type === VSMShadowMap) {
                    result.side = material.shadowSide !== null ? material.shadowSide : material.side;
                } else {
                    result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
                }

                result.clipShadows = material.clipShadows;
                result.clippingPlanes = material.clippingPlanes;
                result.clipIntersection = material.clipIntersection;
                result.wireframeLinewidth = material.wireframeLinewidth;
                result.linewidth = material.linewidth;

                if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
                    result.referencePosition.setFromMatrixPosition(light.matrixWorld);
                    result.nearDistance = shadowCameraNear;
                    result.farDistance = shadowCameraFar;
                }

                return result;
            }

            function renderObject(object, camera, shadowCamera, light, type) {
                if (object.visible === false) return;
                var visible = object.layers.test(camera.layers);

                if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                    if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

                        var geometry = _objects.update(object);

                        var material = object.material;

                        if (Array.isArray(material)) {
                            var groups = geometry.groups;

                            for (var k = 0, kl = groups.length; k < kl; k++) {
                                var group = groups[k];
                                var groupMaterial = material[group.materialIndex];

                                if (groupMaterial && groupMaterial.visible) {
                                    var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                }
                            }
                        } else if (material.visible) {
                            var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);

                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                        }
                    }
                }

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    renderObject(children[i], camera, shadowCamera, light, type);
                }
            }
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLState(gl, extensions, capabilities) {
            var isWebGL2 = capabilities.isWebGL2;

            function ColorBuffer() {
                var locked = false;
                var color = new Vector4();
                var currentColorMask = null;
                var currentColorClear = new Vector4(0, 0, 0, 0);
                return {
                    setMask: function (colorMask) {
                        if (currentColorMask !== colorMask && !locked) {
                            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                            currentColorMask = colorMask;
                        }
                    },
                    setLocked: function (lock) {
                        locked = lock;
                    },
                    setClear: function (r, g, b, a, premultipliedAlpha) {
                        if (premultipliedAlpha === true) {
                            r *= a;
                            g *= a;
                            b *= a;
                        }

                        color.set(r, g, b, a);

                        if (currentColorClear.equals(color) === false) {
                            gl.clearColor(r, g, b, a);
                            currentColorClear.copy(color);
                        }
                    },
                    reset: function () {
                        locked = false;
                        currentColorMask = null;
                        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
                    }
                };
            }

            function DepthBuffer() {
                var locked = false;
                var currentDepthMask = null;
                var currentDepthFunc = null;
                var currentDepthClear = null;
                return {
                    setTest: function (depthTest) {
                        if (depthTest) {
                            enable(gl.DEPTH_TEST);
                        } else {
                            disable(gl.DEPTH_TEST);
                        }
                    },
                    setMask: function (depthMask) {
                        if (currentDepthMask !== depthMask && !locked) {
                            gl.depthMask(depthMask);
                            currentDepthMask = depthMask;
                        }
                    },
                    setFunc: function (depthFunc) {
                        if (currentDepthFunc !== depthFunc) {
                            if (depthFunc) {
                                switch (depthFunc) {
                                    case NeverDepth:
                                        gl.depthFunc(gl.NEVER);
                                        break;

                                    case AlwaysDepth:
                                        gl.depthFunc(gl.ALWAYS);
                                        break;

                                    case LessDepth:
                                        gl.depthFunc(gl.LESS);
                                        break;

                                    case LessEqualDepth:
                                        gl.depthFunc(gl.LEQUAL);
                                        break;

                                    case EqualDepth:
                                        gl.depthFunc(gl.EQUAL);
                                        break;

                                    case GreaterEqualDepth:
                                        gl.depthFunc(gl.GEQUAL);
                                        break;

                                    case GreaterDepth:
                                        gl.depthFunc(gl.GREATER);
                                        break;

                                    case NotEqualDepth:
                                        gl.depthFunc(gl.NOTEQUAL);
                                        break;

                                    default:
                                        gl.depthFunc(gl.LEQUAL);
                                }
                            } else {
                                gl.depthFunc(gl.LEQUAL);
                            }

                            currentDepthFunc = depthFunc;
                        }
                    },
                    setLocked: function (lock) {
                        locked = lock;
                    },
                    setClear: function (depth) {
                        if (currentDepthClear !== depth) {
                            gl.clearDepth(depth);
                            currentDepthClear = depth;
                        }
                    },
                    reset: function () {
                        locked = false;
                        currentDepthMask = null;
                        currentDepthFunc = null;
                        currentDepthClear = null;
                    }
                };
            }

            function StencilBuffer() {
                var locked = false;
                var currentStencilMask = null;
                var currentStencilFunc = null;
                var currentStencilRef = null;
                var currentStencilFuncMask = null;
                var currentStencilFail = null;
                var currentStencilZFail = null;
                var currentStencilZPass = null;
                var currentStencilClear = null;
                return {
                    setTest: function (stencilTest) {
                        if (!locked) {
                            if (stencilTest) {
                                enable(gl.STENCIL_TEST);
                            } else {
                                disable(gl.STENCIL_TEST);
                            }
                        }
                    },
                    setMask: function (stencilMask) {
                        if (currentStencilMask !== stencilMask && !locked) {
                            gl.stencilMask(stencilMask);
                            currentStencilMask = stencilMask;
                        }
                    },
                    setFunc: function (stencilFunc, stencilRef, stencilMask) {
                        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                            currentStencilFunc = stencilFunc;
                            currentStencilRef = stencilRef;
                            currentStencilFuncMask = stencilMask;
                        }
                    },
                    setOp: function (stencilFail, stencilZFail, stencilZPass) {
                        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                            currentStencilFail = stencilFail;
                            currentStencilZFail = stencilZFail;
                            currentStencilZPass = stencilZPass;
                        }
                    },
                    setLocked: function (lock) {
                        locked = lock;
                    },
                    setClear: function (stencil) {
                        if (currentStencilClear !== stencil) {
                            gl.clearStencil(stencil);
                            currentStencilClear = stencil;
                        }
                    },
                    reset: function () {
                        locked = false;
                        currentStencilMask = null;
                        currentStencilFunc = null;
                        currentStencilRef = null;
                        currentStencilFuncMask = null;
                        currentStencilFail = null;
                        currentStencilZFail = null;
                        currentStencilZPass = null;
                        currentStencilClear = null;
                    }
                };
            } //


            var colorBuffer = new ColorBuffer();
            var depthBuffer = new DepthBuffer();
            var stencilBuffer = new StencilBuffer();
            var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var newAttributes = new Uint8Array(maxVertexAttributes);
            var enabledAttributes = new Uint8Array(maxVertexAttributes);
            var attributeDivisors = new Uint8Array(maxVertexAttributes);
            var enabledCapabilities = {};
            var currentProgram = null;
            var currentBlendingEnabled = null;
            var currentBlending = null;
            var currentBlendEquation = null;
            var currentBlendSrc = null;
            var currentBlendDst = null;
            var currentBlendEquationAlpha = null;
            var currentBlendSrcAlpha = null;
            var currentBlendDstAlpha = null;
            var currentPremultipledAlpha = false;
            var currentFlipSided = null;
            var currentCullFace = null;
            var currentLineWidth = null;
            var currentPolygonOffsetFactor = null;
            var currentPolygonOffsetUnits = null;
            var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            var lineWidthAvailable = false;
            var version = 0;
            var glVersion = gl.getParameter(gl.VERSION);

            if (glVersion.indexOf('WebGL') !== -1) {
                version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
                lineWidthAvailable = version >= 1.0;
            } else if (glVersion.indexOf('OpenGL ES') !== -1) {
                version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
                lineWidthAvailable = version >= 2.0;
            }

            var currentTextureSlot = null;
            var currentBoundTextures = {};
            var currentScissor = new Vector4();
            var currentViewport = new Vector4();

            function createTexture(type, target, count) {
                var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

                var texture = gl.createTexture();
                gl.bindTexture(type, texture);
                gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                for (var i = 0; i < count; i++) {
                    gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                }

                return texture;
            }

            var emptyTextures = {};
            emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
            emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

            colorBuffer.setClear(0, 0, 0, 1);
            depthBuffer.setClear(1);
            stencilBuffer.setClear(0);
            enable(gl.DEPTH_TEST);
            depthBuffer.setFunc(LessEqualDepth);
            setFlipSided(false);
            setCullFace(CullFaceBack);
            enable(gl.CULL_FACE);
            setBlending(NoBlending); //

            function initAttributes() {
                for (var i = 0, l = newAttributes.length; i < l; i++) {
                    newAttributes[i] = 0;
                }
            }

            function enableAttribute(attribute) {
                enableAttributeAndDivisor(attribute, 0);
            }

            function enableAttributeAndDivisor(attribute, meshPerAttribute) {
                newAttributes[attribute] = 1;

                if (enabledAttributes[attribute] === 0) {
                    gl.enableVertexAttribArray(attribute);
                    enabledAttributes[attribute] = 1;
                }

                if (attributeDivisors[attribute] !== meshPerAttribute) {
                    var extension = isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
                    extension[isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
                    attributeDivisors[attribute] = meshPerAttribute;
                }
            }

            function disableUnusedAttributes() {
                for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                    if (enabledAttributes[i] !== newAttributes[i]) {
                        gl.disableVertexAttribArray(i);
                        enabledAttributes[i] = 0;
                    }
                }
            }

            function enable(id) {
                if (enabledCapabilities[id] !== true) {
                    gl.enable(id);
                    enabledCapabilities[id] = true;
                }
            }

            function disable(id) {
                if (enabledCapabilities[id] !== false) {
                    gl.disable(id);
                    enabledCapabilities[id] = false;
                }
            }

            function useProgram(program) {
                if (currentProgram !== program) {
                    gl.useProgram(program);
                    currentProgram = program;
                    return true;
                }

                return false;
            }

            var equationToGL = {
                [AddEquation]: gl.FUNC_ADD,
                [SubtractEquation]: gl.FUNC_SUBTRACT,
                [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
            };

            if (isWebGL2) {
                equationToGL[MinEquation] = gl.MIN;
                equationToGL[MaxEquation] = gl.MAX;
            } else {
                var extension = extensions.get('EXT_blend_minmax');

                if (extension !== null) {
                    equationToGL[MinEquation] = extension.MIN_EXT;
                    equationToGL[MaxEquation] = extension.MAX_EXT;
                }
            }

            var factorToGL = {
                [ZeroFactor]: gl.ZERO,
                [OneFactor]: gl.ONE,
                [SrcColorFactor]: gl.SRC_COLOR,
                [SrcAlphaFactor]: gl.SRC_ALPHA,
                [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
                [DstColorFactor]: gl.DST_COLOR,
                [DstAlphaFactor]: gl.DST_ALPHA,
                [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
                [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
                [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
                [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
            };

            function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
                if (blending === NoBlending) {
                    if (currentBlendingEnabled) {
                        disable(gl.BLEND);
                        currentBlendingEnabled = false;
                    }

                    return;
                }

                if (!currentBlendingEnabled) {
                    enable(gl.BLEND);
                    currentBlendingEnabled = true;
                }

                if (blending !== CustomBlending) {
                    if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                            gl.blendEquation(gl.FUNC_ADD);
                            currentBlendEquation = AddEquation;
                            currentBlendEquationAlpha = AddEquation;
                        }

                        if (premultipliedAlpha) {
                            switch (blending) {
                                case NormalBlending:
                                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                    break;

                                case AdditiveBlending:
                                    gl.blendFunc(gl.ONE, gl.ONE);
                                    break;

                                case SubtractiveBlending:
                                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                                    break;

                                case MultiplyBlending:
                                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                                    break;

                                default:
                                    console.error('THREE.WebGLState: Invalid blending: ', blending);
                                    break;
                            }
                        } else {
                            switch (blending) {
                                case NormalBlending:
                                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                    break;

                                case AdditiveBlending:
                                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                                    break;

                                case SubtractiveBlending:
                                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                                    break;

                                case MultiplyBlending:
                                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                                    break;

                                default:
                                    console.error('THREE.WebGLState: Invalid blending: ', blending);
                                    break;
                            }
                        }

                        currentBlendSrc = null;
                        currentBlendDst = null;
                        currentBlendSrcAlpha = null;
                        currentBlendDstAlpha = null;
                        currentBlending = blending;
                        currentPremultipledAlpha = premultipliedAlpha;
                    }

                    return;
                } // custom blending


                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;

                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                    currentBlendEquation = blendEquation;
                    currentBlendEquationAlpha = blendEquationAlpha;
                }

                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                    gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                    currentBlendSrc = blendSrc;
                    currentBlendDst = blendDst;
                    currentBlendSrcAlpha = blendSrcAlpha;
                    currentBlendDstAlpha = blendDstAlpha;
                }

                currentBlending = blending;
                currentPremultipledAlpha = null;
            }

            function setMaterial(material, frontFaceCW) {
                material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
                var flipSided = material.side === BackSide;
                if (frontFaceCW) flipSided = !flipSided;
                setFlipSided(flipSided);
                material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                depthBuffer.setFunc(material.depthFunc);
                depthBuffer.setTest(material.depthTest);
                depthBuffer.setMask(material.depthWrite);
                colorBuffer.setMask(material.colorWrite);
                var stencilWrite = material.stencilWrite;
                stencilBuffer.setTest(stencilWrite);

                if (stencilWrite) {
                    stencilBuffer.setMask(material.stencilWriteMask);
                    stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                    stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
                }

                setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
            } //


            function setFlipSided(flipSided) {
                if (currentFlipSided !== flipSided) {
                    if (flipSided) {
                        gl.frontFace(gl.CW);
                    } else {
                        gl.frontFace(gl.CCW);
                    }

                    currentFlipSided = flipSided;
                }
            }

            function setCullFace(cullFace) {
                if (cullFace !== CullFaceNone) {
                    enable(gl.CULL_FACE);

                    if (cullFace !== currentCullFace) {
                        if (cullFace === CullFaceBack) {
                            gl.cullFace(gl.BACK);
                        } else if (cullFace === CullFaceFront) {
                            gl.cullFace(gl.FRONT);
                        } else {
                            gl.cullFace(gl.FRONT_AND_BACK);
                        }
                    }
                } else {
                    disable(gl.CULL_FACE);
                }

                currentCullFace = cullFace;
            }

            function setLineWidth(width) {
                if (width !== currentLineWidth) {
                    if (lineWidthAvailable) gl.lineWidth(width);
                    currentLineWidth = width;
                }
            }

            function setPolygonOffset(polygonOffset, factor, units) {
                if (polygonOffset) {
                    enable(gl.POLYGON_OFFSET_FILL);

                    if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                        gl.polygonOffset(factor, units);
                        currentPolygonOffsetFactor = factor;
                        currentPolygonOffsetUnits = units;
                    }
                } else {
                    disable(gl.POLYGON_OFFSET_FILL);
                }
            }

            function setScissorTest(scissorTest) {
                if (scissorTest) {
                    enable(gl.SCISSOR_TEST);
                } else {
                    disable(gl.SCISSOR_TEST);
                }
            } // texture


            function activeTexture(webglSlot) {
                if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

                if (currentTextureSlot !== webglSlot) {
                    gl.activeTexture(webglSlot);
                    currentTextureSlot = webglSlot;
                }
            }

            function bindTexture(webglType, webglTexture) {
                if (currentTextureSlot === null) {
                    activeTexture();
                }

                var boundTexture = currentBoundTextures[currentTextureSlot];

                if (boundTexture === undefined) {
                    boundTexture = {
                        type: undefined,
                        texture: undefined
                    };
                    currentBoundTextures[currentTextureSlot] = boundTexture;
                }

                if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                    gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                    boundTexture.type = webglType;
                    boundTexture.texture = webglTexture;
                }
            }

            function unbindTexture() {
                var boundTexture = currentBoundTextures[currentTextureSlot];

                if (boundTexture !== undefined && boundTexture.type !== undefined) {
                    gl.bindTexture(boundTexture.type, null);
                    boundTexture.type = undefined;
                    boundTexture.texture = undefined;
                }
            }

            function compressedTexImage2D() {
                try {
                    gl.compressedTexImage2D.apply(gl, arguments);
                } catch (error) {
                    console.error('THREE.WebGLState:', error);
                }
            }

            function texImage2D() {
                try {
                    gl.texImage2D.apply(gl, arguments);
                } catch (error) {
                    console.error('THREE.WebGLState:', error);
                }
            }

            function texImage3D() {
                try {
                    gl.texImage3D.apply(gl, arguments);
                } catch (error) {
                    console.error('THREE.WebGLState:', error);
                }
            } //


            function scissor(scissor) {
                if (currentScissor.equals(scissor) === false) {
                    gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                    currentScissor.copy(scissor);
                }
            }

            function viewport(viewport) {
                if (currentViewport.equals(viewport) === false) {
                    gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                    currentViewport.copy(viewport);
                }
            } //


            function reset() {
                for (var i = 0; i < enabledAttributes.length; i++) {
                    if (enabledAttributes[i] === 1) {
                        gl.disableVertexAttribArray(i);
                        enabledAttributes[i] = 0;
                    }
                }

                enabledCapabilities = {};
                currentTextureSlot = null;
                currentBoundTextures = {};
                currentProgram = null;
                currentBlending = null;
                currentFlipSided = null;
                currentCullFace = null;
                colorBuffer.reset();
                depthBuffer.reset();
                stencilBuffer.reset();
            }

            return {
                buffers: {
                    color: colorBuffer,
                    depth: depthBuffer,
                    stencil: stencilBuffer
                },
                initAttributes: initAttributes,
                enableAttribute: enableAttribute,
                enableAttributeAndDivisor: enableAttributeAndDivisor,
                disableUnusedAttributes: disableUnusedAttributes,
                enable: enable,
                disable: disable,
                useProgram: useProgram,
                setBlending: setBlending,
                setMaterial: setMaterial,
                setFlipSided: setFlipSided,
                setCullFace: setCullFace,
                setLineWidth: setLineWidth,
                setPolygonOffset: setPolygonOffset,
                setScissorTest: setScissorTest,
                activeTexture: activeTexture,
                bindTexture: bindTexture,
                unbindTexture: unbindTexture,
                compressedTexImage2D: compressedTexImage2D,
                texImage2D: texImage2D,
                texImage3D: texImage3D,
                scissor: scissor,
                viewport: viewport,
                reset: reset
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
            var isWebGL2 = capabilities.isWebGL2;
            var maxTextures = capabilities.maxTextures;
            var maxCubemapSize = capabilities.maxCubemapSize;
            var maxTextureSize = capabilities.maxTextureSize;
            var maxSamples = capabilities.maxSamples;

            var _videoTextures = new WeakMap();

            var _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
            // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
            // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


            var useOffscreenCanvas = false;

            try {
                useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
            } catch (err) {// Ignore any errors
            }

            function createCanvas(width, height) {
                // Use OffscreenCanvas when available. Specially needed in web workers
                return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            }

            function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
                var scale = 1; // handle case if texture exceeds max size

                if (image.width > maxSize || image.height > maxSize) {
                    scale = maxSize / Math.max(image.width, image.height);
                } // only perform resize if necessary


                if (scale < 1 || needsPowerOfTwo === true) {
                    // only perform resize for certain image types
                    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                        var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                        var width = floor(scale * image.width);
                        var height = floor(scale * image.height);
                        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

                        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                        canvas.width = width;
                        canvas.height = height;
                        var context = canvas.getContext('2d');
                        context.drawImage(image, 0, 0, width, height);
                        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                        return canvas;
                    } else {
                        if ('data' in image) {
                            console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                        }

                        return image;
                    }
                }

                return image;
            }

            function isPowerOfTwo(image) {
                return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
            }

            function textureNeedsPowerOfTwo(texture) {
                if (isWebGL2) return false;
                return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
            }

            function textureNeedsGenerateMipmaps(texture, supportsMips) {
                return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
            }

            function generateMipmap(target, texture, width, height) {
                _gl.generateMipmap(target);

                var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

                textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
            }

            function getInternalFormat(internalFormatName, glFormat, glType) {
                if (isWebGL2 === false) return glFormat;

                if (internalFormatName !== null) {
                    if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
                    console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
                }

                var internalFormat = glFormat;

                if (glFormat === _gl.RED) {
                    if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
                    if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
                    if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
                }

                if (glFormat === _gl.RGB) {
                    if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
                    if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
                    if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
                }

                if (glFormat === _gl.RGBA) {
                    if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
                    if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
                    if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
                }

                if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
                    extensions.get('EXT_color_buffer_float');
                } else if (internalFormat === _gl.RGB16F || internalFormat === _gl.RGB32F) {
                    console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
                }

                return internalFormat;
            } // Fallback filters for non-power-of-2 textures


            function filterFallback(f) {
                if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
                    return _gl.NEAREST;
                }

                return _gl.LINEAR;
            } //


            function onTextureDispose(event) {
                var texture = event.target;
                texture.removeEventListener('dispose', onTextureDispose);
                deallocateTexture(texture);

                if (texture.isVideoTexture) {
                    _videoTextures.delete(texture);
                }

                info.memory.textures--;
            }

            function onRenderTargetDispose(event) {
                var renderTarget = event.target;
                renderTarget.removeEventListener('dispose', onRenderTargetDispose);
                deallocateRenderTarget(renderTarget);
                info.memory.textures--;
            } //


            function deallocateTexture(texture) {
                var textureProperties = properties.get(texture);
                if (textureProperties.__webglInit === undefined) return;

                _gl.deleteTexture(textureProperties.__webglTexture);

                properties.remove(texture);
            }

            function deallocateRenderTarget(renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                var textureProperties = properties.get(renderTarget.texture);
                if (!renderTarget) return;

                if (textureProperties.__webglTexture !== undefined) {
                    _gl.deleteTexture(textureProperties.__webglTexture);
                }

                if (renderTarget.depthTexture) {
                    renderTarget.depthTexture.dispose();
                }

                if (renderTarget.isWebGLCubeRenderTarget) {
                    for (var i = 0; i < 6; i++) {
                        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

                        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                    }
                } else {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

                    if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                }

                properties.remove(renderTarget.texture);
                properties.remove(renderTarget);
            } //


            var textureUnits = 0;

            function resetTextureUnits() {
                textureUnits = 0;
            }

            function allocateTextureUnit() {
                var textureUnit = textureUnits;

                if (textureUnit >= maxTextures) {
                    console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
                }

                textureUnits += 1;
                return textureUnit;
            } //


            function setTexture2D(texture, slot) {
                var textureProperties = properties.get(texture);
                if (texture.isVideoTexture) updateVideoTexture(texture);

                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    var image = texture.image;

                    if (image === undefined) {
                        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
                    } else if (image.complete === false) {
                        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                    } else {
                        uploadTexture(textureProperties, texture, slot);
                        return;
                    }
                }

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            }

            function setTexture2DArray(texture, slot) {
                var textureProperties = properties.get(texture);

                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
            }

            function setTexture3D(texture, slot) {
                var textureProperties = properties.get(texture);

                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
            }

            function setTextureCube(texture, slot) {
                if (texture.image.length !== 6) return;
                var textureProperties = properties.get(texture);

                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    initTexture(textureProperties, texture);
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

                    var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
                    var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                    var cubeImage = [];

                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
                        } else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }

                    var image = cubeImage[0],
                        supportsMips = isPowerOfTwo(image) || isWebGL2,
                        glFormat = utils.convert(texture.format),
                        glType = utils.convert(texture.type),
                        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
                    var mipmaps;

                    if (isCompressed) {
                        for (var i = 0; i < 6; i++) {
                            mipmaps = cubeImage[i].mipmaps;

                            for (var j = 0; j < mipmaps.length; j++) {
                                var mipmap = mipmaps[j];

                                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                    if (glFormat !== null) {
                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    } else {
                                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                    }
                                } else {
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }

                        textureProperties.__maxMipLevel = mipmaps.length - 1;
                    } else {
                        mipmaps = texture.mipmaps;

                        for (var i = 0; i < 6; i++) {
                            if (isDataTexture) {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

                                for (var j = 0; j < mipmaps.length; j++) {
                                    var mipmap = mipmaps[j];
                                    var mipmapImage = mipmap.image[i].image;
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                                }
                            } else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

                                for (var j = 0; j < mipmaps.length; j++) {
                                    var mipmap = mipmaps[j];
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                                }
                            }
                        }

                        textureProperties.__maxMipLevel = mipmaps.length;
                    }

                    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                        // We assume images for cube map have the same size.
                        generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
                    }

                    textureProperties.__version = texture.version;
                    if (texture.onUpdate) texture.onUpdate(texture);
                } else {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                }
            }

            function setTextureCubeDynamic(texture, slot) {
                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
            }

            var wrappingToGL = {
                [RepeatWrapping]: _gl.REPEAT,
                [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
                [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
            };
            var filterToGL = {
                [NearestFilter]: _gl.NEAREST,
                [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
                [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
                [LinearFilter]: _gl.LINEAR,
                [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
                [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
            };

            function setTextureParameters(textureType, texture, supportsMips) {
                if (supportsMips) {
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

                    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
                    }

                    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

                    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
                } else {
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

                    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
                    }

                    if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
                    }

                    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

                    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

                    if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
                    }
                }

                var extension = extensions.get('EXT_texture_filter_anisotropic');

                if (extension) {
                    if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
                    if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

                    if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

                        properties.get(texture).__currentAnisotropy = texture.anisotropy;
                    }
                }
            }

            function initTexture(textureProperties, texture) {
                if (textureProperties.__webglInit === undefined) {
                    textureProperties.__webglInit = true;
                    texture.addEventListener('dispose', onTextureDispose);
                    textureProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                }
            }

            function uploadTexture(textureProperties, texture, slot) {
                var textureType = _gl.TEXTURE_2D;
                if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
                if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
                initTexture(textureProperties, texture);
                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(textureType, textureProperties.__webglTexture);

                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

                _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

                var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
                var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
                var supportsMips = isPowerOfTwo(image) || isWebGL2,
                    glFormat = utils.convert(texture.format),
                    glType = utils.convert(texture.type),
                    glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
                setTextureParameters(textureType, texture, supportsMips);
                var mipmap,
                    mipmaps = texture.mipmaps;

                if (texture.isDepthTexture) {
                    // populate depth texture with dummy data
                    glInternalFormat = _gl.DEPTH_COMPONENT;

                    if (texture.type === FloatType) {
                        if (isWebGL2 === false) throw new Error('Float Depth Texture only supported in WebGL2.0');
                        glInternalFormat = _gl.DEPTH_COMPONENT32F;
                    } else if (isWebGL2) {
                        // WebGL 2.0 requires signed internalformat for glTexImage2D
                        glInternalFormat = _gl.DEPTH_COMPONENT16;
                    }

                    if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                            console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                            texture.type = UnsignedShortType;
                            glType = utils.convert(texture.type);
                        }
                    } // Depth stencil textures need the DEPTH_STENCIL internal format
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)


                    if (texture.format === DepthStencilFormat) {
                        glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

                        if (texture.type !== UnsignedInt248Type) {
                            console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                            texture.type = UnsignedInt248Type;
                            glType = utils.convert(texture.type);
                        }
                    }

                    state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
                } else if (texture.isDataTexture) {
                    // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels
                    if (mipmaps.length > 0 && supportsMips) {
                        for (var i = 0, il = mipmaps.length; i < il; i++) {
                            mipmap = mipmaps[i];
                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                        }

                        texture.generateMipmaps = false;
                        textureProperties.__maxMipLevel = mipmaps.length - 1;
                    } else {
                        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                        textureProperties.__maxMipLevel = 0;
                    }
                } else if (texture.isCompressedTexture) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];

                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (glFormat !== null) {
                                state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            } else {
                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                            }
                        } else {
                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                        }
                    }

                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                } else if (texture.isDataTexture2DArray) {
                    state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                } else if (texture.isDataTexture3D) {
                    state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                } else {
                    // regular Texture (image, video, canvas)
                    // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels
                    if (mipmaps.length > 0 && supportsMips) {
                        for (var i = 0, il = mipmaps.length; i < il; i++) {
                            mipmap = mipmaps[i];
                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
                        }

                        texture.generateMipmaps = false;
                        textureProperties.__maxMipLevel = mipmaps.length - 1;
                    } else {
                        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
                        textureProperties.__maxMipLevel = 0;
                    }
                }

                if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                    generateMipmap(textureType, texture, image.width, image.height);
                }

                textureProperties.__version = texture.version;
                if (texture.onUpdate) texture.onUpdate(texture);
            } // Render targets
            // Setup storage for target texture and bind it to correct framebuffer


            function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
                var glFormat = utils.convert(renderTarget.texture.format);
                var glType = utils.convert(renderTarget.texture.type);
                var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


            function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

                if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                    if (isMultisample) {
                        var samples = getRenderTargetSamples(renderTarget);

                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                    } else {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                    }

                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
                } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                    if (isMultisample) {
                        var samples = getRenderTargetSamples(renderTarget);

                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
                    } else {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                    }

                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
                } else {
                    var glFormat = utils.convert(renderTarget.texture.format);
                    var glType = utils.convert(renderTarget.texture.type);
                    var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

                    if (isMultisample) {
                        var samples = getRenderTargetSamples(renderTarget);

                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    } else {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
                    }
                }

                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            } // Setup resources for a Depth Texture for a FBO (needs an extension)


            function setupDepthTexture(framebuffer, renderTarget) {
                var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
                if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                    throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
                } // upload an empty depth texture with framebuffer size


                if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                    renderTarget.depthTexture.image.width = renderTarget.width;
                    renderTarget.depthTexture.image.height = renderTarget.height;
                    renderTarget.depthTexture.needsUpdate = true;
                }

                setTexture2D(renderTarget.depthTexture, 0);

                var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

                if (renderTarget.depthTexture.format === DepthFormat) {
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
                } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
                } else {
                    throw new Error('Unknown depthTexture format');
                }
            } // Setup GL resources for a non-texture depth buffer


            function setupDepthRenderbuffer(renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                var isCube = renderTarget.isWebGLCubeRenderTarget === true;

                if (renderTarget.depthTexture) {
                    if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
                    setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
                } else {
                    if (isCube) {
                        renderTargetProperties.__webglDepthbuffer = [];

                        for (var i = 0; i < 6; i++) {
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);

                            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                        }
                    } else {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

                        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                    }
                }

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            } // Set up GL resources for the render target


            function setupRenderTarget(renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                var textureProperties = properties.get(renderTarget.texture);
                renderTarget.addEventListener('dispose', onRenderTargetDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
                var isCube = renderTarget.isWebGLCubeRenderTarget === true;
                var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
                var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Setup framebuffer

                if (isCube) {
                    renderTargetProperties.__webglFramebuffer = [];

                    for (var i = 0; i < 6; i++) {
                        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                    }
                } else {
                    renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                    if (isMultisample) {
                        if (isWebGL2) {
                            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

                            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

                            var glFormat = utils.convert(renderTarget.texture.format);
                            var glType = utils.convert(renderTarget.texture.type);
                            var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                            var samples = getRenderTargetSamples(renderTarget);

                            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

                            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

                            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

                            if (renderTarget.depthBuffer) {
                                renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                                setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                            }

                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
                        } else {
                            console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
                        }
                    }
                } // Setup color buffer


                if (isCube) {
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);

                    for (var i = 0; i < 6; i++) {
                        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                    }

                    if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                        generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
                    }

                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
                } else {
                    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                    setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

                    if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
                        generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
                    }

                    state.bindTexture(_gl.TEXTURE_2D, null);
                } // Setup depth and stencil buffers


                if (renderTarget.depthBuffer) {
                    setupDepthRenderbuffer(renderTarget);
                }
            }

            function updateRenderTargetMipmap(renderTarget) {
                var texture = renderTarget.texture;
                var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

                if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                    var target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

                    var webglTexture = properties.get(texture).__webglTexture;

                    state.bindTexture(target, webglTexture);
                    generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                    state.bindTexture(target, null);
                }
            }

            function updateMultisampleRenderTarget(renderTarget) {
                if (renderTarget.isWebGLMultisampleRenderTarget) {
                    if (isWebGL2) {
                        var renderTargetProperties = properties.get(renderTarget);

                        _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

                        _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

                        var width = renderTarget.width;
                        var height = renderTarget.height;
                        var mask = _gl.COLOR_BUFFER_BIT;
                        if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
                        if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;

                        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
                    } else {
                        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
                    }
                }
            }

            function getRenderTargetSamples(renderTarget) {
                return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
            }

            function updateVideoTexture(texture) {
                var frame = info.render.frame; // Check the last frame we updated the VideoTexture

                if (_videoTextures.get(texture) !== frame) {
                    _videoTextures.set(texture, frame);

                    texture.update();
                }
            } // backwards compatibility


            var warnedTexture2D = false;
            var warnedTextureCube = false;

            function safeSetTexture2D(texture, slot) {
                if (texture && texture.isWebGLRenderTarget) {
                    if (warnedTexture2D === false) {
                        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warnedTexture2D = true;
                    }

                    texture = texture.texture;
                }

                setTexture2D(texture, slot);
            }

            function safeSetTextureCube(texture, slot) {
                if (texture && texture.isWebGLCubeRenderTarget) {
                    if (warnedTextureCube === false) {
                        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warnedTextureCube = true;
                    }

                    texture = texture.texture;
                } // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
                // TODO: unify these code paths


                if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
                    // CompressedTexture can have Array in image :/
                    // this function alone should take care of cube textures
                    setTextureCube(texture, slot);
                } else {
                    // assumed: texture property of THREE.WebGLCubeRenderTarget
                    setTextureCubeDynamic(texture, slot);
                }
            } //


            this.allocateTextureUnit = allocateTextureUnit;
            this.resetTextureUnits = resetTextureUnits;
            this.setTexture2D = setTexture2D;
            this.setTexture2DArray = setTexture2DArray;
            this.setTexture3D = setTexture3D;
            this.setTextureCube = setTextureCube;
            this.setTextureCubeDynamic = setTextureCubeDynamic;
            this.setupRenderTarget = setupRenderTarget;
            this.updateRenderTargetMipmap = updateRenderTargetMipmap;
            this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
            this.safeSetTexture2D = safeSetTexture2D;
            this.safeSetTextureCube = safeSetTextureCube;
        }

        /**
         * @author thespite / http://www.twitter.com/thespite
         */

        function WebGLUtils(gl, extensions, capabilities) {
            var isWebGL2 = capabilities.isWebGL2;

            function convert(p) {
                var extension;
                if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
                if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
                if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
                if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
                if (p === ByteType) return gl.BYTE;
                if (p === ShortType) return gl.SHORT;
                if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
                if (p === IntType) return gl.INT;
                if (p === UnsignedIntType) return gl.UNSIGNED_INT;
                if (p === FloatType) return gl.FLOAT;

                if (p === HalfFloatType) {
                    if (isWebGL2) return gl.HALF_FLOAT;
                    extension = extensions.get('OES_texture_half_float');

                    if (extension !== null) {
                        return extension.HALF_FLOAT_OES;
                    } else {
                        return null;
                    }
                }

                if (p === AlphaFormat) return gl.ALPHA;
                if (p === RGBFormat) return gl.RGB;
                if (p === RGBAFormat) return gl.RGBA;
                if (p === LuminanceFormat) return gl.LUMINANCE;
                if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
                if (p === DepthFormat) return gl.DEPTH_COMPONENT;
                if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
                if (p === RedFormat) return gl.RED; // WebGL2 formats.

                if (p === RedIntegerFormat) return gl.RED_INTEGER;
                if (p === RGFormat) return gl.RG;
                if (p === RGIntegerFormat) return gl.RG_INTEGER;
                if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
                if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

                if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_s3tc');

                    if (extension !== null) {
                        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    } else {
                        return null;
                    }
                }

                if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_pvrtc');

                    if (extension !== null) {
                        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    } else {
                        return null;
                    }
                }

                if (p === RGB_ETC1_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_etc1');

                    if (extension !== null) {
                        return extension.COMPRESSED_RGB_ETC1_WEBGL;
                    } else {
                        return null;
                    }
                }

                if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_etc');

                    if (extension !== null) {
                        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
                    }
                }

                if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_astc');

                    if (extension !== null) {
                        // TODO Complete?
                        return p;
                    } else {
                        return null;
                    }
                }

                if (p === UnsignedInt248Type) {
                    if (isWebGL2) return gl.UNSIGNED_INT_24_8;
                    extension = extensions.get('WEBGL_depth_texture');

                    if (extension !== null) {
                        return extension.UNSIGNED_INT_24_8_WEBGL;
                    } else {
                        return null;
                    }
                }
            }

            return {
                convert: convert
            };
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         * @author WestLangley / http://github.com/WestLangley
         */

        function Camera() {
            Object3D.call(this);
            this.type = 'Camera';
            this.matrixWorldInverse = new Matrix4();
            this.projectionMatrix = new Matrix4();
            this.projectionMatrixInverse = new Matrix4();
        }

        Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Camera,
            isCamera: true,
            copy: function (source, recursive) {
                Object3D.prototype.copy.call(this, source, recursive);
                this.matrixWorldInverse.copy(source.matrixWorldInverse);
                this.projectionMatrix.copy(source.projectionMatrix);
                this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
                return this;
            },
            getWorldDirection: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Camera: .getWorldDirection() target is now required');
                    target = new Vector3();
                }

                this.updateMatrixWorld(true);
                var e = this.matrixWorld.elements;
                return target.set(-e[8], -e[9], -e[10]).normalize();
            },
            updateMatrixWorld: function (force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                this.matrixWorldInverse.getInverse(this.matrixWorld);
            },
            updateWorldMatrix: function (updateParents, updateChildren) {
                Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
                this.matrixWorldInverse.getInverse(this.matrixWorld);
            },
            clone: function () {
                return new this.constructor().copy(this);
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author greggman / http://games.greggman.com/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author tschw
         */

        function PerspectiveCamera(fov, aspect, near, far) {
            Camera.call(this);
            this.type = 'PerspectiveCamera';
            this.fov = fov !== undefined ? fov : 50;
            this.zoom = 1;
            this.near = near !== undefined ? near : 0.1;
            this.far = far !== undefined ? far : 2000;
            this.focus = 10;
            this.aspect = aspect !== undefined ? aspect : 1;
            this.view = null;
            this.filmGauge = 35; // width of the film (default in millimeters)

            this.filmOffset = 0; // horizontal film offset (same unit as gauge)

            this.updateProjectionMatrix();
        }

        PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
            constructor: PerspectiveCamera,
            isPerspectiveCamera: true,
            copy: function (source, recursive) {
                Camera.prototype.copy.call(this, source, recursive);
                this.fov = source.fov;
                this.zoom = source.zoom;
                this.near = source.near;
                this.far = source.far;
                this.focus = source.focus;
                this.aspect = source.aspect;
                this.view = source.view === null ? null : Object.assign({}, source.view);
                this.filmGauge = source.filmGauge;
                this.filmOffset = source.filmOffset;
                return this;
            },

            /**
             * Sets the FOV by focal length in respect to the current .filmGauge.
             *
             * The default film gauge is 35, so that the focal length can be specified for
             * a 35mm (full frame) camera.
             *
             * Values for focal length and film gauge must have the same unit.
             */
            setFocalLength: function (focalLength) {
                // see http://www.bobatkins.com/photography/technical/field_of_view.html
                var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
                this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
                this.updateProjectionMatrix();
            },

            /**
             * Calculates the focal length from the current .fov and .filmGauge.
             */
            getFocalLength: function () {
                var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
                return 0.5 * this.getFilmHeight() / vExtentSlope;
            },
            getEffectiveFOV: function () {
                return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
            },
            getFilmWidth: function () {
                // film not completely covered in portrait format (aspect < 1)
                return this.filmGauge * Math.min(this.aspect, 1);
            },
            getFilmHeight: function () {
                // film not completely covered in landscape format (aspect > 1)
                return this.filmGauge / Math.max(this.aspect, 1);
            },

            /**
             * Sets an offset in a larger frustum. This is useful for multi-window or
             * multi-monitor/multi-machine setups.
             *
             * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
             * the monitors are in grid like this
             *
             *   +---+---+---+
             *   | A | B | C |
             *   +---+---+---+
             *   | D | E | F |
             *   +---+---+---+
             *
             * then for each monitor you would call it like this
             *
             *   var w = 1920;
             *   var h = 1080;
             *   var fullWidth = w * 3;
             *   var fullHeight = h * 2;
             *
             *   --A--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
             *   --B--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
             *   --C--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
             *   --D--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
             *   --E--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
             *   --F--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
             *
             *   Note there is no reason monitors have to be the same size or in a grid.
             */
            setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
                this.aspect = fullWidth / fullHeight;

                if (this.view === null) {
                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };
                }

                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;
                this.updateProjectionMatrix();
            },
            clearViewOffset: function () {
                if (this.view !== null) {
                    this.view.enabled = false;
                }

                this.updateProjectionMatrix();
            },
            updateProjectionMatrix: function () {
                var near = this.near,
                    top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom,
                    height = 2 * top,
                    width = this.aspect * height,
                    left = -0.5 * width,
                    view = this.view;

                if (this.view !== null && this.view.enabled) {
                    var fullWidth = view.fullWidth,
                        fullHeight = view.fullHeight;
                    left += view.offsetX * width / fullWidth;
                    top -= view.offsetY * height / fullHeight;
                    width *= view.width / fullWidth;
                    height *= view.height / fullHeight;
                }

                var skew = this.filmOffset;
                if (skew !== 0) left += near * skew / this.getFilmWidth();
                this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
                this.projectionMatrixInverse.getInverse(this.projectionMatrix);
            },
            toJSON: function (meta) {
                var data = Object3D.prototype.toJSON.call(this, meta);
                data.object.fov = this.fov;
                data.object.zoom = this.zoom;
                data.object.near = this.near;
                data.object.far = this.far;
                data.object.focus = this.focus;
                data.object.aspect = this.aspect;
                if (this.view !== null) data.object.view = Object.assign({}, this.view);
                data.object.filmGauge = this.filmGauge;
                data.object.filmOffset = this.filmOffset;
                return data;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function ArrayCamera(array) {
            PerspectiveCamera.call(this);
            this.cameras = array || [];
        }

        ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
            constructor: ArrayCamera,
            isArrayCamera: true
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Group() {
            Object3D.call(this);
            this.type = 'Group';
        }

        Group.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Group,
            isGroup: true
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebXRManager(renderer, gl) {
            var scope = this;
            var session = null;
            var framebufferScaleFactor = 1.0;
            var referenceSpace = null;
            var referenceSpaceType = 'local-floor';
            var pose = null;
            var controllers = [];
            var inputSourcesMap = new Map(); //

            var cameraL = new PerspectiveCamera();
            cameraL.layers.enable(1);
            cameraL.viewport = new Vector4();
            var cameraR = new PerspectiveCamera();
            cameraR.layers.enable(2);
            cameraR.viewport = new Vector4();
            var cameraVR = new ArrayCamera([cameraL, cameraR]);
            cameraVR.layers.enable(1);
            cameraVR.layers.enable(2);
            var _currentDepthNear = null;
            var _currentDepthFar = null; //

            this.enabled = false;
            this.isPresenting = false;

            this.getController = function (id) {
                var controller = controllers[id];

                if (controller === undefined) {
                    controller = {};
                    controllers[id] = controller;
                }

                if (controller.targetRay === undefined) {
                    controller.targetRay = new Group();
                    controller.targetRay.matrixAutoUpdate = false;
                    controller.targetRay.visible = false;
                }

                return controller.targetRay;
            };

            this.getControllerGrip = function (id) {
                var controller = controllers[id];

                if (controller === undefined) {
                    controller = {};
                    controllers[id] = controller;
                }

                if (controller.grip === undefined) {
                    controller.grip = new Group();
                    controller.grip.matrixAutoUpdate = false;
                    controller.grip.visible = false;
                }

                return controller.grip;
            }; //


            function onSessionEvent(event) {
                var controller = inputSourcesMap.get(event.inputSource);

                if (controller) {
                    if (controller.targetRay) {
                        controller.targetRay.dispatchEvent({
                            type: event.type
                        });
                    }

                    if (controller.grip) {
                        controller.grip.dispatchEvent({
                            type: event.type
                        });
                    }
                }
            }

            function onSessionEnd() {
                inputSourcesMap.forEach(function (controller, inputSource) {
                    if (controller.targetRay) {
                        controller.targetRay.dispatchEvent({
                            type: 'disconnected',
                            data: inputSource
                        });
                        controller.targetRay.visible = false;
                    }

                    if (controller.grip) {
                        controller.grip.dispatchEvent({
                            type: 'disconnected',
                            data: inputSource
                        });
                        controller.grip.visible = false;
                    }
                });
                inputSourcesMap.clear(); //

                renderer.setFramebuffer(null);
                renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

                animation.stop();
                scope.isPresenting = false;
                scope.dispatchEvent({
                    type: 'sessionend'
                });
            }

            function onRequestReferenceSpace(value) {
                referenceSpace = value;
                animation.setContext(session);
                animation.start();
                scope.isPresenting = true;
                scope.dispatchEvent({
                    type: 'sessionstart'
                });
            }

            this.setFramebufferScaleFactor = function (value) {
                framebufferScaleFactor = value; // Warn if function is used while presenting

                if (scope.isPresenting == true) {
                    console.warn("WebXRManager: Cannot change framebuffer scale while presenting VR content");
                }
            };

            this.setReferenceSpaceType = function (value) {
                referenceSpaceType = value;
            };

            this.getReferenceSpace = function () {
                return referenceSpace;
            };

            this.getSession = function () {
                return session;
            };

            this.setSession = function (value) {
                session = value;

                if (session !== null) {
                    session.addEventListener('select', onSessionEvent);
                    session.addEventListener('selectstart', onSessionEvent);
                    session.addEventListener('selectend', onSessionEvent);
                    session.addEventListener('squeeze', onSessionEvent);
                    session.addEventListener('squeezestart', onSessionEvent);
                    session.addEventListener('squeezeend', onSessionEvent);
                    session.addEventListener('end', onSessionEnd);
                    var attributes = gl.getContextAttributes();
                    var layerInit = {
                        antialias: attributes.antialias,
                        alpha: attributes.alpha,
                        depth: attributes.depth,
                        stencil: attributes.stencil,
                        framebufferScaleFactor: framebufferScaleFactor
                    }; // eslint-disable-next-line no-undef

                    var baseLayer = new XRWebGLLayer(session, gl, layerInit);
                    session.updateRenderState({
                        baseLayer: baseLayer
                    });
                    session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //

                    session.addEventListener('inputsourceschange', updateInputSources);
                }
            };

            function updateInputSources(event) {
                var inputSources = session.inputSources; // Assign inputSources to available controllers

                for (var i = 0; i < controllers.length; i++) {
                    inputSourcesMap.set(inputSources[i], controllers[i]);
                } // Notify disconnected


                for (var i = 0; i < event.removed.length; i++) {
                    var inputSource = event.removed[i];
                    var controller = inputSourcesMap.get(inputSource);

                    if (controller) {
                        if (controller.targetRay) {
                            controller.targetRay.dispatchEvent({
                                type: 'disconnected',
                                data: inputSource
                            });
                        }

                        if (controller.grip) {
                            controller.grip.dispatchEvent({
                                type: 'disconnected',
                                data: inputSource
                            });
                        }

                        inputSourcesMap.delete(inputSource);
                    }
                } // Notify connected


                for (var i = 0; i < event.added.length; i++) {
                    var inputSource = event.added[i];
                    var controller = inputSourcesMap.get(inputSource);

                    if (controller) {
                        if (controller.targetRay) {
                            controller.targetRay.dispatchEvent({
                                type: 'connected',
                                data: inputSource
                            });
                        }

                        if (controller.grip) {
                            controller.grip.dispatchEvent({
                                type: 'connected',
                                data: inputSource
                            });
                        }
                    }
                }
            } //


            var cameraLPos = new Vector3();
            var cameraRPos = new Vector3();
            /**
             * @author jsantell / https://www.jsantell.com/
             *
             * Assumes 2 cameras that are parallel and share an X-axis, and that
             * the cameras' projection and world matrices have already been set.
             * And that near and far planes are identical for both cameras.
             * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
             */

            function setProjectionFromUnion(camera, cameraL, cameraR) {
                cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
                cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
                var ipd = cameraLPos.distanceTo(cameraRPos);
                var projL = cameraL.projectionMatrix.elements;
                var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
                // most likely identical top and bottom frustum extents.
                // Use the left camera for these values.

                var near = projL[14] / (projL[10] - 1);
                var far = projL[14] / (projL[10] + 1);
                var topFov = (projL[9] + 1) / projL[5];
                var bottomFov = (projL[9] - 1) / projL[5];
                var leftFov = (projL[8] - 1) / projL[0];
                var rightFov = (projR[8] + 1) / projR[0];
                var left = near * leftFov;
                var right = near * rightFov; // Calculate the new camera's position offset from the
                // left camera. xOffset should be roughly half `ipd`.

                var zOffset = ipd / (-leftFov + rightFov);
                var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

                cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
                camera.translateX(xOffset);
                camera.translateZ(zOffset);
                camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
                camera.matrixWorldInverse.getInverse(camera.matrixWorld); // Find the union of the frustum values of the cameras and scale
                // the values so that the near plane's position does not change in world space,
                // although must now be relative to the new union camera.

                var near2 = near + zOffset;
                var far2 = far + zOffset;
                var left2 = left - xOffset;
                var right2 = right + (ipd - xOffset);
                var top2 = topFov * far / far2 * near2;
                var bottom2 = bottomFov * far / far2 * near2;
                camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
            }

            function updateCamera(camera, parent) {
                if (parent === null) {
                    camera.matrixWorld.copy(camera.matrix);
                } else {
                    camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
                }

                camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            }

            this.getCamera = function (camera) {
                cameraVR.near = cameraR.near = cameraL.near = camera.near;
                cameraVR.far = cameraR.far = cameraL.far = camera.far;

                if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                    // Note that the new renderState won't apply until the next frame. See #18320
                    session.updateRenderState({
                        depthNear: cameraVR.near,
                        depthFar: cameraVR.far
                    });
                    _currentDepthNear = cameraVR.near;
                    _currentDepthFar = cameraVR.far;
                }

                var parent = camera.parent;
                var cameras = cameraVR.cameras;
                updateCamera(cameraVR, parent);

                for (var i = 0; i < cameras.length; i++) {
                    updateCamera(cameras[i], parent);
                } // update camera and its children


                camera.matrixWorld.copy(cameraVR.matrixWorld);
                var children = camera.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    children[i].updateMatrixWorld(true);
                }

                setProjectionFromUnion(cameraVR, cameraL, cameraR);
                return cameraVR;
            }; // Animation Loop


            var onAnimationFrameCallback = null;

            function onAnimationFrame(time, frame) {
                pose = frame.getViewerPose(referenceSpace);

                if (pose !== null) {
                    var views = pose.views;
                    var baseLayer = session.renderState.baseLayer;
                    renderer.setFramebuffer(baseLayer.framebuffer);

                    for (var i = 0; i < views.length; i++) {
                        var view = views[i];
                        var viewport = baseLayer.getViewport(view);
                        var camera = cameraVR.cameras[i];
                        camera.matrix.fromArray(view.transform.matrix);
                        camera.projectionMatrix.fromArray(view.projectionMatrix);
                        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

                        if (i === 0) {
                            cameraVR.matrix.copy(camera.matrix);
                        }
                    }
                } //


                var inputSources = session.inputSources;

                for (var i = 0; i < controllers.length; i++) {
                    var controller = controllers[i];
                    var inputSource = inputSources[i];
                    var inputPose = null;
                    var gripPose = null;

                    if (inputSource) {
                        if (controller.targetRay) {
                            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

                            if (inputPose !== null) {
                                controller.targetRay.matrix.fromArray(inputPose.transform.matrix);
                                controller.targetRay.matrix.decompose(controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale);
                            }
                        }

                        if (controller.grip && inputSource.gripSpace) {
                            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

                            if (gripPose !== null) {
                                controller.grip.matrix.fromArray(gripPose.transform.matrix);
                                controller.grip.matrix.decompose(controller.grip.position, controller.grip.rotation, controller.grip.scale);
                            }
                        }
                    }

                    if (controller.targetRay) {
                        controller.targetRay.visible = inputPose !== null;
                    }

                    if (controller.grip) {
                        controller.grip.visible = gripPose !== null;
                    }
                }

                if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
            }

            var animation = new WebGLAnimation();
            animation.setAnimationLoop(onAnimationFrame);

            this.setAnimationLoop = function (callback) {
                onAnimationFrameCallback = callback;
            };

            this.dispose = function () {};
        }

        Object.assign(WebXRManager.prototype, EventDispatcher.prototype);

        /**
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author szimek / https://github.com/szimek/
         * @author tschw
         */

        function WebGLRenderer(parameters) {
            parameters = parameters || {};

            var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
                _context = parameters.context !== undefined ? parameters.context : null,
                _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
                _depth = parameters.depth !== undefined ? parameters.depth : true,
                _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
                _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
                _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
                _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
                _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
                _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

            var currentRenderList = null;
            var currentRenderState = null; // public properties

            this.domElement = _canvas; // Debug configuration container

            this.debug = {
                /**
                 * Enables error checking and reporting when shader programs are being compiled
                 * @type {boolean}
                 */
                checkShaderErrors: true
            }; // clearing

            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true; // scene graph

            this.sortObjects = true; // user-defined clipping

            this.clippingPlanes = [];
            this.localClippingEnabled = false; // physically based shading

            this.gammaFactor = 2.0; // for backwards compatibility

            this.outputEncoding = LinearEncoding; // physical lights

            this.physicallyCorrectLights = false; // tone mapping

            this.toneMapping = LinearToneMapping;
            this.toneMappingExposure = 1.0;
            this.toneMappingWhitePoint = 1.0; // morphs

            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4; // internal properties

            var _this = this,
                _isContextLost = false,
                // internal state cache
                _framebuffer = null,
                _currentActiveCubeFace = 0,
                _currentActiveMipmapLevel = 0,
                _currentRenderTarget = null,
                _currentFramebuffer = null,
                _currentMaterialId = -1,
                // geometry and program caching
                _currentGeometryProgram = {
                    geometry: null,
                    program: null,
                    wireframe: false
                },
                _currentCamera = null,
                _currentArrayCamera = null,
                _currentViewport = new Vector4(),
                _currentScissor = new Vector4(),
                _currentScissorTest = null,
                //
                _width = _canvas.width,
                _height = _canvas.height,
                _pixelRatio = 1,
                _opaqueSort = null,
                _transparentSort = null,
                _viewport = new Vector4(0, 0, _width, _height),
                _scissor = new Vector4(0, 0, _width, _height),
                _scissorTest = false,
                // frustum
                _frustum = new Frustum(),
                // clipping
                _clipping = new WebGLClipping(),
                _clippingEnabled = false,
                _localClippingEnabled = false,
                // camera matrices cache
                _projScreenMatrix = new Matrix4(),
                _vector3 = new Vector3();

            function getTargetPixelRatio() {
                return _currentRenderTarget === null ? _pixelRatio : 1;
            } // initialize


            var _gl;

            try {
                var contextAttributes = {
                    alpha: _alpha,
                    depth: _depth,
                    stencil: _stencil,
                    antialias: _antialias,
                    premultipliedAlpha: _premultipliedAlpha,
                    preserveDrawingBuffer: _preserveDrawingBuffer,
                    powerPreference: _powerPreference,
                    failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
                    xrCompatible: true
                }; // event listeners must be registered before WebGL context is created, see #12753

                _canvas.addEventListener('webglcontextlost', onContextLost, false);

                _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

                _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

                if (_gl === null) {
                    if (_canvas.getContext('webgl') !== null) {
                        throw new Error('Error creating WebGL context with your selected attributes.');
                    } else {
                        throw new Error('Error creating WebGL context.');
                    }
                } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


                if (_gl.getShaderPrecisionFormat === undefined) {
                    _gl.getShaderPrecisionFormat = function () {
                        return {
                            'rangeMin': 1,
                            'rangeMax': 1,
                            'precision': 1
                        };
                    };
                }
            } catch (error) {
                console.error('THREE.WebGLRenderer: ' + error.message);
                throw error;
            }

            var extensions, capabilities, state, info;
            var properties, textures, attributes, geometries, objects;
            var programCache, renderLists, renderStates;
            var background, morphtargets, bufferRenderer, indexedBufferRenderer;
            var utils;

            function initGLContext() {
                extensions = new WebGLExtensions(_gl);
                capabilities = new WebGLCapabilities(_gl, extensions, parameters);

                if (capabilities.isWebGL2 === false) {
                    extensions.get('WEBGL_depth_texture');
                    extensions.get('OES_texture_float');
                    extensions.get('OES_texture_half_float');
                    extensions.get('OES_texture_half_float_linear');
                    extensions.get('OES_standard_derivatives');
                    extensions.get('OES_element_index_uint');
                    extensions.get('ANGLE_instanced_arrays');
                }

                extensions.get('OES_texture_float_linear');
                utils = new WebGLUtils(_gl, extensions, capabilities);
                state = new WebGLState(_gl, extensions, capabilities);
                state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
                state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
                info = new WebGLInfo(_gl);
                properties = new WebGLProperties();
                textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
                attributes = new WebGLAttributes(_gl, capabilities);
                geometries = new WebGLGeometries(_gl, attributes, info);
                objects = new WebGLObjects(_gl, geometries, attributes, info);
                morphtargets = new WebGLMorphtargets(_gl);
                programCache = new WebGLPrograms(_this, extensions, capabilities);
                renderLists = new WebGLRenderLists();
                renderStates = new WebGLRenderStates();
                background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
                bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
                indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
                info.programs = programCache.programs;
                _this.capabilities = capabilities;
                _this.extensions = extensions;
                _this.properties = properties;
                _this.renderLists = renderLists;
                _this.state = state;
                _this.info = info;
            }

            initGLContext(); // xr

            var xr = new WebXRManager(_this, _gl);
            this.xr = xr; // shadow map

            var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
            this.shadowMap = shadowMap; // API

            this.getContext = function () {
                return _gl;
            };

            this.getContextAttributes = function () {
                return _gl.getContextAttributes();
            };

            this.forceContextLoss = function () {
                var extension = extensions.get('WEBGL_lose_context');
                if (extension) extension.loseContext();
            };

            this.forceContextRestore = function () {
                var extension = extensions.get('WEBGL_lose_context');
                if (extension) extension.restoreContext();
            };

            this.getPixelRatio = function () {
                return _pixelRatio;
            };

            this.setPixelRatio = function (value) {
                if (value === undefined) return;
                _pixelRatio = value;
                this.setSize(_width, _height, false);
            };

            this.getSize = function (target) {
                if (target === undefined) {
                    console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
                    target = new Vector2();
                }

                return target.set(_width, _height);
            };

            this.setSize = function (width, height, updateStyle) {
                if (xr.isPresenting) {
                    console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                    return;
                }

                _width = width;
                _height = height;
                _canvas.width = Math.floor(width * _pixelRatio);
                _canvas.height = Math.floor(height * _pixelRatio);

                if (updateStyle !== false) {
                    _canvas.style.width = width + 'px';
                    _canvas.style.height = height + 'px';
                }

                this.setViewport(0, 0, width, height);
            };

            this.getDrawingBufferSize = function (target) {
                if (target === undefined) {
                    console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
                    target = new Vector2();
                }

                return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
            };

            this.setDrawingBufferSize = function (width, height, pixelRatio) {
                _width = width;
                _height = height;
                _pixelRatio = pixelRatio;
                _canvas.width = Math.floor(width * pixelRatio);
                _canvas.height = Math.floor(height * pixelRatio);
                this.setViewport(0, 0, width, height);
            };

            this.getCurrentViewport = function (target) {
                if (target === undefined) {
                    console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
                    target = new Vector4();
                }

                return target.copy(_currentViewport);
            };

            this.getViewport = function (target) {
                return target.copy(_viewport);
            };

            this.setViewport = function (x, y, width, height) {
                if (x.isVector4) {
                    _viewport.set(x.x, x.y, x.z, x.w);
                } else {
                    _viewport.set(x, y, width, height);
                }

                state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
            };

            this.getScissor = function (target) {
                return target.copy(_scissor);
            };

            this.setScissor = function (x, y, width, height) {
                if (x.isVector4) {
                    _scissor.set(x.x, x.y, x.z, x.w);
                } else {
                    _scissor.set(x, y, width, height);
                }

                state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
            };

            this.getScissorTest = function () {
                return _scissorTest;
            };

            this.setScissorTest = function (boolean) {
                state.setScissorTest(_scissorTest = boolean);
            };

            this.setOpaqueSort = function (method) {
                _opaqueSort = method;
            };

            this.setTransparentSort = function (method) {
                _transparentSort = method;
            }; // Clearing


            this.getClearColor = function () {
                return background.getClearColor();
            };

            this.setClearColor = function () {
                background.setClearColor.apply(background, arguments);
            };

            this.getClearAlpha = function () {
                return background.getClearAlpha();
            };

            this.setClearAlpha = function () {
                background.setClearAlpha.apply(background, arguments);
            };

            this.clear = function (color, depth, stencil) {
                var bits = 0;
                if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
                if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
                if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

                _gl.clear(bits);
            };

            this.clearColor = function () {
                this.clear(true, false, false);
            };

            this.clearDepth = function () {
                this.clear(false, true, false);
            };

            this.clearStencil = function () {
                this.clear(false, false, true);
            }; //


            this.dispose = function () {
                _canvas.removeEventListener('webglcontextlost', onContextLost, false);

                _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

                renderLists.dispose();
                renderStates.dispose();
                properties.dispose();
                objects.dispose();
                xr.dispose();
                animation.stop();
            }; // Events


            function onContextLost(event) {
                event.preventDefault();
                console.log('THREE.WebGLRenderer: Context Lost.');
                _isContextLost = true;
            }

            function onContextRestore()
            /* event */
            {
                console.log('THREE.WebGLRenderer: Context Restored.');
                _isContextLost = false;
                initGLContext();
            }

            function onMaterialDispose(event) {
                var material = event.target;
                material.removeEventListener('dispose', onMaterialDispose);
                deallocateMaterial(material);
            } // Buffer deallocation


            function deallocateMaterial(material) {
                releaseMaterialProgramReference(material);
                properties.remove(material);
            }

            function releaseMaterialProgramReference(material) {
                var programInfo = properties.get(material).program;
                material.program = undefined;

                if (programInfo !== undefined) {
                    programCache.releaseProgram(programInfo);
                }
            } // Buffer rendering


            function renderObjectImmediate(object, program) {
                object.render(function (object) {
                    _this.renderBufferImmediate(object, program);
                });
            }

            this.renderBufferImmediate = function (object, program) {
                state.initAttributes();
                var buffers = properties.get(object);
                if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
                if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
                if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
                if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
                var programAttributes = program.getAttributes();

                if (object.hasPositions) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

                    _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.position);

                    _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
                }

                if (object.hasNormals) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

                    _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.normal);

                    _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
                }

                if (object.hasUvs) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

                    _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.uv);

                    _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
                }

                if (object.hasColors) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

                    _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.color);

                    _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
                }

                state.disableUnusedAttributes();

                _gl.drawArrays(_gl.TRIANGLES, 0, object.count);

                object.count = 0;
            };

            var tempScene = new Scene();

            this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
                if (scene === null) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)

                var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
                var program = setProgram(camera, scene, material, object);
                state.setMaterial(material, frontFaceCW);
                var updateBuffers = false;

                if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
                    _currentGeometryProgram.geometry = geometry.id;
                    _currentGeometryProgram.program = program.id;
                    _currentGeometryProgram.wireframe = material.wireframe === true;
                    updateBuffers = true;
                }

                if (material.morphTargets || material.morphNormals) {
                    morphtargets.update(object, geometry, material, program);
                    updateBuffers = true;
                } //


                var index = geometry.index;
                var position = geometry.attributes.position; //

                if (index === null) {
                    if (position === undefined || position.count === 0) return;
                } else if (index.count === 0) {
                    return;
                } //


                var rangeFactor = 1;

                if (material.wireframe === true) {
                    index = geometries.getWireframeAttribute(geometry);
                    rangeFactor = 2;
                }

                var attribute;
                var renderer = bufferRenderer;

                if (index !== null) {
                    attribute = attributes.get(index);
                    renderer = indexedBufferRenderer;
                    renderer.setIndex(attribute);
                }

                if (updateBuffers) {
                    setupVertexAttributes(object, geometry, material, program);

                    if (index !== null) {
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
                    }
                } //


                var dataCount = index !== null ? index.count : position.count;
                var rangeStart = geometry.drawRange.start * rangeFactor;
                var rangeCount = geometry.drawRange.count * rangeFactor;
                var groupStart = group !== null ? group.start * rangeFactor : 0;
                var groupCount = group !== null ? group.count * rangeFactor : Infinity;
                var drawStart = Math.max(rangeStart, groupStart);
                var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
                var drawCount = Math.max(0, drawEnd - drawStart + 1);
                if (drawCount === 0) return; //

                if (object.isMesh) {
                    if (material.wireframe === true) {
                        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                        renderer.setMode(_gl.LINES);
                    } else {
                        renderer.setMode(_gl.TRIANGLES);
                    }
                } else if (object.isLine) {
                    var lineWidth = material.linewidth;
                    if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

                    state.setLineWidth(lineWidth * getTargetPixelRatio());

                    if (object.isLineSegments) {
                        renderer.setMode(_gl.LINES);
                    } else if (object.isLineLoop) {
                        renderer.setMode(_gl.LINE_LOOP);
                    } else {
                        renderer.setMode(_gl.LINE_STRIP);
                    }
                } else if (object.isPoints) {
                    renderer.setMode(_gl.POINTS);
                } else if (object.isSprite) {
                    renderer.setMode(_gl.TRIANGLES);
                }

                if (object.isInstancedMesh) {
                    renderer.renderInstances(geometry, drawStart, drawCount, object.count);
                } else if (geometry.isInstancedBufferGeometry) {
                    renderer.renderInstances(geometry, drawStart, drawCount, geometry.maxInstancedCount);
                } else {
                    renderer.render(drawStart, drawCount);
                }
            };

            function setupVertexAttributes(object, geometry, material, program) {
                if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
                    if (extensions.get('ANGLE_instanced_arrays') === null) return;
                }

                state.initAttributes();
                var geometryAttributes = geometry.attributes;
                var programAttributes = program.getAttributes();
                var materialDefaultAttributeValues = material.defaultAttributeValues;

                for (var name in programAttributes) {
                    var programAttribute = programAttributes[name];

                    if (programAttribute >= 0) {
                        var geometryAttribute = geometryAttributes[name];

                        if (geometryAttribute !== undefined) {
                            var normalized = geometryAttribute.normalized;
                            var size = geometryAttribute.itemSize;
                            var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

                            if (attribute === undefined) continue;
                            var buffer = attribute.buffer;
                            var type = attribute.type;
                            var bytesPerElement = attribute.bytesPerElement;

                            if (geometryAttribute.isInterleavedBufferAttribute) {
                                var data = geometryAttribute.data;
                                var stride = data.stride;
                                var offset = geometryAttribute.offset;

                                if (data && data.isInstancedInterleavedBuffer) {
                                    state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                                    if (geometry.maxInstancedCount === undefined) {
                                        geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                    }
                                } else {
                                    state.enableAttribute(programAttribute);
                                }

                                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);

                                _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                            } else {
                                if (geometryAttribute.isInstancedBufferAttribute) {
                                    state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                                    if (geometry.maxInstancedCount === undefined) {
                                        geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                    }
                                } else {
                                    state.enableAttribute(programAttribute);
                                }

                                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);

                                _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                            }
                        } else if (name === 'instanceMatrix') {
                            var attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

                            if (attribute === undefined) continue;
                            var buffer = attribute.buffer;
                            var type = attribute.type;
                            state.enableAttributeAndDivisor(programAttribute + 0, 1);
                            state.enableAttributeAndDivisor(programAttribute + 1, 1);
                            state.enableAttributeAndDivisor(programAttribute + 2, 1);
                            state.enableAttributeAndDivisor(programAttribute + 3, 1);

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);

                            _gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);

                            _gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);

                            _gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);

                            _gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                        } else if (materialDefaultAttributeValues !== undefined) {
                            var value = materialDefaultAttributeValues[name];

                            if (value !== undefined) {
                                switch (value.length) {
                                    case 2:
                                        _gl.vertexAttrib2fv(programAttribute, value);

                                        break;

                                    case 3:
                                        _gl.vertexAttrib3fv(programAttribute, value);

                                        break;

                                    case 4:
                                        _gl.vertexAttrib4fv(programAttribute, value);

                                        break;

                                    default:
                                        _gl.vertexAttrib1fv(programAttribute, value);

                                }
                            }
                        }
                    }
                }

                state.disableUnusedAttributes();
            } // Compile


            this.compile = function (scene, camera) {
                currentRenderState = renderStates.get(scene, camera);
                currentRenderState.init();
                scene.traverse(function (object) {
                    if (object.isLight) {
                        currentRenderState.pushLight(object);

                        if (object.castShadow) {
                            currentRenderState.pushShadow(object);
                        }
                    }
                });
                currentRenderState.setupLights(camera);
                var compiled = {};
                scene.traverse(function (object) {
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            for (var i = 0; i < object.material.length; i++) {
                                if (object.material[i].uuid in compiled === false) {
                                    initMaterial(object.material[i], scene, object);
                                    compiled[object.material[i].uuid] = true;
                                }
                            }
                        } else if (object.material.uuid in compiled === false) {
                            initMaterial(object.material, scene, object);
                            compiled[object.material.uuid] = true;
                        }
                    }
                });
            }; // Animation Loop


            var onAnimationFrameCallback = null;

            function onAnimationFrame(time) {
                if (xr.isPresenting) return;
                if (onAnimationFrameCallback) onAnimationFrameCallback(time);
            }

            var animation = new WebGLAnimation();
            animation.setAnimationLoop(onAnimationFrame);
            if (typeof window !== 'undefined') animation.setContext(window);

            this.setAnimationLoop = function (callback) {
                onAnimationFrameCallback = callback;
                xr.setAnimationLoop(callback);
                animation.start();
            }; // Rendering


            this.render = function (scene, camera) {
                var renderTarget, forceClear;

                if (arguments[2] !== undefined) {
                    console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
                    renderTarget = arguments[2];
                }

                if (arguments[3] !== undefined) {
                    console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
                    forceClear = arguments[3];
                }

                if (!(camera && camera.isCamera)) {
                    console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                    return;
                }

                if (_isContextLost) return; // reset caching for this frame

                _currentGeometryProgram.geometry = null;
                _currentGeometryProgram.program = null;
                _currentGeometryProgram.wireframe = false;
                _currentMaterialId = -1;
                _currentCamera = null; // update scene graph

                if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

                if (camera.parent === null) camera.updateMatrixWorld();

                if (xr.enabled && xr.isPresenting) {
                    camera = xr.getCamera(camera);
                } //


                currentRenderState = renderStates.get(scene, camera);
                currentRenderState.init();
                scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

                _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

                _frustum.setFromProjectionMatrix(_projScreenMatrix);

                _localClippingEnabled = this.localClippingEnabled;
                _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
                currentRenderList = renderLists.get(scene, camera);
                currentRenderList.init();
                projectObject(scene, camera, 0, _this.sortObjects);
                currentRenderList.finish();

                if (_this.sortObjects === true) {
                    currentRenderList.sort(_opaqueSort, _transparentSort);
                } //


                if (_clippingEnabled) _clipping.beginShadows();
                var shadowsArray = currentRenderState.state.shadowsArray;
                shadowMap.render(shadowsArray, scene, camera);
                currentRenderState.setupLights(camera);
                if (_clippingEnabled) _clipping.endShadows(); //

                if (this.info.autoReset) this.info.reset();

                if (renderTarget !== undefined) {
                    this.setRenderTarget(renderTarget);
                } //


                background.render(currentRenderList, scene, camera, forceClear); // render scene

                var opaqueObjects = currentRenderList.opaque;
                var transparentObjects = currentRenderList.transparent;

                if (scene.overrideMaterial) {
                    var overrideMaterial = scene.overrideMaterial;
                    if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                    if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
                } else {
                    // opaque pass (front-to-back order)
                    if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera); // transparent pass (back-to-front order)

                    if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
                } //


                scene.onAfterRender(_this, scene, camera); //

                if (_currentRenderTarget !== null) {
                    // Generate mipmap if we're using any kind of mipmap filtering
                    textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

                    textures.updateMultisampleRenderTarget(_currentRenderTarget);
                } // Ensure depth buffer writing is enabled so it can be cleared on next render


                state.buffers.depth.setTest(true);
                state.buffers.depth.setMask(true);
                state.buffers.color.setMask(true);
                state.setPolygonOffset(false); // _gl.finish();

                currentRenderList = null;
                currentRenderState = null;
            };

            function projectObject(object, camera, groupOrder, sortObjects) {
                if (object.visible === false) return;
                var visible = object.layers.test(camera.layers);

                if (visible) {
                    if (object.isGroup) {
                        groupOrder = object.renderOrder;
                    } else if (object.isLOD) {
                        if (object.autoUpdate === true) object.update(camera);
                    } else if (object.isLight) {
                        currentRenderState.pushLight(object);

                        if (object.castShadow) {
                            currentRenderState.pushShadow(object);
                        }
                    } else if (object.isSprite) {
                        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                            if (sortObjects) {
                                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                            }

                            var geometry = objects.update(object);
                            var material = object.material;

                            if (material.visible) {
                                currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                            }
                        }
                    } else if (object.isImmediateRenderObject) {
                        if (sortObjects) {
                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        }

                        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
                    } else if (object.isMesh || object.isLine || object.isPoints) {
                        if (object.isSkinnedMesh) {
                            // update skeleton only once in a frame
                            if (object.skeleton.frame !== info.render.frame) {
                                object.skeleton.update();
                                object.skeleton.frame = info.render.frame;
                            }
                        }

                        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                            if (sortObjects) {
                                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                            }

                            var geometry = objects.update(object);
                            var material = object.material;

                            if (Array.isArray(material)) {
                                var groups = geometry.groups;

                                for (var i = 0, l = groups.length; i < l; i++) {
                                    var group = groups[i];
                                    var groupMaterial = material[group.materialIndex];

                                    if (groupMaterial && groupMaterial.visible) {
                                        currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                                    }
                                }
                            } else if (material.visible) {
                                currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                            }
                        }
                    }
                }

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    projectObject(children[i], camera, groupOrder, sortObjects);
                }
            }

            function renderObjects(renderList, scene, camera, overrideMaterial) {
                for (var i = 0, l = renderList.length; i < l; i++) {
                    var renderItem = renderList[i];
                    var object = renderItem.object;
                    var geometry = renderItem.geometry;
                    var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                    var group = renderItem.group;

                    if (camera.isArrayCamera) {
                        _currentArrayCamera = camera;
                        var cameras = camera.cameras;

                        for (var j = 0, jl = cameras.length; j < jl; j++) {
                            var camera2 = cameras[j];

                            if (object.layers.test(camera2.layers)) {
                                state.viewport(_currentViewport.copy(camera2.viewport));
                                currentRenderState.setupLights(camera2);
                                renderObject(object, scene, camera2, geometry, material, group);
                            }
                        }
                    } else {
                        _currentArrayCamera = null;
                        renderObject(object, scene, camera, geometry, material, group);
                    }
                }
            }

            function renderObject(object, scene, camera, geometry, material, group) {
                object.onBeforeRender(_this, scene, camera, geometry, material, group);
                currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

                if (object.isImmediateRenderObject) {
                    var program = setProgram(camera, scene, material, object);
                    state.setMaterial(material);
                    _currentGeometryProgram.geometry = null;
                    _currentGeometryProgram.program = null;
                    _currentGeometryProgram.wireframe = false;
                    renderObjectImmediate(object, program);
                } else {
                    _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                }

                object.onAfterRender(_this, scene, camera, geometry, material, group);
                currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
            }

            function initMaterial(material, scene, object) {
                var materialProperties = properties.get(material);
                var lights = currentRenderState.state.lights;
                var shadowsArray = currentRenderState.state.shadowsArray;
                var lightsStateVersion = lights.state.version;
                var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
                var programCacheKey = programCache.getProgramCacheKey(parameters);
                var program = materialProperties.program;
                var programChange = true;

                if (program === undefined) {
                    // new material
                    material.addEventListener('dispose', onMaterialDispose);
                } else if (program.cacheKey !== programCacheKey) {
                    // changed glsl or parameters
                    releaseMaterialProgramReference(material);
                } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
                    materialProperties.lightsStateVersion = lightsStateVersion;
                    programChange = false;
                } else if (parameters.shaderID !== undefined) {
                    // same glsl and uniform list
                    return;
                } else {
                    // only rebuild uniform list
                    programChange = false;
                }

                if (programChange) {
                    program = programCache.acquireProgram(parameters, programCacheKey);
                    materialProperties.program = program;
                    materialProperties.uniforms = parameters.uniforms;
                    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
                    materialProperties.outputEncoding = _this.outputEncoding;
                    material.program = program;
                }

                var programAttributes = program.getAttributes();

                if (material.morphTargets) {
                    material.numSupportedMorphTargets = 0;

                    for (var i = 0; i < _this.maxMorphTargets; i++) {
                        if (programAttributes['morphTarget' + i] >= 0) {
                            material.numSupportedMorphTargets++;
                        }
                    }
                }

                if (material.morphNormals) {
                    material.numSupportedMorphNormals = 0;

                    for (var i = 0; i < _this.maxMorphNormals; i++) {
                        if (programAttributes['morphNormal' + i] >= 0) {
                            material.numSupportedMorphNormals++;
                        }
                    }
                }

                var uniforms = materialProperties.uniforms;

                if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                    materialProperties.numClippingPlanes = _clipping.numPlanes;
                    materialProperties.numIntersection = _clipping.numIntersection;
                    uniforms.clippingPlanes = _clipping.uniform;
                }

                materialProperties.fog = scene.fog; // store the light setup it was created for

                materialProperties.needsLights = materialNeedsLights(material);
                materialProperties.lightsStateVersion = lightsStateVersion;

                if (materialProperties.needsLights) {
                    // wire up the material to this renderer's lighting state
                    uniforms.ambientLightColor.value = lights.state.ambient;
                    uniforms.lightProbe.value = lights.state.probe;
                    uniforms.directionalLights.value = lights.state.directional;
                    uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                    uniforms.spotLights.value = lights.state.spot;
                    uniforms.spotLightShadows.value = lights.state.spotShadow;
                    uniforms.rectAreaLights.value = lights.state.rectArea;
                    uniforms.pointLights.value = lights.state.point;
                    uniforms.pointLightShadows.value = lights.state.pointShadow;
                    uniforms.hemisphereLights.value = lights.state.hemi;
                    uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                    uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                    uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                    uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                    uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                    uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
                }

                var progUniforms = materialProperties.program.getUniforms(),
                    uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
                materialProperties.uniformsList = uniformsList;
            }

            function setProgram(camera, scene, material, object) {
                textures.resetTextureUnits();
                var fog = scene.fog;
                var environment = material.isMeshStandardMaterial ? scene.environment : null;
                var materialProperties = properties.get(material);
                var lights = currentRenderState.state.lights;

                if (_clippingEnabled) {
                    if (_localClippingEnabled || camera !== _currentCamera) {
                        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
                        // object instead of the material, once it becomes feasible
                        // (#8465, #8379)

                        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                    }
                }

                if (material.version === materialProperties.__version) {
                    if (materialProperties.program === undefined) {
                        initMaterial(material, scene, object);
                    } else if (material.fog && materialProperties.fog !== fog) {
                        initMaterial(material, scene, object);
                    } else if (materialProperties.environment !== environment) {
                        initMaterial(material, scene, object);
                    } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
                        initMaterial(material, scene, object);
                    } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                        initMaterial(material, scene, object);
                    } else if (materialProperties.outputEncoding !== _this.outputEncoding) {
                        initMaterial(material, scene, object);
                    }
                } else {
                    initMaterial(material, scene, object);
                    materialProperties.__version = material.version;
                }

                var refreshProgram = false;
                var refreshMaterial = false;
                var refreshLights = false;
                var program = materialProperties.program,
                    p_uniforms = program.getUniforms(),
                    m_uniforms = materialProperties.uniforms;

                if (state.useProgram(program.program)) {
                    refreshProgram = true;
                    refreshMaterial = true;
                    refreshLights = true;
                }

                if (material.id !== _currentMaterialId) {
                    _currentMaterialId = material.id;
                    refreshMaterial = true;
                }

                if (refreshProgram || _currentCamera !== camera) {
                    p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

                    if (capabilities.logarithmicDepthBuffer) {
                        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                    }

                    if (_currentCamera !== camera) {
                        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
                        // now, in case this material supports lights - or later, when
                        // the next material that does gets activated:

                        refreshMaterial = true; // set to true on material change

                        refreshLights = true; // remains set until update done
                    } // load material specific uniforms
                    // (shader material also gets them for the sake of genericity)


                    if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                        var uCamPos = p_uniforms.map.cameraPosition;

                        if (uCamPos !== undefined) {
                            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                        }
                    }

                    if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
                        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
                    }

                    if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                    }
                } // skinning uniforms must be set even if material didn't change
                // auto-setting of texture unit for bone texture must go before other textures
                // otherwise textures used for skinning can take over texture units reserved for other material textures


                if (material.skinning) {
                    p_uniforms.setOptional(_gl, object, 'bindMatrix');
                    p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                    var skeleton = object.skeleton;

                    if (skeleton) {
                        var bones = skeleton.bones;

                        if (capabilities.floatVertexTextures) {
                            if (skeleton.boneTexture === undefined) {
                                // layout (1 matrix = 4 pixels)
                                //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                                //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                                //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                                //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                                //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                                var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

                                size = MathUtils.ceilPowerOfTwo(size);
                                size = Math.max(size, 4);
                                var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

                                boneMatrices.set(skeleton.boneMatrices); // copy current values

                                var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                                skeleton.boneMatrices = boneMatrices;
                                skeleton.boneTexture = boneTexture;
                                skeleton.boneTextureSize = size;
                            }

                            p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                            p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                        } else {
                            p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                        }
                    }
                }

                if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                    materialProperties.receiveShadow = object.receiveShadow;
                    p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
                }

                if (refreshMaterial) {
                    p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                    p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

                    if (materialProperties.needsLights) {
                        // the current material requires lighting info
                        // note: all lighting uniforms are always set correctly
                        // they simply reference the renderer's state for their
                        // values
                        //
                        // use the current material's .needsUpdate flags to set
                        // the GL state when required
                        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                    } // refresh uniforms common to several materials


                    if (fog && material.fog) {
                        refreshUniformsFog(m_uniforms, fog);
                    }

                    if (material.isMeshBasicMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                    } else if (material.isMeshLambertMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsLambert(m_uniforms, material);
                    } else if (material.isMeshToonMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsToon(m_uniforms, material);
                    } else if (material.isMeshPhongMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsPhong(m_uniforms, material);
                    } else if (material.isMeshStandardMaterial) {
                        refreshUniformsCommon(m_uniforms, material, environment);

                        if (material.isMeshPhysicalMaterial) {
                            refreshUniformsPhysical(m_uniforms, material, environment);
                        } else {
                            refreshUniformsStandard(m_uniforms, material, environment);
                        }
                    } else if (material.isMeshMatcapMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsMatcap(m_uniforms, material);
                    } else if (material.isMeshDepthMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsDepth(m_uniforms, material);
                    } else if (material.isMeshDistanceMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsDistance(m_uniforms, material);
                    } else if (material.isMeshNormalMaterial) {
                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsNormal(m_uniforms, material);
                    } else if (material.isLineBasicMaterial) {
                        refreshUniformsLine(m_uniforms, material);

                        if (material.isLineDashedMaterial) {
                            refreshUniformsDash(m_uniforms, material);
                        }
                    } else if (material.isPointsMaterial) {
                        refreshUniformsPoints(m_uniforms, material);
                    } else if (material.isSpriteMaterial) {
                        refreshUniformsSprites(m_uniforms, material);
                    } else if (material.isShadowMaterial) {
                        m_uniforms.color.value.copy(material.color);
                        m_uniforms.opacity.value = material.opacity;
                    } // RectAreaLight Texture
                    // TODO (mrdoob): Find a nicer implementation


                    if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
                    if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
                    WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);

                    if (material.isShaderMaterial) {
                        material.uniformsNeedUpdate = false; // #15581
                    }
                }

                if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                    WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                    material.uniformsNeedUpdate = false;
                }

                if (material.isSpriteMaterial) {
                    p_uniforms.setValue(_gl, 'center', object.center);
                } // common matrices


                p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
                p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
                p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
                return program;
            } // Uniforms (refresh uniforms objects)


            function refreshUniformsCommon(uniforms, material, environment) {
                uniforms.opacity.value = material.opacity;

                if (material.color) {
                    uniforms.diffuse.value.copy(material.color);
                }

                if (material.emissive) {
                    uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
                }

                if (material.map) {
                    uniforms.map.value = material.map;
                }

                if (material.alphaMap) {
                    uniforms.alphaMap.value = material.alphaMap;
                }

                if (material.specularMap) {
                    uniforms.specularMap.value = material.specularMap;
                }

                var envMap = material.envMap || environment;

                if (envMap) {
                    uniforms.envMap.value = envMap;
                    uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
                    uniforms.reflectivity.value = material.reflectivity;
                    uniforms.refractionRatio.value = material.refractionRatio;
                    uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
                }

                if (material.lightMap) {
                    uniforms.lightMap.value = material.lightMap;
                    uniforms.lightMapIntensity.value = material.lightMapIntensity;
                }

                if (material.aoMap) {
                    uniforms.aoMap.value = material.aoMap;
                    uniforms.aoMapIntensity.value = material.aoMapIntensity;
                } // uv repeat and offset setting priorities
                // 1. color map
                // 2. specular map
                // 3. normal map
                // 4. bump map
                // 5. alpha map
                // 6. emissive map


                var uvScaleMap;

                if (material.map) {
                    uvScaleMap = material.map;
                } else if (material.specularMap) {
                    uvScaleMap = material.specularMap;
                } else if (material.displacementMap) {
                    uvScaleMap = material.displacementMap;
                } else if (material.normalMap) {
                    uvScaleMap = material.normalMap;
                } else if (material.bumpMap) {
                    uvScaleMap = material.bumpMap;
                } else if (material.roughnessMap) {
                    uvScaleMap = material.roughnessMap;
                } else if (material.metalnessMap) {
                    uvScaleMap = material.metalnessMap;
                } else if (material.alphaMap) {
                    uvScaleMap = material.alphaMap;
                } else if (material.emissiveMap) {
                    uvScaleMap = material.emissiveMap;
                }

                if (uvScaleMap !== undefined) {
                    // backwards compatibility
                    if (uvScaleMap.isWebGLRenderTarget) {
                        uvScaleMap = uvScaleMap.texture;
                    }

                    if (uvScaleMap.matrixAutoUpdate === true) {
                        uvScaleMap.updateMatrix();
                    }

                    uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                } // uv repeat and offset setting priorities for uv2
                // 1. ao map
                // 2. light map


                var uv2ScaleMap;

                if (material.aoMap) {
                    uv2ScaleMap = material.aoMap;
                } else if (material.lightMap) {
                    uv2ScaleMap = material.lightMap;
                }

                if (uv2ScaleMap !== undefined) {
                    // backwards compatibility
                    if (uv2ScaleMap.isWebGLRenderTarget) {
                        uv2ScaleMap = uv2ScaleMap.texture;
                    }

                    if (uv2ScaleMap.matrixAutoUpdate === true) {
                        uv2ScaleMap.updateMatrix();
                    }

                    uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
                }
            }

            function refreshUniformsLine(uniforms, material) {
                uniforms.diffuse.value.copy(material.color);
                uniforms.opacity.value = material.opacity;
            }

            function refreshUniformsDash(uniforms, material) {
                uniforms.dashSize.value = material.dashSize;
                uniforms.totalSize.value = material.dashSize + material.gapSize;
                uniforms.scale.value = material.scale;
            }

            function refreshUniformsPoints(uniforms, material) {
                uniforms.diffuse.value.copy(material.color);
                uniforms.opacity.value = material.opacity;
                uniforms.size.value = material.size * _pixelRatio;
                uniforms.scale.value = _height * 0.5;

                if (material.map) {
                    uniforms.map.value = material.map;
                }

                if (material.alphaMap) {
                    uniforms.alphaMap.value = material.alphaMap;
                } // uv repeat and offset setting priorities
                // 1. color map
                // 2. alpha map


                var uvScaleMap;

                if (material.map) {
                    uvScaleMap = material.map;
                } else if (material.alphaMap) {
                    uvScaleMap = material.alphaMap;
                }

                if (uvScaleMap !== undefined) {
                    if (uvScaleMap.matrixAutoUpdate === true) {
                        uvScaleMap.updateMatrix();
                    }

                    uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                }
            }

            function refreshUniformsSprites(uniforms, material) {
                uniforms.diffuse.value.copy(material.color);
                uniforms.opacity.value = material.opacity;
                uniforms.rotation.value = material.rotation;

                if (material.map) {
                    uniforms.map.value = material.map;
                }

                if (material.alphaMap) {
                    uniforms.alphaMap.value = material.alphaMap;
                } // uv repeat and offset setting priorities
                // 1. color map
                // 2. alpha map


                var uvScaleMap;

                if (material.map) {
                    uvScaleMap = material.map;
                } else if (material.alphaMap) {
                    uvScaleMap = material.alphaMap;
                }

                if (uvScaleMap !== undefined) {
                    if (uvScaleMap.matrixAutoUpdate === true) {
                        uvScaleMap.updateMatrix();
                    }

                    uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                }
            }

            function refreshUniformsFog(uniforms, fog) {
                uniforms.fogColor.value.copy(fog.color);

                if (fog.isFog) {
                    uniforms.fogNear.value = fog.near;
                    uniforms.fogFar.value = fog.far;
                } else if (fog.isFogExp2) {
                    uniforms.fogDensity.value = fog.density;
                }
            }

            function refreshUniformsLambert(uniforms, material) {
                if (material.emissiveMap) {
                    uniforms.emissiveMap.value = material.emissiveMap;
                }
            }

            function refreshUniformsPhong(uniforms, material) {
                uniforms.specular.value.copy(material.specular);
                uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

                if (material.emissiveMap) {
                    uniforms.emissiveMap.value = material.emissiveMap;
                }

                if (material.bumpMap) {
                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;
                    if (material.side === BackSide) uniforms.bumpScale.value *= -1;
                }

                if (material.normalMap) {
                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);
                    if (material.side === BackSide) uniforms.normalScale.value.negate();
                }

                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }
            }

            function refreshUniformsToon(uniforms, material) {
                uniforms.specular.value.copy(material.specular);
                uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

                if (material.gradientMap) {
                    uniforms.gradientMap.value = material.gradientMap;
                }

                if (material.emissiveMap) {
                    uniforms.emissiveMap.value = material.emissiveMap;
                }

                if (material.bumpMap) {
                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;
                    if (material.side === BackSide) uniforms.bumpScale.value *= -1;
                }

                if (material.normalMap) {
                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);
                    if (material.side === BackSide) uniforms.normalScale.value.negate();
                }

                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }
            }

            function refreshUniformsStandard(uniforms, material, environment) {
                uniforms.roughness.value = material.roughness;
                uniforms.metalness.value = material.metalness;

                if (material.roughnessMap) {
                    uniforms.roughnessMap.value = material.roughnessMap;
                }

                if (material.metalnessMap) {
                    uniforms.metalnessMap.value = material.metalnessMap;
                }

                if (material.emissiveMap) {
                    uniforms.emissiveMap.value = material.emissiveMap;
                }

                if (material.bumpMap) {
                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;
                    if (material.side === BackSide) uniforms.bumpScale.value *= -1;
                }

                if (material.normalMap) {
                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);
                    if (material.side === BackSide) uniforms.normalScale.value.negate();
                }

                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }

                if (material.envMap || environment) {
                    //uniforms.envMap.value = material.envMap; // part of uniforms common
                    uniforms.envMapIntensity.value = material.envMapIntensity;
                }
            }

            function refreshUniformsPhysical(uniforms, material, environment) {
                refreshUniformsStandard(uniforms, material, environment);
                uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

                uniforms.clearcoat.value = material.clearcoat;
                uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
                if (material.sheen) uniforms.sheen.value.copy(material.sheen);

                if (material.clearcoatNormalMap) {
                    uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                    uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

                    if (material.side === BackSide) {
                        uniforms.clearcoatNormalScale.value.negate();
                    }
                }

                uniforms.transparency.value = material.transparency;
            }

            function refreshUniformsMatcap(uniforms, material) {
                if (material.matcap) {
                    uniforms.matcap.value = material.matcap;
                }

                if (material.bumpMap) {
                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;
                    if (material.side === BackSide) uniforms.bumpScale.value *= -1;
                }

                if (material.normalMap) {
                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);
                    if (material.side === BackSide) uniforms.normalScale.value.negate();
                }

                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }
            }

            function refreshUniformsDepth(uniforms, material) {
                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }
            }

            function refreshUniformsDistance(uniforms, material) {
                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }

                uniforms.referencePosition.value.copy(material.referencePosition);
                uniforms.nearDistance.value = material.nearDistance;
                uniforms.farDistance.value = material.farDistance;
            }

            function refreshUniformsNormal(uniforms, material) {
                if (material.bumpMap) {
                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;
                    if (material.side === BackSide) uniforms.bumpScale.value *= -1;
                }

                if (material.normalMap) {
                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);
                    if (material.side === BackSide) uniforms.normalScale.value.negate();
                }

                if (material.displacementMap) {
                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;
                }
            } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


            function markUniformsLightsNeedsUpdate(uniforms, value) {
                uniforms.ambientLightColor.needsUpdate = value;
                uniforms.lightProbe.needsUpdate = value;
                uniforms.directionalLights.needsUpdate = value;
                uniforms.directionalLightShadows.needsUpdate = value;
                uniforms.pointLights.needsUpdate = value;
                uniforms.pointLightShadows.needsUpdate = value;
                uniforms.spotLights.needsUpdate = value;
                uniforms.spotLightShadows.needsUpdate = value;
                uniforms.rectAreaLights.needsUpdate = value;
                uniforms.hemisphereLights.needsUpdate = value;
            }

            function materialNeedsLights(material) {
                return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
            } //


            this.setFramebuffer = function (value) {
                if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);
                _framebuffer = value;
            };

            this.getActiveCubeFace = function () {
                return _currentActiveCubeFace;
            };

            this.getActiveMipmapLevel = function () {
                return _currentActiveMipmapLevel;
            };

            this.getRenderTarget = function () {
                return _currentRenderTarget;
            };

            this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
                _currentRenderTarget = renderTarget;
                _currentActiveCubeFace = activeCubeFace;
                _currentActiveMipmapLevel = activeMipmapLevel;

                if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                    textures.setupRenderTarget(renderTarget);
                }

                var framebuffer = _framebuffer;
                var isCube = false;

                if (renderTarget) {
                    var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

                    if (renderTarget.isWebGLCubeRenderTarget) {
                        framebuffer = __webglFramebuffer[activeCubeFace || 0];
                        isCube = true;
                    } else if (renderTarget.isWebGLMultisampleRenderTarget) {
                        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
                    } else {
                        framebuffer = __webglFramebuffer;
                    }

                    _currentViewport.copy(renderTarget.viewport);

                    _currentScissor.copy(renderTarget.scissor);

                    _currentScissorTest = renderTarget.scissorTest;
                } else {
                    _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

                    _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

                    _currentScissorTest = _scissorTest;
                }

                if (_currentFramebuffer !== framebuffer) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                    _currentFramebuffer = framebuffer;
                }

                state.viewport(_currentViewport);
                state.scissor(_currentScissor);
                state.setScissorTest(_currentScissorTest);

                if (isCube) {
                    var textureProperties = properties.get(renderTarget.texture);

                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
                }
            };

            this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                    return;
                }

                var framebuffer = properties.get(renderTarget).__webglFramebuffer;

                if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                    framebuffer = framebuffer[activeCubeFaceIndex];
                }

                if (framebuffer) {
                    var restore = false;

                    if (framebuffer !== _currentFramebuffer) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                        restore = true;
                    }

                    try {
                        var texture = renderTarget.texture;
                        var textureFormat = texture.format;
                        var textureType = texture.type;

                        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                            return;
                        }

                        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                            !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                            !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                            return;
                        }

                        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                            // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                            if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                                _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                            }
                        } else {
                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                        }
                    } finally {
                        if (restore) {
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                        }
                    }
                }
            };

            this.copyFramebufferToTexture = function (position, texture, level) {
                if (level === undefined) level = 0;
                var levelScale = Math.pow(2, -level);
                var width = Math.floor(texture.image.width * levelScale);
                var height = Math.floor(texture.image.height * levelScale);
                var glFormat = utils.convert(texture.format);
                textures.setTexture2D(texture, 0);

                _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

                state.unbindTexture();
            };

            this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
                var width = srcTexture.image.width;
                var height = srcTexture.image.height;
                var glFormat = utils.convert(dstTexture.format);
                var glType = utils.convert(dstTexture.type);
                textures.setTexture2D(dstTexture, 0);

                if (srcTexture.isDataTexture) {
                    _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
                } else {
                    _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
                }

                state.unbindTexture();
            };

            this.initTexture = function (texture) {
                textures.setTexture2D(texture, 0);
                state.unbindTexture();
            };

            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                    detail: this
                })); // eslint-disable-line no-undef

            }
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author benaadams / https://twitter.com/ben_a_adams
         * @author Mugen87 / https://github.com/Mugen87
         */

        function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            Geometry.call(this);
            this.type = 'SphereGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
            this.mergeVertices();
        }

        SphereGeometry.prototype = Object.create(Geometry.prototype);
        SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry

        function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            BufferGeometry.call(this);
            this.type = 'SphereBufferGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            radius = radius || 1;
            widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
            heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
            phiStart = phiStart !== undefined ? phiStart : 0;
            phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
            var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
            var ix, iy;
            var index = 0;
            var grid = [];
            var vertex = new Vector3();
            var normal = new Vector3(); // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // generate vertices, normals and uvs

            for (iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = [];
                var v = iy / heightSegments; // special case for the poles

                var uOffset = 0;

                if (iy == 0 && thetaStart == 0) {
                    uOffset = 0.5 / widthSegments;
                } else if (iy == heightSegments && thetaEnd == Math.PI) {
                    uOffset = -0.5 / widthSegments;
                }

                for (ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments; // vertex

                    vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vertex.x, vertex.y, vertex.z); // normal

                    normal.copy(vertex).normalize();
                    normals.push(normal.x, normal.y, normal.z); // uv

                    uvs.push(u + uOffset, 1 - v);
                    verticesRow.push(index++);
                }

                grid.push(verticesRow);
            } // indices


            for (iy = 0; iy < heightSegments; iy++) {
                for (ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
                }
            } // build geometry


            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }

        SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author arose / http://github.com/arose
         */

        function OrthographicCamera(left, right, top, bottom, near, far) {
            Camera.call(this);
            this.type = 'OrthographicCamera';
            this.zoom = 1;
            this.view = null;
            this.left = left !== undefined ? left : -1;
            this.right = right !== undefined ? right : 1;
            this.top = top !== undefined ? top : 1;
            this.bottom = bottom !== undefined ? bottom : -1;
            this.near = near !== undefined ? near : 0.1;
            this.far = far !== undefined ? far : 2000;
            this.updateProjectionMatrix();
        }

        OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
            constructor: OrthographicCamera,
            isOrthographicCamera: true,
            copy: function (source, recursive) {
                Camera.prototype.copy.call(this, source, recursive);
                this.left = source.left;
                this.right = source.right;
                this.top = source.top;
                this.bottom = source.bottom;
                this.near = source.near;
                this.far = source.far;
                this.zoom = source.zoom;
                this.view = source.view === null ? null : Object.assign({}, source.view);
                return this;
            },
            setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
                if (this.view === null) {
                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };
                }

                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;
                this.updateProjectionMatrix();
            },
            clearViewOffset: function () {
                if (this.view !== null) {
                    this.view.enabled = false;
                }

                this.updateProjectionMatrix();
            },
            updateProjectionMatrix: function () {
                var dx = (this.right - this.left) / (2 * this.zoom);
                var dy = (this.top - this.bottom) / (2 * this.zoom);
                var cx = (this.right + this.left) / 2;
                var cy = (this.top + this.bottom) / 2;
                var left = cx - dx;
                var right = cx + dx;
                var top = cy + dy;
                var bottom = cy - dy;

                if (this.view !== null && this.view.enabled) {
                    var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                    var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    left += scaleW * this.view.offsetX;
                    right = left + scaleW * this.view.width;
                    top -= scaleH * this.view.offsetY;
                    bottom = top - scaleH * this.view.height;
                }

                this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
                this.projectionMatrixInverse.getInverse(this.projectionMatrix);
            },
            toJSON: function (meta) {
                var data = Object3D.prototype.toJSON.call(this, meta);
                data.object.zoom = this.zoom;
                data.object.left = this.left;
                data.object.right = this.right;
                data.object.top = this.top;
                data.object.bottom = this.bottom;
                data.object.near = this.near;
                data.object.far = this.far;
                if (this.view !== null) data.object.view = Object.assign({}, this.view);
                return data;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author bhouston / http://clara.io/
         * @author stephomi / http://stephaneginier.com/
         */

        function Raycaster(origin, direction, near, far) {
            this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

            this.near = near || 0;
            this.far = far || Infinity;
            this.camera = null;
            this.layers = new Layers();
            this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            };
            Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {
                        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                        return this.Points;
                    }
                }
            });
        }

        function ascSort(a, b) {
            return a.distance - b.distance;
        }

        function intersectObject(object, raycaster, intersects, recursive) {
            if (object.layers.test(raycaster.layers)) {
                object.raycast(raycaster, intersects);
            }

            if (recursive === true) {
                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {
                    intersectObject(children[i], raycaster, intersects, true);
                }
            }
        }

        Object.assign(Raycaster.prototype, {
            set: function (origin, direction) {
                // direction is assumed to be normalized (for accurate distance calculations)
                this.ray.set(origin, direction);
            },
            setFromCamera: function (coords, camera) {
                if (camera && camera.isPerspectiveCamera) {
                    this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                    this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                    this.camera = camera;
                } else if (camera && camera.isOrthographicCamera) {
                    this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

                    this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                    this.camera = camera;
                } else {
                    console.error('THREE.Raycaster: Unsupported camera type.');
                }
            },
            intersectObject: function (object, recursive, optionalTarget) {
                var intersects = optionalTarget || [];
                intersectObject(object, this, intersects, recursive);
                intersects.sort(ascSort);
                return intersects;
            },
            intersectObjects: function (objects, recursive, optionalTarget) {
                var intersects = optionalTarget || [];

                if (Array.isArray(objects) === false) {
                    console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                    return intersects;
                }

                for (var i = 0, l = objects.length; i < l; i++) {
                    intersectObject(objects[i], this, intersects, recursive);
                }

                intersects.sort(ascSort);
                return intersects;
            }
        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InterleavedBuffer(array, stride) {
            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;
            this.usage = StaticDrawUsage;
            this.updateRange = {
                offset: 0,
                count: -1
            };
            this.version = 0;
        }

        Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
            set: function (value) {
                if (value === true) this.version++;
            }
        });
        Object.assign(InterleavedBuffer.prototype, {
            isInterleavedBuffer: true,
            onUploadCallback: function () {},
            setUsage: function (value) {
                this.usage = value;
                return this;
            },
            copy: function (source) {
                this.array = new source.array.constructor(source.array);
                this.count = source.count;
                this.stride = source.stride;
                this.usage = source.usage;
                return this;
            },
            copyAt: function (index1, attribute, index2) {
                index1 *= this.stride;
                index2 *= attribute.stride;

                for (var i = 0, l = this.stride; i < l; i++) {
                    this.array[index1 + i] = attribute.array[index2 + i];
                }

                return this;
            },
            set: function (value, offset) {
                if (offset === undefined) offset = 0;
                this.array.set(value, offset);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            onUpload: function (callback) {
                this.onUploadCallback = callback;
                return this;
            }
        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        var _vector$6 = new Vector3();

        function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized === true;
        }

        Object.defineProperties(InterleavedBufferAttribute.prototype, {
            count: {
                get: function () {
                    return this.data.count;
                }
            },
            array: {
                get: function () {
                    return this.data.array;
                }
            }
        });
        Object.assign(InterleavedBufferAttribute.prototype, {
            isInterleavedBufferAttribute: true,
            applyMatrix4: function (m) {
                for (var i = 0, l = this.data.count; i < l; i++) {
                    _vector$6.x = this.getX(i);
                    _vector$6.y = this.getY(i);
                    _vector$6.z = this.getZ(i);

                    _vector$6.applyMatrix4(m);

                    this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
                }

                return this;
            },
            setX: function (index, x) {
                this.data.array[index * this.data.stride + this.offset] = x;
                return this;
            },
            setY: function (index, y) {
                this.data.array[index * this.data.stride + this.offset + 1] = y;
                return this;
            },
            setZ: function (index, z) {
                this.data.array[index * this.data.stride + this.offset + 2] = z;
                return this;
            },
            setW: function (index, w) {
                this.data.array[index * this.data.stride + this.offset + 3] = w;
                return this;
            },
            getX: function (index) {
                return this.data.array[index * this.data.stride + this.offset];
            },
            getY: function (index) {
                return this.data.array[index * this.data.stride + this.offset + 1];
            },
            getZ: function (index) {
                return this.data.array[index * this.data.stride + this.offset + 2];
            },
            getW: function (index) {
                return this.data.array[index * this.data.stride + this.offset + 3];
            },
            setXY: function (index, x, y) {
                index = index * this.data.stride + this.offset;
                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;
                return this;
            },
            setXYZ: function (index, x, y, z) {
                index = index * this.data.stride + this.offset;
                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;
                this.data.array[index + 2] = z;
                return this;
            },
            setXYZW: function (index, x, y, z, w) {
                index = index * this.data.stride + this.offset;
                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;
                this.data.array[index + 2] = z;
                this.data.array[index + 3] = w;
                return this;
            }
        });

        /**
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
         *  color: <hex>,
         *  map: new THREE.Texture( <Image> ),
         *  alphaMap: new THREE.Texture( <Image> ),
         *  rotation: <float>,
         *  sizeAttenuation: <bool>
         * }
         */

        function SpriteMaterial(parameters) {
            Material.call(this);
            this.type = 'SpriteMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.alphaMap = null;
            this.rotation = 0;
            this.sizeAttenuation = true;
            this.transparent = true;
            this.setValues(parameters);
        }

        SpriteMaterial.prototype = Object.create(Material.prototype);
        SpriteMaterial.prototype.constructor = SpriteMaterial;
        SpriteMaterial.prototype.isSpriteMaterial = true;

        SpriteMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.rotation = source.rotation;
            this.sizeAttenuation = source.sizeAttenuation;
            return this;
        };

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         */

        var _geometry;

        var _intersectPoint = new Vector3();

        var _worldScale = new Vector3();

        var _mvPosition = new Vector3();

        var _alignedPosition = new Vector2();

        var _rotatedPosition = new Vector2();

        var _viewWorldMatrix = new Matrix4();

        var _vA$1 = new Vector3();

        var _vB$1 = new Vector3();

        var _vC$1 = new Vector3();

        var _uvA$1 = new Vector2();

        var _uvB$1 = new Vector2();

        var _uvC$1 = new Vector2();

        function Sprite(material) {
            Object3D.call(this);
            this.type = 'Sprite';

            if (_geometry === undefined) {
                _geometry = new BufferGeometry();
                var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
                var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

                _geometry.setIndex([0, 1, 2, 0, 2, 3]);

                _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

                _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
            }

            this.geometry = _geometry;
            this.material = material !== undefined ? material : new SpriteMaterial();
            this.center = new Vector2(0.5, 0.5);
        }

        Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Sprite,
            isSprite: true,
            raycast: function (raycaster, intersects) {
                if (raycaster.camera === null) {
                    console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
                }

                _worldScale.setFromMatrixScale(this.matrixWorld);

                _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

                this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

                _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

                if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
                    _worldScale.multiplyScalar(-_mvPosition.z);
                }

                var rotation = this.material.rotation;
                var sin, cos;

                if (rotation !== 0) {
                    cos = Math.cos(rotation);
                    sin = Math.sin(rotation);
                }

                var center = this.center;
                transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

                _uvA$1.set(0, 0);

                _uvB$1.set(1, 0);

                _uvC$1.set(1, 1); // check first triangle


                var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

                if (intersect === null) {
                    // check second triangle
                    transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

                    _uvB$1.set(0, 1);

                    intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

                    if (intersect === null) {
                        return;
                    }
                }

                var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
                if (distance < raycaster.near || distance > raycaster.far) return;
                intersects.push({
                    distance: distance,
                    point: _intersectPoint.clone(),
                    uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
                    face: null,
                    object: this
                });
            },
            clone: function () {
                return new this.constructor(this.material).copy(this);
            },
            copy: function (source) {
                Object3D.prototype.copy.call(this, source);
                if (source.center !== undefined) this.center.copy(source.center);
                return this;
            }
        });

        function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
            // compute position in camera space
            _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


            if (sin !== undefined) {
                _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
                _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
            } else {
                _rotatedPosition.copy(_alignedPosition);
            }

            vertexPosition.copy(mvPosition);
            vertexPosition.x += _rotatedPosition.x;
            vertexPosition.y += _rotatedPosition.y; // transform to world space

            vertexPosition.applyMatrix4(_viewWorldMatrix);
        }

        /**
         * @author alteredq / http://alteredqualia.com/
         */
        function Clock(autoStart) {
            this.autoStart = autoStart !== undefined ? autoStart : true;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }

        Object.assign(Clock.prototype, {
            start: function () {
                this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

                this.oldTime = this.startTime;
                this.elapsedTime = 0;
                this.running = true;
            },
            stop: function () {
                this.getElapsedTime();
                this.running = false;
                this.autoStart = false;
            },
            getElapsedTime: function () {
                this.getDelta();
                return this.elapsedTime;
            },
            getDelta: function () {
                var diff = 0;

                if (this.autoStart && !this.running) {
                    this.start();
                    return 0;
                }

                if (this.running) {
                    var newTime = (typeof performance === 'undefined' ? Date : performance).now();
                    diff = (newTime - this.oldTime) / 1000;
                    this.oldTime = newTime;
                    this.elapsedTime += diff;
                }

                return diff;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        var Cache = {
            enabled: false,
            files: {},
            add: function (key, file) {
                if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

                this.files[key] = file;
            },
            get: function (key) {
                if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

                return this.files[key];
            },
            remove: function (key) {
                delete this.files[key];
            },
            clear: function () {
                this.files = {};
            }
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */
        function LoadingManager(onLoad, onProgress, onError) {
            var scope = this;
            var isLoading = false;
            var itemsLoaded = 0;
            var itemsTotal = 0;
            var urlModifier = undefined;
            var handlers = []; // Refer to #5689 for the reason why we don't set .onStart
            // in the constructor

            this.onStart = undefined;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;

            this.itemStart = function (url) {
                itemsTotal++;

                if (isLoading === false) {
                    if (scope.onStart !== undefined) {
                        scope.onStart(url, itemsLoaded, itemsTotal);
                    }
                }

                isLoading = true;
            };

            this.itemEnd = function (url) {
                itemsLoaded++;

                if (scope.onProgress !== undefined) {
                    scope.onProgress(url, itemsLoaded, itemsTotal);
                }

                if (itemsLoaded === itemsTotal) {
                    isLoading = false;

                    if (scope.onLoad !== undefined) {
                        scope.onLoad();
                    }
                }
            };

            this.itemError = function (url) {
                if (scope.onError !== undefined) {
                    scope.onError(url);
                }
            };

            this.resolveURL = function (url) {
                if (urlModifier) {
                    return urlModifier(url);
                }

                return url;
            };

            this.setURLModifier = function (transform) {
                urlModifier = transform;
                return this;
            };

            this.addHandler = function (regex, loader) {
                handlers.push(regex, loader);
                return this;
            };

            this.removeHandler = function (regex) {
                var index = handlers.indexOf(regex);

                if (index !== -1) {
                    handlers.splice(index, 2);
                }

                return this;
            };

            this.getHandler = function (file) {
                for (var i = 0, l = handlers.length; i < l; i += 2) {
                    var regex = handlers[i];
                    var loader = handlers[i + 1];
                    if (regex.global) regex.lastIndex = 0; // see #17920

                    if (regex.test(file)) {
                        return loader;
                    }
                }

                return null;
            };
        }

        var DefaultLoadingManager = new LoadingManager();

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function Loader(manager) {
            this.manager = manager !== undefined ? manager : DefaultLoadingManager;
            this.crossOrigin = 'anonymous';
            this.path = '';
            this.resourcePath = '';
        }

        Object.assign(Loader.prototype, {
            load: function ()
                /* url, onLoad, onProgress, onError */
            {},
            parse: function ()
                /* data */
            {},
            setCrossOrigin: function (crossOrigin) {
                this.crossOrigin = crossOrigin;
                return this;
            },
            setPath: function (path) {
                this.path = path;
                return this;
            },
            setResourcePath: function (resourcePath) {
                this.resourcePath = resourcePath;
                return this;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function ImageLoader(manager) {
            Loader.call(this, manager);
        }

        ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
            constructor: ImageLoader,
            load: function (url, onLoad, onProgress, onError) {
                if (this.path !== undefined) url = this.path + url;
                url = this.manager.resolveURL(url);
                var scope = this;
                var cached = Cache.get(url);

                if (cached !== undefined) {
                    scope.manager.itemStart(url);
                    setTimeout(function () {
                        if (onLoad) onLoad(cached);
                        scope.manager.itemEnd(url);
                    }, 0);
                    return cached;
                }

                var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

                function onImageLoad() {
                    image.removeEventListener('load', onImageLoad, false);
                    image.removeEventListener('error', onImageError, false);
                    Cache.add(url, this);
                    if (onLoad) onLoad(this);
                    scope.manager.itemEnd(url);
                }

                function onImageError(event) {
                    image.removeEventListener('load', onImageLoad, false);
                    image.removeEventListener('error', onImageError, false);
                    if (onError) onError(event);
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }

                image.addEventListener('load', onImageLoad, false);
                image.addEventListener('error', onImageError, false);

                if (url.substr(0, 5) !== 'data:') {
                    if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
                }

                scope.manager.itemStart(url);
                image.src = url;
                return image;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function TextureLoader(manager) {
            Loader.call(this, manager);
        }

        TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
            constructor: TextureLoader,
            load: function (url, onLoad, onProgress, onError) {
                var texture = new Texture();
                var loader = new ImageLoader(this.manager);
                loader.setCrossOrigin(this.crossOrigin);
                loader.setPath(this.path);
                loader.load(url, function (image) {
                    texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

                    var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                    texture.format = isJPEG ? RGBFormat : RGBAFormat;
                    texture.needsUpdate = true;

                    if (onLoad !== undefined) {
                        onLoad(texture);
                    }
                }, onProgress, onError);
                return texture;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
         *  color: <hex>,
         *  opacity: <float>,
         *  map: new THREE.Texture( <Image> ),
         *  alphaMap: new THREE.Texture( <Image> ),
         *
         *  size: <float>,
         *  sizeAttenuation: <bool>
         *
         *  morphTargets: <bool>
         * }
         */

        function PointsMaterial(parameters) {
            Material.call(this);
            this.type = 'PointsMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.alphaMap = null;
            this.size = 1;
            this.sizeAttenuation = true;
            this.morphTargets = false;
            this.setValues(parameters);
        }

        PointsMaterial.prototype = Object.create(Material.prototype);
        PointsMaterial.prototype.constructor = PointsMaterial;
        PointsMaterial.prototype.isPointsMaterial = true;

        PointsMaterial.prototype.copy = function (source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;
            this.morphTargets = source.morphTargets;
            return this;
        };

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function Light(color, intensity) {
            Object3D.call(this);
            this.type = 'Light';
            this.color = new Color(color);
            this.intensity = intensity !== undefined ? intensity : 1;
            this.receiveShadow = undefined;
        }

        Light.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Light,
            isLight: true,
            copy: function (source) {
                Object3D.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.intensity = source.intensity;
                return this;
            },
            toJSON: function (meta) {
                var data = Object3D.prototype.toJSON.call(this, meta);
                data.object.color = this.color.getHex();
                data.object.intensity = this.intensity;
                if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
                if (this.distance !== undefined) data.object.distance = this.distance;
                if (this.angle !== undefined) data.object.angle = this.angle;
                if (this.decay !== undefined) data.object.decay = this.decay;
                if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
                if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
                return data;
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function LightShadow(camera) {
            this.camera = camera;
            this.bias = 0;
            this.radius = 1;
            this.mapSize = new Vector2(512, 512);
            this.map = null;
            this.mapPass = null;
            this.matrix = new Matrix4();
            this._frustum = new Frustum();
            this._frameExtents = new Vector2(1, 1);
            this._viewportCount = 1;
            this._viewports = [new Vector4(0, 0, 1, 1)];
        }

        Object.assign(LightShadow.prototype, {
            _projScreenMatrix: new Matrix4(),
            _lightPositionWorld: new Vector3(),
            _lookTarget: new Vector3(),
            getViewportCount: function () {
                return this._viewportCount;
            },
            getFrustum: function () {
                return this._frustum;
            },
            updateMatrices: function (light) {
                var shadowCamera = this.camera,
                    shadowMatrix = this.matrix,
                    projScreenMatrix = this._projScreenMatrix,
                    lookTarget = this._lookTarget,
                    lightPositionWorld = this._lightPositionWorld;
                lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(lightPositionWorld);
                lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                shadowCamera.lookAt(lookTarget);
                shadowCamera.updateMatrixWorld();
                projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

                this._frustum.setFromProjectionMatrix(projScreenMatrix);

                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                shadowMatrix.multiply(shadowCamera.projectionMatrix);
                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
            },
            getViewport: function (viewportIndex) {
                return this._viewports[viewportIndex];
            },
            getFrameExtents: function () {
                return this._frameExtents;
            },
            copy: function (source) {
                this.camera = source.camera.clone();
                this.bias = source.bias;
                this.radius = source.radius;
                this.mapSize.copy(source.mapSize);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            toJSON: function () {
                var object = {};
                if (this.bias !== 0) object.bias = this.bias;
                if (this.radius !== 1) object.radius = this.radius;
                if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
                object.camera = this.camera.toJSON(false).object;
                delete object.camera.matrix;
                return object;
            }
        });

        function PointLightShadow() {
            LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
            this._frameExtents = new Vector2(4, 2);
            this._viewportCount = 6;
            this._viewports = [// These viewports map a cube-map onto a 2D texture with the
                // following orientation:
                //
                //  xzXZ
                //   y Y
                //
                // X - Positive x direction
                // x - Negative x direction
                // Y - Positive y direction
                // y - Negative y direction
                // Z - Positive z direction
                // z - Negative z direction
                // positive X
                new Vector4(2, 1, 1, 1), // negative X
                new Vector4(0, 1, 1, 1), // positive Z
                new Vector4(3, 1, 1, 1), // negative Z
                new Vector4(1, 1, 1, 1), // positive Y
                new Vector4(3, 0, 1, 1), // negative Y
                new Vector4(1, 0, 1, 1)];
            this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
            this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
        }

        PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
            constructor: PointLightShadow,
            isPointLightShadow: true,
            updateMatrices: function (light, viewportIndex) {
                if (viewportIndex === undefined) viewportIndex = 0;
                var camera = this.camera,
                    shadowMatrix = this.matrix,
                    lightPositionWorld = this._lightPositionWorld,
                    lookTarget = this._lookTarget,
                    projScreenMatrix = this._projScreenMatrix;
                lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                camera.position.copy(lightPositionWorld);
                lookTarget.copy(camera.position);
                lookTarget.add(this._cubeDirections[viewportIndex]);
                camera.up.copy(this._cubeUps[viewportIndex]);
                camera.lookAt(lookTarget);
                camera.updateMatrixWorld();
                shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
                projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

                this._frustum.setFromProjectionMatrix(projScreenMatrix);
            }
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function PointLight(color, intensity, distance, decay) {
            Light.call(this, color, intensity);
            this.type = 'PointLight';
            Object.defineProperty(this, 'power', {
                get: function () {
                    // intensity = power per solid angle.
                    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                    return this.intensity * 4 * Math.PI;
                },
                set: function (power) {
                    // intensity = power per solid angle.
                    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                    this.intensity = power / (4 * Math.PI);
                }
            });
            this.distance = distance !== undefined ? distance : 0;
            this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

            this.shadow = new PointLightShadow();
        }

        PointLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: PointLight,
            isPointLight: true,
            copy: function (source) {
                Light.prototype.copy.call(this, source);
                this.distance = source.distance;
                this.decay = source.decay;
                this.shadow = source.shadow.clone();
                return this;
            }
        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        var _inverseMatrix$1 = new Matrix4();

        var _ray$1 = new Ray();

        var _sphere$2 = new Sphere();

        var _position$1 = new Vector3();

        function Points(geometry, material) {
            Object3D.call(this);
            this.type = 'Points';
            this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
            this.material = material !== undefined ? material : new PointsMaterial();
            this.updateMorphTargets();
        }

        Points.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Points,
            isPoints: true,
            raycast: function (raycaster, intersects) {
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                _sphere$2.copy(geometry.boundingSphere);

                _sphere$2.applyMatrix4(matrixWorld);

                _sphere$2.radius += threshold;
                if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

                _inverseMatrix$1.getInverse(matrixWorld);

                _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;

                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;

                    if (index !== null) {
                        var indices = index.array;

                        for (var i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];

                            _position$1.fromArray(positions, a * 3);

                            testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3; i < l; i++) {
                            _position$1.fromArray(positions, i * 3);

                            testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                        }
                    }
                } else {
                    var vertices = geometry.vertices;

                    for (var i = 0, l = vertices.length; i < l; i++) {
                        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                    }
                }
            },
            updateMorphTargets: function () {
                var geometry = this.geometry;
                var m, ml, name;

                if (geometry.isBufferGeometry) {
                    var morphAttributes = geometry.morphAttributes;
                    var keys = Object.keys(morphAttributes);

                    if (keys.length > 0) {
                        var morphAttribute = morphAttributes[keys[0]];

                        if (morphAttribute !== undefined) {
                            this.morphTargetInfluences = [];
                            this.morphTargetDictionary = {};

                            for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                                name = morphAttribute[m].name || String(m);
                                this.morphTargetInfluences.push(0);
                                this.morphTargetDictionary[name] = m;
                            }
                        }
                    }
                } else {
                    var morphTargets = geometry.morphTargets;

                    if (morphTargets !== undefined && morphTargets.length > 0) {
                        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this);
            }
        });

        function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
            var rayPointDistanceSq = _ray$1.distanceSqToPoint(point);

            if (rayPointDistanceSq < localThresholdSq) {
                var intersectPoint = new Vector3();

                _ray$1.closestPointToPoint(point, intersectPoint);

                intersectPoint.applyMatrix4(matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                if (distance < raycaster.near || distance > raycaster.far) return;
                intersects.push({
                    distance: distance,
                    distanceToRay: Math.sqrt(rayPointDistanceSq),
                    point: intersectPoint,
                    index: index,
                    face: null,
                    object: object
                });
            }
        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function RawShaderMaterial(parameters) {
            ShaderMaterial.call(this, parameters);
            this.type = 'RawShaderMaterial';
        }

        RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
        RawShaderMaterial.prototype.constructor = RawShaderMaterial;
        RawShaderMaterial.prototype.isRawShaderMaterial = true;

        /**
         * @author bhouston / http://clara.io
         */

        var _vector$7 = new Vector2();

        function Box2(min, max) {
            this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
            this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
        }

        Object.assign(Box2.prototype, {
            set: function (min, max) {
                this.min.copy(min);
                this.max.copy(max);
                return this;
            },
            setFromPoints: function (points) {
                this.makeEmpty();

                for (var i = 0, il = points.length; i < il; i++) {
                    this.expandByPoint(points[i]);
                }

                return this;
            },
            setFromCenterAndSize: function (center, size) {
                var halfSize = _vector$7.copy(size).multiplyScalar(0.5);

                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (box) {
                this.min.copy(box.min);
                this.max.copy(box.max);
                return this;
            },
            makeEmpty: function () {
                this.min.x = this.min.y = +Infinity;
                this.max.x = this.max.y = -Infinity;
                return this;
            },
            isEmpty: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return this.max.x < this.min.x || this.max.y < this.min.y;
            },
            getCenter: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Box2: .getCenter() target is now required');
                    target = new Vector2();
                }

                return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function (target) {
                if (target === undefined) {
                    console.warn('THREE.Box2: .getSize() target is now required');
                    target = new Vector2();
                }

                return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
            },
            expandByPoint: function (point) {
                this.min.min(point);
                this.max.max(point);
                return this;
            },
            expandByVector: function (vector) {
                this.min.sub(vector);
                this.max.add(vector);
                return this;
            },
            expandByScalar: function (scalar) {
                this.min.addScalar(-scalar);
                this.max.addScalar(scalar);
                return this;
            },
            containsPoint: function (point) {
                return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
            },
            containsBox: function (box) {
                return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
            },
            getParameter: function (point, target) {
                // This can potentially have a divide by zero if the box
                // has a size dimension of 0.
                if (target === undefined) {
                    console.warn('THREE.Box2: .getParameter() target is now required');
                    target = new Vector2();
                }

                return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
            },
            intersectsBox: function (box) {
                // using 4 splitting planes to rule out intersections
                return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
            },
            clampPoint: function (point, target) {
                if (target === undefined) {
                    console.warn('THREE.Box2: .clampPoint() target is now required');
                    target = new Vector2();
                }

                return target.copy(point).clamp(this.min, this.max);
            },
            distanceToPoint: function (point) {
                var clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);

                return clampedPoint.sub(point).length();
            },
            intersect: function (box) {
                this.min.max(box.min);
                this.max.min(box.max);
                return this;
            },
            union: function (box) {
                this.min.min(box.min);
                this.max.max(box.max);
                return this;
            },
            translate: function (offset) {
                this.min.add(offset);
                this.max.add(offset);
                return this;
            },
            equals: function (box) {
                return box.min.equals(this.min) && box.max.equals(this.max);
            }
        });

        var Lensflare = function Lensflare() {
            Mesh.call(this, Lensflare.Geometry, new MeshBasicMaterial({
                opacity: 0,
                transparent: true
            }));
            this.type = 'Lensflare';
            this.frustumCulled = false;
            this.renderOrder = Infinity; //

            var positionScreen = new Vector3();
            var positionView = new Vector3(); // textures

            var tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);
            tempMap.minFilter = NearestFilter;
            tempMap.magFilter = NearestFilter;
            tempMap.wrapS = ClampToEdgeWrapping;
            tempMap.wrapT = ClampToEdgeWrapping;
            var occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);
            occlusionMap.minFilter = NearestFilter;
            occlusionMap.magFilter = NearestFilter;
            occlusionMap.wrapS = ClampToEdgeWrapping;
            occlusionMap.wrapT = ClampToEdgeWrapping; // material

            var geometry = Lensflare.Geometry;
            var material1a = new RawShaderMaterial({
                uniforms: {
                    scale: {
                        value: null
                    },
                    screenPosition: {
                        value: null
                    }
                },
                vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'void main() {', '	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\n'),
                fragmentShader: ['precision highp float;', 'void main() {', '	gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );', '}'].join('\n'),
                depthTest: true,
                depthWrite: false,
                transparent: false
            });
            var material1b = new RawShaderMaterial({
                uniforms: {
                    map: {
                        value: tempMap
                    },
                    scale: {
                        value: null
                    },
                    screenPosition: {
                        value: null
                    }
                },
                vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', '	vUV = uv;', '	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\n'),
                fragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'varying vec2 vUV;', 'void main() {', '	gl_FragColor = texture2D( map, vUV );', '}'].join('\n'),
                depthTest: false,
                depthWrite: false,
                transparent: false
            }); // the following object is used for occlusionMap generation

            var mesh1 = new Mesh(geometry, material1a); //

            var elements = [];
            var shader = LensflareElement.Shader;
            var material2 = new RawShaderMaterial({
                uniforms: {
                    map: {
                        value: null
                    },
                    occlusionMap: {
                        value: occlusionMap
                    },
                    color: {
                        value: new Color(0xffffff)
                    },
                    scale: {
                        value: new Vector2()
                    },
                    screenPosition: {
                        value: new Vector3()
                    }
                },
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                blending: AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            var mesh2 = new Mesh(geometry, material2);

            this.addElement = function (element) {
                elements.push(element);
            }; //


            var scale = new Vector2();
            var screenPositionPixels = new Vector2();
            var validArea = new Box2();
            var viewport = new Vector4();

            this.onBeforeRender = function (renderer, scene, camera) {
                renderer.getCurrentViewport(viewport);
                var invAspect = viewport.w / viewport.z;
                var halfViewportWidth = viewport.z / 2.0;
                var halfViewportHeight = viewport.w / 2.0;
                var size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                validArea.min.set(viewport.x, viewport.y);
                validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space

                positionView.setFromMatrixPosition(this.matrixWorld);
                positionView.applyMatrix4(camera.matrixWorldInverse);
                if (positionView.z > 0) return; // lensflare is behind the camera

                positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy

                screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull

                if (validArea.containsPoint(screenPositionPixels)) {
                    // save current RGB to temp texture
                    renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad

                    var uniforms = material1a.uniforms;
                    uniforms['scale'].value = scale;
                    uniforms['screenPosition'].value = positionScreen;
                    renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap

                    renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics

                    var uniforms = material1b.uniforms;
                    uniforms['scale'].value = scale;
                    uniforms['screenPosition'].value = positionScreen;
                    renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements

                    var vecX = -positionScreen.x * 2;
                    var vecY = -positionScreen.y * 2;

                    for (var i = 0, l = elements.length; i < l; i++) {
                        var element = elements[i];
                        var uniforms = material2.uniforms;
                        uniforms['color'].value.copy(element.color);
                        uniforms['map'].value = element.texture;
                        uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;
                        uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;
                        var size = element.size / viewport.w;
                        var invAspect = viewport.w / viewport.z;
                        uniforms['scale'].value.set(size * invAspect, size);
                        material2.uniformsNeedUpdate = true;
                        renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
                    }
                }
            };

            this.dispose = function () {
                material1a.dispose();
                material1b.dispose();
                material2.dispose();
                tempMap.dispose();
                occlusionMap.dispose();

                for (var i = 0, l = elements.length; i < l; i++) {
                    elements[i].texture.dispose();
                    elements[i].texture = null;
                }

                material1a = null;
                material1b = null;
                material2 = null;
                tempMap = null;
                occlusionMap = null;
            };
        };

        Lensflare.prototype = Object.create(Mesh.prototype);
        Lensflare.prototype.constructor = Lensflare;
        Lensflare.prototype.isLensflare = true; //

        var LensflareElement = function LensflareElement(texture, size, distance, color) {
            this.texture = texture;
            this.size = size || 1;
            this.distance = distance || 0;
            this.color = color || new Color(0xffffff);
        };

        LensflareElement.Shader = {
            uniforms: {
                map: {
                    value: null
                },
                occlusionMap: {
                    value: null
                },
                color: {
                    value: null
                },
                scale: {
                    value: null
                },
                screenPosition: {
                    value: null
                }
            },
            vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'uniform sampler2D occlusionMap;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	vUV = uv;', '	vec2 pos = position.xy;', '	vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );', '	vVisibility =        visibility.r / 9.0;', '	vVisibility *= 1.0 - visibility.g / 9.0;', '	vVisibility *=       visibility.b / 9.0;', '	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );', '}'].join('\n'),
            fragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	vec4 texture = texture2D( map, vUV );', '	texture.a *= vVisibility;', '	gl_FragColor = texture;', '	gl_FragColor.rgb *= color;', '}'].join('\n')
        };

        Lensflare.Geometry = function () {
            var geometry = new BufferGeometry();
            var float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
            var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            geometry.setIndex([0, 1, 2, 0, 2, 3]);
            geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
            return geometry;
        }();

        var Object3DProxy = function Object3DProxy() {};

        Object3DProxy.BoxBufferGeometry = BoxBufferGeometry;
        Object3DProxy.ShaderMaterial = ShaderMaterial;
        Object3DProxy.Mesh = Mesh;
        Object3DProxy.OrthographicCamera = OrthographicCamera;
        Object3DProxy.PlaneBufferGeometry = PlaneBufferGeometry;
        Object3DProxy.TextureLoader = TextureLoader;
        Object3DProxy.LinearFilter = LinearFilter;
        Object3DProxy.NearestFilter = NearestFilter;
        Object3DProxy.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
        Object3DProxy.ClampToEdgeWrapping = ClampToEdgeWrapping;
        Object3DProxy.RepeatWrapping = RepeatWrapping;
        Object3DProxy.RGBFormat = RGBFormat;
        Object3DProxy.Group = Group;
        Object3DProxy.DoubleSide = DoubleSide;
        Object3DProxy.BackSide = BackSide;
        Object3DProxy.FrontSide = FrontSide;
        Object3DProxy.Quaternion = Quaternion;
        Object3DProxy.AdditiveBlending = AdditiveBlending;
        Object3DProxy.Points = Points;

        Object3DProxy.newWebGLRenderer = function (parameters) {
            return new WebGLRenderer(parameters);
        };

        Object3DProxy.newFloat32BufferAttribute = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _construct(Float32BufferAttribute, args);
        };

        Object3DProxy.newWebGLRenderTarget = function (width, height, parameters) {
            return new WebGLRenderTarget(width, height, parameters);
        };

        Object3DProxy.newBufferGeometry = function () {
            return new BufferGeometry();
        };

        Object3DProxy.newCube = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            return _construct(BoxBufferGeometry, args);
        };

        Object3DProxy.newSphere = function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            return _construct(SphereBufferGeometry, args);
        };

        Object3DProxy.newTexture = function () {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
            }

            return _construct(Texture, args);
        };

        Object3DProxy.newPlane = function (_ref) {
            var _ref$width = _ref.width,
                width = _ref$width === void 0 ? 20 : _ref$width,
                _ref$height = _ref.height,
                height = _ref$height === void 0 ? 20 : _ref$height,
                _ref$widthSegments = _ref.widthSegments,
                widthSegments = _ref$widthSegments === void 0 ? 8 : _ref$widthSegments,
                _ref$heightSegments = _ref.heightSegments,
                heightSegments = _ref$heightSegments === void 0 ? 8 : _ref$heightSegments;
            return new PlaneBufferGeometry(width, height, widthSegments, heightSegments);
        };

        Object3DProxy.newSprite = function (material) {
            return new Sprite(material);
        };

        Object3DProxy.newScene = function () {
            return new Scene();
        };

        Object3DProxy.newCamera = function (_ref2) {
            var fov = _ref2.fov,
                aspect = _ref2.aspect,
                near = _ref2.near,
                far = _ref2.far;
            return new PerspectiveCamera(fov, aspect, near, far);
        };

        Object3DProxy.newRaycaster = function (_ref3) {
            var origin = _ref3.origin,
                direction = _ref3.direction,
                near = _ref3.near,
                far = _ref3.far;
            return new Raycaster(origin, direction, near, far);
        };

        Object3DProxy.newTextureLoader = function () {
            return new TextureLoader();
        };

        Object3DProxy.newMeshBasicMaterial = function (parameters) {
            return new MeshBasicMaterial(parameters);
        };

        Object3DProxy.newSpriteMaterial = function (parameters) {
            return new SpriteMaterial(parameters);
        };

        Object3DProxy.setMaterialFilter = function (material) {
            material.map.magFilter = Object3DProxy.LinearFilter;
            material.map.minFilter = Object3DProxy.LinearFilter;
            material.map.wrapS = Object3DProxy.ClampToEdgeWrapping;
            material.map.wrapT = Object3DProxy.ClampToEdgeWrapping;
        };

        Object3DProxy.newClock = function () {
            return new Clock();
        };

        Object3DProxy.newMesh = function (geometry, material) {
            return new Mesh(geometry, material);
        };

        Object3DProxy.newGroup = function () {
            return new Group();
        };

        Object3DProxy.newColor = function (r, g, b) {
            return new Color(r, g, b);
        };

        Object3DProxy.degToRad = function (deg) {
            return MathUtils.degToRad(deg);
        };

        Object3DProxy.radToDeg = function (rad) {
            return MathUtils.radToDeg(rad);
        };

        Object3DProxy.newFrustum = function () {
            return new Frustum();
        };

        Object3DProxy.newMatrix4 = function () {
            return new Matrix4();
        };

        Object3DProxy.newVector3 = function (x, y, z) {
            return new Vector3(x, y, z);
        };

        Object3DProxy.newVector2 = function (x, y) {
            return new Vector2(x, y);
        };

        Object3DProxy.newObject3D = function () {
            return new Object3D();
        };

        Object3DProxy.newPointLight = function () {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
            }

            return _construct(PointLight, args);
        };

        Object3DProxy.newLensflare = function () {
            return new Lensflare();
        };

        Object3DProxy.newLensflareElement = function () {
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                args[_key6] = arguments[_key6];
            }

            return _construct(LensflareElement, args);
        };

        Object3DProxy.newPointsMaterial = function (args) {
            return new PointsMaterial(args);
        };

        Object3DProxy.newPoints = function () {
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
            }

            return _construct(Points, args);
        };

        Object3DProxy.newEuler = function () {
            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                args[_key8] = arguments[_key8];
            }

            return _construct(Euler, args);
        };

        /*
	 * @files: request.js
	 * @Author: guowubiao
	 * @Date: 2020-03-17 23:42
	 */
        function addUrlCorsOrigin(url) {
            return url + (url.indexOf('?') !== -1 ? '&' : '?') + 'origin=' + encodeURIComponent(location.origin);
        }

        function request(opt) {
            var options = opt || {};
            options.type = (options.type || 'GET').toUpperCase();
            var xhr;

            if (window.ActiveXObject) {
                xhr = new window.ActiveXObject('Microsoft.XMLHTTP');
            } else {
                xhr = new XMLHttpRequest();
            }

            if (opt.withCredentials) {
                xhr.withCredentials = true;
            }

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var status = xhr.status;

                    if (status >= 200 && status < 300) {
                        // eslint-disable-next-line no-unused-expressions
                        options.success && options.success(xhr.responseText);
                    } else {
                        // eslint-disable-next-line no-unused-expressions
                        options.error && options.error(status);
                        options.error = null;
                    }
                }
            };

            if (options.ontimeout) {
                xhr.ontimeout = options.ontimeout;
            }

            if (options.error) {
                xhr.onerror = function (error) {
                    options.error && options.error(error);
                    options.error = null;
                };
            }

            var url = options.addUrlCorsOrigin ? addUrlCorsOrigin(options.url) : options.url;
            xhr.timeout = options.timeout || 10000;

            if (options.type === 'GET') {
                xhr.open('GET', url, true);

                for (var k in options.headers) {
                    xhr.setRequestHeader(k, options.headers[k]);
                }

                xhr.send(null);
            } else if (options.type === 'POST') {
                xhr.open('POST', url, true);

                for (var _k in options.headers) {
                    xhr.setRequestHeader(_k, options.headers[_k]);
                }

                console.log(xhr);
                options.body = options.body || {};
                xhr.send(JSON.stringify(options.body));
            }
        }

        var _Promise = typeof Promise === 'undefined' ? es6Promise.Promise : Promise;

        var Loader$1 = function Loader(viewer) {
            var _this = this;

            this.loadJson = function (url) {
                return new _Promise(function (resolve, reject) {
                    request({
                        url: url,
                        type: 'get',
                        dataType: 'json',
                        success: function success(data) {
                            console.log('success');
                            resolve(JSON.parse(data));
                        },
                        error: function error(_error) {
                            console.log(_error);
                            reject(_error);
                        }
                    });
                });
            };

            this.loadImage = function (url) {
                return new _Promise(function (resolve, reject) {
                    _this.imageLoader.load(addUrlCorsOrigin(url), function (texture) {
                        texture.magFilter = texture.minFilter = Object3DProxy.LinearFilter;
                        resolve(texture);
                    }, undefined, function (error) {
                        // console.error(error);
                        reject(error);
                    });
                });
            };

            this.viewer = viewer;
            this.imageLoader = Object3DProxy.newTextureLoader();
        };

        /**
         * Base3D: 3D
         */
        var Base3D = function Base3D() {
            var _this = this;

            this.log = function (data) {
                console.log(_this.constructor.name, data);
            };

            this.on = function (eventName, callback) {
                _this.addEventListener(eventName, callback);
            };

            this.off = function (eventName, callback) {
                _this.removeEventListener(eventName, callback);
            };

            this.addEventListener = function (type, listener) {
                if (_this._listeners === undefined) {
                    _this._listeners = {};
                }

                if (_this._listeners[type] === undefined) {
                    _this._listeners[type] = [];
                }

                if (_this._listeners[type].indexOf(listener) === -1) {
                    _this._listeners[type].push(listener);
                }
            };

            this.hasEventListener = function (type, listener) {
                if (_this._listeners === undefined) {
                    return false;
                }

                return _this._listeners[type] !== undefined && _this._listeners[type].indexOf(listener) !== -1;
            };

            this.removeEventListener = function (type, listener) {
                if (_this._listeners === undefined) {
                    return;
                }

                var listenerArray = _this._listeners[type];

                if (listenerArray !== undefined) {
                    var index = listenerArray.indexOf(listener);

                    if (index !== -1) {
                        listenerArray.splice(index, 1);
                    }
                }
            };

            this.dispatchEvent = function (event) {
                if (_this._listeners === undefined) {
                    return;
                }

                var listenerArray = _this._listeners[event.type];

                if (listenerArray !== undefined) {
                    event.target = _this;
                    var array = listenerArray.slice(0);

                    for (var i = 0, l = array.length; i < l; i++) {
                        array[i].call(_this, event);
                    }
                }
            };

            this.trigger = function (evtName) {
                // patch for spin
                if (_this._listeners === undefined) {
                    return;
                }

                var listenerArray = _this._listeners[evtName];

                if (listenerArray !== undefined) {
                    var array = listenerArray.slice(0);

                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }

                    for (var i = 0, l = array.length; i < l; i++) {
                        array[i].apply(_this, args);
                    }
                }
            };

            this.clearSubscribers = function () {
                _this._listeners === undefined;
            };
        };

        const PROJECTION_TYPE = {
            SPHERE: 'sphere',
            CUBE: 'cube',
            CUBE_LIST: 'cube-list',
            CUBE_MULTI: 'cube-multi'
        };
        const CAMERA_DEFAULT_OPTIONS = {
            pitchRange: [-90, 90],
            fovRange: [30, 120],
            autoRotate: {
                enable: false,
                delay: 3000,
                speed: -4
            }
        };
        const HOTSPOT_TYPE = {
            SWITCH: 'switch',
            LABEL: 'label',
            VIDEO: 'video',
            POLE: 'pole',
            CUSTOM: 'custom',
            THEED_D: '3d',
            DOM: 'dom'
        };
        const HOTSPOT_OPTIONS = {
            LABEL_RAY_LENGTH: 40,
            MASK_RAY_LENGTH: 40,
            LINK_RAY_LENGTH: 40
        };
        const SDK_MODE = {
            SHOW: 0,
            EDIT: 1
        };
        const EFFECT_TYPE = {
            LIGHT: 'light',
            PARTICLE: 'particle'
        };
        const EVENT_INT = {
            DISPLAY_LOADED: 'display-loaded',
            DISPLAY_LOAD_ERROR: 'display-load-error',
            TILE_LOAD: 'tile-load',
            ANIMATION_READY: 'animation-ready',
            ANIMATION_END: 'animation-end',
            TILE_INIT_ERROR: 'tile-init-error',
            TILE_IMAGE_ERROR: 'tile-image-error',
            SCENE_READY: 'scene-ready',
            SCENE_LOADED: 'SCENE_LOADED',
            CANVAS_DRAWN: 'canvas-draw',
            LEVEL_LOADED: 'level-loaded',
            LOADED: 'LOADED'
        };
        const EVENT = {
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#webgl-not-support
             * @event
             */
            STARTUP_END: 'hyd-startup-end',
            STARTUP_ERROR: 'hyd-startup-error',
            /**
             * ebgl.
             *
             * @name Hydreigon.PanoViewer#webgl-not-support
             * @event
             */
            WEBGL_NO_SUPPORT: 'webgl-not-support',
            /**
             * .
             *
             * @name Hydreigon.PanoViewer#options-error
             * @event
             */
            OPTIONS_ERROR: 'options-error',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#loaded
             * @event
             */
            LOADED: 'loaded',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-loading
             * @returns {string} sceneId:id
             * @event
             */
            SCENE_LOADING: 'scene-loading',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-transition
             * @event
             */
            SCENE_TRANSITION: 'scene-transition',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-loaded
             * @returns {string} sceneId:id
             * @event
             */
            SCENE_LOADED: 'scene-loaded',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-image-error
             * @event
             */
            SCENE_IMAGE_ERROR: 'hyd-image-error',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-config-error
             * @event
             */
            SCENE_CONFIG_ERROR: 'hyd-config-error',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#scene-click
             * @returns {string} sceneId:id
             * @event
             */
            SCENE_CLICK: 'scene-click',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#tile-image-error
             * @event
             */
            TILE_IMAGE_ERROR: 'tile-image-error',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#hs-update
             * @returns {string} sceneId id
             * @returns {string} hotspotId Id
             * @returns {Object} hotspot 
             * @event
             */
            HS_UPDATE: 'hs-update',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#hs-select
             * @param {string} Id
             * @event
             */
            HS_SELECT: 'hs-select',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#hs-unselect
             * @event
             */
            HS_UNSELECT: 'hs-unselect',
            /**
             * 3D
             *
             * @name Hydreigon.PanoViewer#hs-click
             * @event
             */
            HS_CLICK: 'hs-click',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-change
             * @returns {string} cause nimouchyroutoll
             * @returns {Object} rotation otation
             * @returns {float} fov ov
             * @event
             */
            CAMERA_CHANGE: 'camera-change',
            /**
             * evel
             *
             * @name Hydreigon.PanoViewer#level-loaded
             * @event
             */
            LEVEL_LOADED: 'level-loaded',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-animation-start
             * @event
             */
            CAMERA_ANIMATION_START: 'camera-animation-start',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-animation-end
             * @event
             */
            CAMERA_ANIMATION_END: 'camera-animation-end',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-animation-end
             * @event
             */
            SNAPSHOT_READY: 'snapshot-ready',
            CAN_ENTER: 'can-enter',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-animation-end
             * @event
             */
            BEFORE_RENDER: 'before-render',
            /**
             * 
             *
             * @name Hydreigon.PanoViewer#camera-animation-end
             * @event
             */
            AFTER_RENDER: 'after-render',
            /**
             * 
             */
            CONTROLLER_DRAG: 'controller-drag',
            /**
             * 
             */
            TRANSITION_END: 'transition-end',
            ANIMATION_END: 'animation-end',
            ANIMATION_START: 'animation-start',
            ANIMATION_PAUSE: 'animation-pause',
            ANIMATION_RESUME: 'animation-resume',
            PAUSE_AUTO_ROTATE: 'pause-auto-rotate'
        };

        var Display = /*#__PURE__*/function (_Base3D) {
            _inheritsLoose(Display, _Base3D);

            function Display(viewer) {
                var _this;

                _this = _Base3D.call(this) || this;
                _this.viewer = null;
                _this.viewer = viewer;
                return _this;
            }

            return Display;
        }(Base3D);

        var SphereMesh = /*#__PURE__*/function (_Display) {
            _inheritsLoose(SphereMesh, _Display);

            function SphereMesh(viewer, config) {
                var _this;

                _this = _Display.call(this, viewer) || this;
                _this.config = null;
                _this.display = null;

                _this.startLoad = function () {
                    var geometry = Object3DProxy.newSphere(_this.viewer.geometrySize, 64, 64);

                    _this.createMesh(geometry, _this.config.image);

                    return _assertThisInitialized(_this);
                };

                _this.createMesh = function (geometry, url) {
                    _this.viewer.loader.loadImage(url).then(function (texture) {
                        var material = Object3DProxy.newMeshBasicMaterial({
                            map: texture
                        });
                        Object3DProxy.setMaterialFilter(material);
                        geometry.scale(-1, 1, 1);
                        geometry.rotateY(-Math.PI / 2);
                        _this.display = Object3DProxy.newMesh(geometry, material);

                        _this.dispatchEvent({
                            type: EVENT_INT.DISPLAY_LOADED,
                            mesh: _assertThisInitialized(_this)
                        });
                    })["catch"](function (error) {
                        _this.dispatchEvent({
                            type: EVENT_INT.DISPLAY_LOAD_ERROR,
                            error: error
                        });
                    });
                };

                _this.update = function () {};

                _this.viewer.geometrySize = 100;
                _this.config = config;
                console.log(config);
                return _this;
            }

            var _proto = SphereMesh.prototype;

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }

                this.display.material.map.dispose();
                this.display.material.dispose();
                this.display.geometry.dispose();
                this.display.material.map = null;
                this.display.material = null;
                this.display.geometry = null;
            };

            return SphereMesh;
        }(Display);

        var _Promise$1 = typeof Promise === 'undefined' ? es6Promise.Promise : Promise;
        var FACE_INDEX = {
            r: 0,
            l: 1,
            u: 2,
            d: 3,
            f: 4,
            b: 5
        };
        var FACE_ORDER = ['r', 'l', 'u', 'd', 'f', 'b'];

        var CubeMesh = /*#__PURE__*/function (_Display) {
            _inheritsLoose(CubeMesh, _Display);

            function CubeMesh(viewer, config, multires) {
                var _this;

                if (multires === void 0) {
                    multires = false;
                }

                _this = _Display.call(this, viewer) || this;
                _this.config = null;
                _this.display = null;

                _this.startLoad = function () {
                    _this.create();
                };

                _this.create = function () {
                    _this.createGeometry();

                    _this.createMaterial().then(function (materialArr) {
                        _this.display = Object3DProxy.newMesh(_this.geometry, materialArr); // if (!this.viewer.enterAnimationFinished) {
                        //     console.log('');
                        //     this.setMorph(1);
                        // }

                        if (_this.multires) {
                            _this.dispatchEvent({
                                type: EVENT_INT.CANVAS_DRAWN,
                                cube: _assertThisInitialized(_this)
                            });
                        } else {
                            _this.dispatchEvent({
                                type: EVENT_INT.DISPLAY_LOADED,
                                mesh: _assertThisInitialized(_this)
                            });
                        }

                        _this.geometry.scale(_this.viewer.geometrySize, _this.viewer.geometrySize, _this.viewer.geometrySize);
                    })["catch"](function (error) {
                        _this.dispatchEvent({
                            type: EVENT_INT.DISPLAY_LOAD_ERROR,
                            error: error
                        });
                    });
                };

                _this.createGeometry = function () {
                    _this.geometry = new Object3DProxy.BoxBufferGeometry(2, 2, 2, 32, 32, 32);
                    _this.viewer.geometrySize = 200;

                    _this.geometry.scale(-1, 1, 1);

                    if (_this.multires) {
                        _this.viewer.geometrySize = _this.multires.config.tile_size[_this.multires.config.tile_size.length - 1] * 1.1;
                    }

                    _this.geometry.rotateY(Math.PI); // fixme: judge animation;


                    _this.createMorph(_this.geometry, _this.viewer.geometrySize);
                };

                _this.drawMultiresPiece = function (image, row, col, faceIndex) {
                    var canvas = _this.canvasArr[FACE_INDEX[faceIndex]];
                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 512 * (col - 1), 512 * (row - 1));

                    for (var _iterator = _createForOfIteratorHelperLoose(_this.materialArr), _step; !(_step = _iterator()).done;) {
                        var item = _step.value;
                        item.map.needsUpdate = true;
                        item.needsUpdate = true;
                    }
                };

                _this.createMorph = function (geometry, size) {
                    geometry.morphAttributes.position = []; // 

                    var positions = geometry.attributes.position.array;
                    var spherePositions = [];

                    for (var i = 0; i < positions.length; i += 3) {
                        var x = positions[i];
                        var y = positions[i + 1];
                        var z = positions[i + 2];
                        spherePositions.push(x * Math.sqrt(1 - y * y / 2 - z * z / 2 + y * y * z * z / 3) * size, y * Math.sqrt(1 - z * z / 2 - x * x / 2 + z * z * x * x / 3) * size, z * Math.sqrt(1 - x * x / 2 - y * y / 2 + x * x * y * y / 3) * size);
                    }

                    geometry.morphAttributes.position[0] = Object3DProxy.newFloat32BufferAttribute(spherePositions, 3);
                };

                _this.setMorph = function (value) {
                    _this.display.morphTargetInfluences[0] = value;
                };

                _this.createMaterial = function () {
                    if (_this.config.image) {
                        if (_this.config.image instanceof Array) {
                            return _this.createMaterialWithList(_this.config.image);
                        } else {
                            return _this.createMaterialWithSprite(_this.config.image, [{
                                y: 2,
                                x: 0
                            }, // right
                                {
                                    y: 0,
                                    x: 0
                                }, // left
                                {
                                    y: 4,
                                    x: 0
                                }, // up
                                {
                                    y: 5,
                                    x: 0
                                }, // down
                                {
                                    y: 1,
                                    x: 0
                                }, // back
                                {
                                    y: 3,
                                    x: 0
                                } // front
                            ]);
                        }
                    } else {
                        return _this.createMaterialWithSprite(_this.config.preview || _this.config.tile_path + 'preview.jpg', [{
                            y: 2,
                            x: 0
                        }, // right
                            {
                                y: 0,
                                x: 0
                            }, // left
                            {
                                y: 4,
                                x: 0
                            }, // up
                            {
                                y: 5,
                                x: 0
                            }, // down
                            {
                                y: 1,
                                x: 0
                            }, // back
                            {
                                y: 3,
                                x: 0
                            } // front
                        ]);
                    }
                };

                _this.createMaterialWithList = function (urls) {
                    var promise = new _Promise$1(function (resolve, reject) {
                        var promiseList = [];
                        var tmpPromise = null;
                        var d = null;
                        var index = null;

                        for (var i = 0, length = 6; i < length; ++i) {
                            d = FACE_ORDER[i];
                            index = _this.config.order.indexOf(d);
                            tmpPromise = _this.viewer.loader.loadImage(urls[index]);
                            promiseList.push(tmpPromise);
                        }

                        _Promise$1.all(promiseList).then(function (textures) {
                            var textureArr = [];
                            textures.forEach(function (image) {
                                var material = Object3DProxy.newMeshBasicMaterial({
                                    map: image
                                });
                                textureArr.push(material);
                            });
                            resolve(textureArr);
                        })["catch"](function (error) {
                            _this.viewer.dispatchEvent({
                                type: EVENT.SCENE_IMAGE_ERROR
                            });

                            reject(error);
                        });
                    });
                    return promise;
                };

                _this.createMaterialWithSprite = function (url, pos) {
                    var promise = new _Promise$1(function (resolve, reject) {
                        _this.viewer.loader.loadImage(url).then(function (texture) {
                            var image = texture.image;
                            _this.materialArr = [];
                            var isize = image.naturalWidth;
                            var size = isize;

                            if (_this.multires) {
                                size = _this.multires.config.tile_size[_this.multires.initLevel];
                            }

                            for (var i = 0; i < 6; i++) {
                                var canvas = document.createElement('canvas');
                                var context = canvas.getContext('2d');
                                canvas.height = size;
                                canvas.width = size;
                                context.drawImage(image, 0, pos[i].y * isize + 1, isize, isize - 2, 0, 0, size, size);

                                var _texture = Object3DProxy.newTexture(canvas);

                                _texture.image = canvas;
                                _texture.magFilter = _texture.minFilter = Object3DProxy.LinearFilter;
                                _texture.needsUpdate = true;

                                _this.canvasArr.push(canvas);

                                _this.materialArr.push(Object3DProxy.newMeshBasicMaterial({
                                    map: _texture,
                                    side: Object3DProxy.DoubleSide,
                                    morphTargets: true
                                }));
                            }

                            resolve(_this.materialArr);
                        })["catch"](function (error) {
                            _this.viewer.dispatchEvent({
                                type: EVENT.SCENE_IMAGE_ERROR
                            });

                            reject(error);
                        });
                    });
                    return promise;
                };

                _this.update = function () {};

                _this.multires = multires;
                _this.config = config;
                _this.canvasArr = [];
                return _this;
            }

            var _proto = CubeMesh.prototype;

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }

                if (this.display && this.display.geometry) {
                    this.display.geometry.dispose();
                    this.display.geometry = null;
                }

                if (this.display && this.display.material) {
                    this.display.material.forEach(function (material) {
                        material.map.dispose();
                        material.map = null;
                    });
                    this.display.material = null;
                }

                if (this.canvasArr) {
                    this.canvasArr.forEach(function (canvas) {
                        canvas && canvas.remove();
                        canvas = null;
                    });
                    this.canvasArr = null;
                }

                if (this.materialArr) {
                    this.materialArr.forEach(function (material) {
                        if (material) {
                            var _material$map;

                            (_material$map = material.map) === null || _material$map === void 0 ? void 0 : _material$map.dispose();
                            material.map = null;
                        }
                    });
                    this.materialArr = null;
                }

                this.display = null;
                this.viewer = null;
                this.multires = null;
            };

            return CubeMesh;
        }(Display);

        // {
        //     "levels": [2, 4, 6], // evels.length
        //     "tilePath": "http://url.com/",
        //     "tileFile": "${face}/${level}/${row}/${level}_${face}_${row}_${col}.jpg",
        //     "tileSize": [512,640,1280,2560], // 512*5126402
        // }

        var FACE_ARR = ['f', 'b', 'l', 'r', 'u', 'd'];
        var LEVEL_COLOR = {
            1: 'red',
            2: 'green',
            3: 'blue',
            4: 'white'
        }; // url

        var MeshPiece = /*#__PURE__*/function (_Display) {
            _inheritsLoose(MeshPiece, _Display);

            function MeshPiece(multires, level, face, row, col, url) {
                var _this;

                _this = _Display.call(this) || this;

                _this.load = function () {
                    var geometry = Object3DProxy.newPlane({
                        width: _this.width,
                        height: _this.height,
                        widthSegments: 1,
                        heightSegments: 1
                    });

                    _this.multires.viewer.loader.loadImage(_this.url).then(function (texture) {
                        var _this$mesh$position;

                        if (!_this.multires.viewer.imageResource) {
                            _this.multires.viewer.imageResource = {};
                        }

                        _this.multires.viewer.imageResource[_this.level + "-" + _this.face + "-" + _this.row + "-" + _this.col] = texture.image;

                        _this.dispatchEvent({
                            type: EVENT_INT.TILE_LOAD,
                            display: _assertThisInitialized(_this)
                        });

                        var material = Object3DProxy.newMeshBasicMaterial({
                            map: texture
                        });
                        Object3DProxy.setMaterialFilter(material);
                        _this.mesh = Object3DProxy.newMesh(geometry, material); // 

                        if (_this.multires.viewer.enterAnimationFinished) {
                            _this.multires.display.add(_this.mesh);

                            _this.multires.viewer.story.currentScene._bindEvent(_this.mesh);
                        } else {
                            _this.multires.piecesNotInScene.push(_assertThisInitialized(_this));
                        }

                        if (_this.level === _this.multires.initLevel) {
                            _this.multires.outCube.drawMultiresPiece(texture.image, _this.row, _this.col, _this.face);
                        }

                        (_this$mesh$position = _this.mesh.position).set.apply(_this$mesh$position, _this.getPositionFromConfig(_this.config));

                        _this.mesh.name = "level" + _this.level + "-" + _this.face + "-" + _this.row + "-" + _this.col;
                        _this.mesh.self = _assertThisInitialized(_this);

                        if (_this.multires.viewer.options.debugLayer) {
                            _this.addDebugerLayer();
                        }
                    })["catch"](function () {
                        _this.isFailed = true;
                        console.log('mesh failed', "level" + _this.level + "-" + _this.face + "-" + _this.row + "-" + _this.col);

                        _this.dispatchEvent({
                            type: EVENT_INT.DISPLAY_LOAD_ERROR,
                            display: _assertThisInitialized(_this)
                        });
                    });
                };

                _this.addDebugerLayer = function () {
                    var canvas = document.createElement('canvas');
                    canvas.width = _this.width;
                    canvas.height = _this.height;
                    var x = _this.width / 2;
                    var y = _this.height / 2 - 25;
                    var ctx = canvas.getContext('2d');
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(20, 20, _this.width - 40, _this.height - 40);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = LEVEL_COLOR[_this.level] || LEVEL_COLOR[0];
                    ctx.font = '22px Courier';
                    ctx.fillText(_this.mesh.name, x, y);
                    var texture = Object3DProxy.newTexture(canvas);
                    texture.wrapS = texture.wrapT = Object3DProxy.ClampToEdgeWrapping;
                    texture.magFilter = Object3DProxy.LinearFilter;
                    texture.minFilter = Object3DProxy.LinearFilter;
                    texture.needsUpdate = true;
                    var material = Object3DProxy.newMeshBasicMaterial({
                        map: texture,
                        transparent: true
                    });
                    var geometry = Object3DProxy.newPlane({
                        width: _this.width,
                        height: _this.height,
                        widthSegments: 1,
                        heightSegments: 1
                    });
                    var mesh = Object3DProxy.newMesh(geometry, material);
                    mesh.renderOrder = _this.mesh.renderOrder + 1;

                    _this.mesh.add(mesh);
                };

                _this.config = multires.config;
                _this.level = level;
                _this.face = face;
                _this.row = row;
                _this.col = col;
                _this.isFailed = false;

                var _this$getSizeFromConf = _this.getSizeFromConfig(_this.config);

                _this.width = _this$getSizeFromConf[0];
                _this.height = _this$getSizeFromConf[1];
                _this.url = url;
                _this.multires = multires;

                _this.load();

                return _this;
            }

            var _proto = MeshPiece.prototype;

            _proto.getSideWidth = function getSideWidth(config, level) {
                return config.tile_size[level] % 512 || 512;
            };

            _proto.getPositionFromConfig = function getPositionFromConfig(config) {
                // 
                var wholeSize = config.tile_size[this.level];
                var distance = wholeSize / 2; // 

                var left = (this.col - 1) * 512 + this.width / 2 - distance;
                var top = distance - (this.row - 1) * 512 - this.height / 2; // console.log('mesh', left, distance, top);

                switch (this.face) {
                    case 'f':
                        // 
                        return [left, top, -distance];

                    case 'b':
                        // 
                        this.mesh.rotation.y = Math.PI;
                        return [-left, top, distance];

                    case 'l':
                        // 
                        this.mesh.rotation.y = Math.PI / 2;
                        return [-distance, top, -left];

                    case 'r':
                        // 
                        this.mesh.rotation.y = -Math.PI / 2;
                        return [distance, top, left];

                    case 'u':
                        // 
                        this.mesh.rotation.x = Math.PI / 2;
                        return [left, distance, top];

                    case 'd':
                        // 
                        this.mesh.rotation.x = -Math.PI / 2;
                        return [left, -distance, -top];

                    default:
                        return [0, 0, 0];
                }
            };

            _proto.dispose = function dispose() {
                if (this.mesh) {
                    if (this.mesh.parent) {
                        this.mesh.parent.remove(this.mesh);
                    }

                    if (this.mesh.geometry) {
                        this.mesh.geometry.dispose();
                        this.mesh.geometry = null;
                    }

                    if (this.mesh.material) {
                        this.mesh.material.map.dispose();
                        this.mesh.material.map = null;
                        this.mesh.material.dispose();
                        this.mesh.material = null;
                    }

                    this.mesh = null;
                }

                this.clearSubscribers();
                this.multires = null;
                this.config = null;
            } // 
            ;

            _proto.getSizeFromConfig = function getSizeFromConfig(config) {
                var edgeSize = this.getSideWidth(config, this.level);
                var width;
                var height; // 

                if (this.row === config.levels[this.level - 1]) {
                    height = edgeSize;
                } else {
                    height = 512;
                } // 


                if (this.col === config.levels[this.level - 1]) {
                    width = edgeSize;
                } else {
                    width = 512;
                }

                return [width, height];
            };

            return MeshPiece;
        }(Display); // FOVlevel


        var FOV_TO_LEVEL = [85, 60, 40, 30];
        var EPSILON = 0.0000001;

        var Multires = /*#__PURE__*/function (_Display2) {
            _inheritsLoose(Multires, _Display2);

            function Multires(viewer, config, scene, camera) {
                var _this2;

                _this2 = _Display2.call(this, viewer) || this;
                _this2.viewer = null;
                _this2.config = null;
                _this2.visible = false;
                _this2.display = null;
                _this2.firstFall = false;
                _this2.outCube = null;
                _this2.piecesNotInScene = [];

                _this2.checkMeshLevel = function (e) {
                    if (e && e.cause && e.cause === 'anim') {
                        return;
                    }

                    if (_this2.scene.sceneId !== _this2.viewer.story.currentScene.sceneId) {
                        return;
                    } // console.log('level: check');


                    var arr = _this2.checkAllInFrustumPieces();

                    for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done;) {
                        var item = _step.value;

                        _this2.replacePieceNew(item.self.level, item.self.face, item.self.row, item.self.col);
                    }
                };

                _this2.fovToLevel = function (fov) {
                    var h = _this2.viewer.container.offsetHeight * window.devicePixelRatio / Math.tan(Object3DProxy.degToRad(fov / 2));

                    for (var i = 0; i < _this2.config.tile_size.length; i++) {
                        var c = _this2.config.tile_size[i];

                        if (c > h * (_this2.config.zoomFactor || 1)) {
                            return i;
                        }
                    }

                    return _this2.config.tile_size.length - 1;
                };

                _this2.getCurrentPieceFourPoint = function (pieceCount, row, col, sideSize) {
                    var top = 0;
                    var left = 0;
                    var right = 0;
                    var bottom = 0;
                    top = (row - 1) * 512;
                    left = (col - 1) * 512;

                    if (row < pieceCount) {
                        bottom = top + 512;
                    } else {
                        bottom = top + sideSize;
                    }

                    if (col < pieceCount) {
                        right = left + 512;
                    } else {
                        right = left + sideSize;
                    }

                    return {
                        top: top,
                        left: left,
                        right: right,
                        bottom: bottom
                    };
                };

                _this2.init = function () {
                    // this.initLevel = this.fovToLevel(this.camera.fov);
                    _this2.initLevel = 1;
                    _this2.display = Object3DProxy.newGroup();
                    _this2.outCube = new CubeMesh(_this2.viewer, _this2.config, _assertThisInitialized(_this2));

                    _this2.outCube.on(EVENT_INT.CANVAS_DRAWN, function () {
                        _this2.display.add(_this2.outCube.display);

                        _this2.dispatchEvent({
                            type: EVENT_INT.DISPLAY_LOADED,
                            mesh: _assertThisInitialized(_this2)
                        });

                        _this2.showAllLevelPieces(_this2.initLevel);

                        _this2.viewer.on(EVENT.CAMERA_CHANGE, _this2.checkMeshLevel);

                        for (var _iterator2 = _createForOfIteratorHelperLoose(_this2.piecesNotInScene), _step2; !(_step2 = _iterator2()).done;) {
                            var item = _step2.value;

                            _this2.display.add(item.mesh);

                            _this2.viewer.story.currentScene._bindEvent(item.mesh);
                        }

                        _this2.piecesNotInScene = []; // Fixme

                        setTimeout(function () {
                            _this2.checkMeshLevel();
                        }, 0); // this.showAllLevelPieces(1);
                    });

                    _this2.outCube.startLoad();
                };

                _this2.viewer = viewer;
                _this2.config = config;

                if (!_this2.config.levels) {
                    _this2.config.levels = [];

                    for (var i = 1; i < config.tile_size.length; i++) {
                        _this2.config.levels.push(Math.ceil(config.tile_size[i] / 512));
                    }
                }

                _this2.currentLevel = 1;
                _this2.pieces = {};
                _this2.scene = scene;
                _this2.camera = camera;

                _this2.init(); // this.viewer.on(EVENT.SCENE_LOADED, () => {
                //     // console.log('level SNAPSHOT_READY');
                //     this.viewer.on(EVENT.CAMERA_CHANGE, this.checkMeshLevel);
                //     console.log(this.piecesNotInScene)
                //     for (let item of this.piecesNotInScene) {
                //         this.display.add(item.mesh);
                //         this.viewer.story.currentScene._bindEvent(item.mesh);
                //     }
                //     this.piecesNotInScene = [];
                //     // Fixme
                //     setTimeout(() => {
                //         this.checkMeshLevel();
                //     }, 0);
                // });


                return _this2;
            }

            var _proto2 = Multires.prototype;

            _proto2.getCurrentLevel = function getCurrentLevel() {
                for (var i = 0; i < this.config.levels.length; i++) {
                    if (this.camera.fov < FOV_TO_LEVEL[i]) {
                        continue;
                    } else {
                        this.currentLevel = i + 1;
                        break;
                    }
                }
            };

            // fovevel
            _proto2.checkAllInFrustumPieces = function checkAllInFrustumPieces() {
                var frustum = this.viewer.story.currentScene.updateFrustum();
                this.currentLevel = this.fovToLevel(this.camera.fov); // this.getCurrentLevel();

                var arr = []; // console.log('tile: ', this.display.children.length);

                for (var _iterator3 = _createForOfIteratorHelperLoose(this.display.children), _step3; !(_step3 = _iterator3()).done;) {
                    var item = _step3.value;

                    if (!item.self) {
                        // 
                        continue;
                    }

                    if (item.self.level >= this.currentLevel || item.self.hasReplace) {
                        continue;
                    }

                    if (frustum.intersectsObject(item)) {
                        arr.push(item);
                    }
                } // console.log('tile: ', arr.length);


                return arr;
            } // 
            ;

            _proto2.replacePieceNew = function replacePieceNew(oldLevel, face, oldRow, oldCol) {
                var _this3 = this;

                var oldPiece = this.pieces[oldLevel] || {};
                oldPiece = oldPiece[face] || {};
                oldPiece = oldPiece[oldRow] || {};
                oldPiece = oldPiece[oldCol] || undefined;
                var level = oldLevel + 1; // 

                var bigSize = this.config.tile_size[oldLevel]; // 

                var pieceCount = Math.ceil(bigSize / 512);
                var sideSize = bigSize % 512 ? bigSize % 512 : 512; //  0512

                var size = this.getCurrentPieceFourPoint(pieceCount, oldRow, oldCol, sideSize);
                var oldPointRate = {
                    top: size.top / bigSize,
                    left: size.left / bigSize,
                    right: size.right / bigSize,
                    bottom: size.bottom / bigSize
                }; // 

                var newPiecesInfo = [{
                    level: level,
                    face: face,
                    row: oldRow * 2 - 1,
                    col: oldCol * 2 - 1
                }];

                if (oldPiece.height === 512 && oldPiece.width === 512) {
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: oldRow * 2,
                        col: oldCol * 2 - 1
                    });
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: oldRow * 2 - 1,
                        col: oldCol * 2
                    });
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: oldRow * 2,
                        col: oldCol * 2
                    });
                    var bigSizeNew = this.config.tile_size[oldLevel + 1];
                    var pieceCountNew = Math.ceil(bigSizeNew / 512);
                    var sideSizeNew = bigSizeNew % 512 ? bigSizeNew % 512 : 512;
                    var newSize = this.getCurrentPieceFourPoint(pieceCountNew, oldRow * 2, oldCol * 2, sideSizeNew);
                    var newPointRate = {
                        top: newSize.top / bigSizeNew,
                        left: newSize.left / bigSizeNew,
                        right: newSize.right / bigSizeNew,
                        bottom: newSize.bottom / bigSizeNew
                    }; // 2

                    if (Math.abs(newPointRate.right - oldPointRate.right) > EPSILON) {
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 - 1,
                            col: oldCol * 2 + 1
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2,
                            col: oldCol * 2 + 1
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 + 1,
                            col: oldCol * 2 + 1
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 + 1,
                            col: oldCol * 2
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 + 1,
                            col: oldCol * 2 - 1
                        });
                    }
                } else if (oldPiece.height === 512) {
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: oldRow * 2,
                        col: oldCol * 2 - 1
                    });
                    var _bigSizeNew = this.config.tile_size[oldLevel + 1];

                    var _pieceCountNew = Math.ceil(_bigSizeNew / 512);

                    var _sideSizeNew = _bigSizeNew % 512 ? _bigSizeNew % 512 : 512;

                    var _newSize = this.getCurrentPieceFourPoint(_pieceCountNew, oldRow * 2, oldCol * 2 - 1, _sideSizeNew);

                    var _newPointRate = {
                        top: _newSize.top / _bigSizeNew,
                        left: _newSize.left / _bigSizeNew,
                        right: _newSize.right / _bigSizeNew,
                        bottom: _newSize.bottom / _bigSizeNew
                    }; // 2

                    if (Math.abs(_newPointRate.right - oldPointRate.right) > EPSILON) {
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 - 1,
                            col: oldCol * 2
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2,
                            col: oldCol * 2
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 + 1,
                            col: oldCol * 2
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 + 1,
                            col: oldCol * 2 - 1
                        });
                    }
                } else if (oldPiece.width === 512) {
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: oldRow * 2 - 1,
                        col: oldCol * 2
                    });
                    var _bigSizeNew2 = this.config.tile_size[oldLevel + 1];

                    var _pieceCountNew2 = Math.ceil(_bigSizeNew2 / 512);

                    var _sideSizeNew2 = _bigSizeNew2 % 512 ? _bigSizeNew2 % 512 : 512;

                    var _newSize2 = this.getCurrentPieceFourPoint(_pieceCountNew2, oldRow * 2 - 1, oldCol * 2, _sideSizeNew2);

                    var _newPointRate2 = {
                        top: _newSize2.top / _bigSizeNew2,
                        left: _newSize2.left / _bigSizeNew2,
                        right: _newSize2.right / _bigSizeNew2,
                        bottom: _newSize2.bottom / _bigSizeNew2
                    }; // 2

                    if (Math.abs(_newPointRate2.bottom - oldPointRate.bottom) > EPSILON) {
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2 - 1,
                            col: oldCol * 2 + 1
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2,
                            col: oldCol * 2 + 1
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2,
                            col: oldCol * 2
                        });
                        newPiecesInfo.push({
                            level: level,
                            face: face,
                            row: oldRow * 2,
                            col: oldCol * 2 - 1
                        });
                    }
                } else {
                    // console.log('level:', this.config.levels);
                    // 
                    newPiecesInfo.push({
                        level: level,
                        face: face,
                        row: this.config.levels[level - 1],
                        col: this.config.levels[level - 1]
                    });
                }

                var loadedCount = 0;

                var check = function check() {
                    loadedCount++;

                    if (loadedCount === newPiecesInfo.length) {
                        setTimeout(function () {
                            oldPiece.dispose();

                            if (_this3.pieces[oldLevel] && _this3.pieces[oldLevel][face] && _this3.pieces[oldLevel][face][oldRow] && _this3.pieces[oldLevel][face][oldRow] && _this3.pieces[oldLevel][face][oldRow][oldCol]) {
                                _this3.pieces[oldLevel][face][oldRow][oldCol] = null;
                            }
                        }, 0);
                    }
                };

                var max = this.config.levels[level - 1];
                var item = null;

                for (var i = 0, ii = newPiecesInfo.length; i < ii; ++i) {
                    item = newPiecesInfo[i];

                    if (item.row > max || item.col > max) {
                        newPiecesInfo.splice(i, 1);
                        i--;
                        ii--;
                        continue;
                    }

                    var newPiece = this.pieces[item.level] || {};
                    newPiece = newPiece[item.face] || {};
                    newPiece = newPiece[item.row] || {};
                    newPiece = newPiece[item.col] || undefined;

                    if (newPiece) {
                        if (newPiece.isFailed) {
                            newPiece.load();
                        } else {
                            check();
                        }
                    } else {
                        if (item.col !== undefined && item.row !== undefined) {
                            var piece = this.showPieceByXY(item.level, item.face, item.row, item.col);
                            piece.on(EVENT_INT.TILE_LOAD, check);
                        }
                    }
                }

                oldPiece.hasReplace = true;
            } // 
            ;

            _proto2.showPieceByXY = function showPieceByXY(level, face, row, col) {
                var _this4 = this;

                var suffix;

                if (this.config.tile_file.indexOf('.jpg') > 0) {
                    suffix = '.jpg';
                } else if (this.config.tile_file.indexOf('.jpeg') > 0) {
                    suffix = '.jpeg';
                } else {
                    suffix = '.png';
                }

                var needZero = this.config.tile_file.indexOf('0') > -1;
                var tmpRow = needZero ? row < 10 ? '0' + row : row : row;
                var tmpCol = needZero ? col < 10 ? '0' + col : col : col;
                var imageName = "l" + level + "_" + face + "_" + tmpRow + "_" + tmpCol + suffix;
                var url = "" + this.config.tile_path + face + "/l" + level + "/" + tmpRow + "/" + imageName; // Maximum 120

                var piece = new MeshPiece(this, level, face, row, col, url);
                piece.addEventListener(EVENT_INT.DISPLAY_LOAD_ERROR, function () {
                    _this4.dispatchEvent({
                        type: EVENT_INT.TILE_IMAGE_ERROR,
                        piece: piece,
                        error: url + ' is failed.'
                    }); // // 
                    // if (isFirst && !this.firstFall) {
                    //     this.firstFall = true;
                    //     this.dispatchEvent({type: EVENT_INT.TILE_INIT_ERROR, piece, error: url + ' is failed.'});
                    // } else {
                    //     this.dispatchEvent({type: EVENT_INT.TILE_IMAGE_ERROR, piece, error: url + ' is failed.'});
                    // }

                });

                if (!this.pieces[level]) {
                    this.pieces[level] = {};
                }

                if (!this.pieces[level][face]) {
                    this.pieces[level][face] = [];
                }

                if (!this.pieces[level][face][row]) {
                    this.pieces[level][face][row] = [];
                }

                this.pieces[level][face][row][col] = piece;
                return piece;
            } // levelevel1
            ;

            _proto2.showAllLevelPieces = function showAllLevelPieces(level) {
                var _this5 = this;

                var count = this.config.levels[level - 1];
                var allCount = count * count * 6;
                var finishedCount = 0;

                var listen = function listen() {
                    finishedCount++;

                    _this5.viewer.dispatchEvent({
                        type: EVENT.SCENE_LOADING,
                        progress: finishedCount / allCount
                    });

                    if (finishedCount === allCount) {
                        _this5.viewer.dispatchEvent({
                            type: EVENT_INT.LEVEL_LOADED,
                            sceneId: _this5.scene.sceneId
                        });

                        _this5.scene.initLevelLoaded();
                    }
                }; // krpano1


                for (var _iterator4 = _createForOfIteratorHelperLoose(FACE_ARR), _step4; !(_step4 = _iterator4()).done;) {
                    var item = _step4.value;

                    for (var i = 1; i <= count; i++) {
                        for (var j = 1; j <= count; j++) {
                            var piece = this.showPieceByXY(level, item, i, j, true);
                            piece.on(EVENT_INT.TILE_LOAD, listen);
                        }
                    }
                }
            } // hydreigonhydreigon
            ;

            _proto2.forceShowPiece = function forceShowPiece() {
                var _this6 = this;

                this.viewer.off(EVENT.CAMERA_CHANGE, this.checkMeshLevel);
                this.viewer.on(EVENT.CAMERA_CHANGE, this.checkMeshLevel);

                for (var _iterator5 = _createForOfIteratorHelperLoose(this.piecesNotInScene), _step5; !(_step5 = _iterator5()).done;) {
                    var item = _step5.value;
                    this.display.add(item.mesh);

                    this.viewer.story.currentScene._bindEvent(item.mesh);
                } // Fixme


                setTimeout(function () {
                    _this6.checkMeshLevel();
                }, 0);
                this.piecesNotInScene = [];
                this.viewer.enterAnimationFinished = true;
            };

            _proto2.show = function show() {
                this.visible = true;
            };

            _proto2.hide = function hide() {
                this.visible = false;
            };

            _proto2.dispose = function dispose() {
                this.clearSubscribers();
                this.piecesNotInScene.forEach(function (piece) {
                    piece.dispose();
                });
                this.piecesNotInScene = [];

                try {
                    if (this.pieces) {
                        for (var l in this.pieces) {
                            for (var f in this.pieces[l]) {
                                for (var r = 0; r < ((_this$pieces$l$f = this.pieces[l][f]) === null || _this$pieces$l$f === void 0 ? void 0 : _this$pieces$l$f.length); r++) {
                                    var _this$pieces$l$f;

                                    for (var c = 0; c < ((_this$pieces$l$f$r = this.pieces[l][f][r]) === null || _this$pieces$l$f$r === void 0 ? void 0 : _this$pieces$l$f$r.length); c++) {
                                        var _this$pieces$l$f$r, _this$pieces$l$f$r$c;

                                        (_this$pieces$l$f$r$c = this.pieces[l][f][r][c]) === null || _this$pieces$l$f$r$c === void 0 ? void 0 : _this$pieces$l$f$r$c.dispose();
                                        this.pieces[l][f][r][c] = null;
                                    }
                                }
                            }
                        }

                        this.pieces = null;
                    }
                } catch (e) {
                    console.error('recycle failed, eroor info is' + e);
                }

                if (this.outCube) {
                    this.outCube.off(EVENT_INT.CANVAS_DRAWN);
                    this.outCube.dispose();
                    this.outCube = null;
                }

                if (this.display) {
                    if (this.display.parent) {
                        this.display.parent.remove(this.display);
                    }

                    if (this.display.children && this.display.children instanceof Array) {
                        this.display.children.forEach(function (mesh) {
                            if (mesh.material instanceof Array) {
                                mesh.material.forEach(function (material) {
                                    material.map.dispose();
                                    material.map = null;
                                    material.dispose();
                                    material = null;
                                });
                            } else {
                                if (mesh.material && mesh.material.map) {
                                    mesh.material.map.dispose();
                                    mesh.material.map = null;
                                    mesh.material.dispose();
                                    mesh.material = null;
                                }
                            }

                            if (mesh.geometry) {
                                mesh.geometry.dispose();
                                mesh.geometry = null;
                            }
                        });
                        this.display.children = [];
                    }

                    this.display = null;
                }
            };

            return Multires;
        }(Display);

        var _Promise$2 = typeof Promise === 'undefined' ? es6Promise.Promise : Promise;
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.font = 'normal 24px PingFangSC-Regular';
        function drawTipString(text) {
            ctx.font = 'normal 20px PingFangSC-Regular';
            var width = ctx.measureText(text).width;
            canvas.height = 40;
            canvas.width = 32 + width;
            ctx.clearRect(0, 0, canvas.width, canvas.width);
            drawRoundRect(0, 0, canvas.width, canvas.height, 6);
            ctx.fillStyle = 'white';
            ctx.font = 'normal 20px PingFangSC-Regular';
            ctx.fillText(text, 16, 27);
            return canvas;
        }
        function drawRoundRect(x, y, w, h, r) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';

            if (w < 2 * r) {
                r = w / 2;
            }

            if (h < 2 * r) {
                r = h / 2;
            }

            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();
            return ctx;
        }

        function setCSS(dom, css) {
            for (var key in css) {
                dom.style[key] = css[key];
            }
        }
        var convertToRadArr = function convertToRadArr(arr) {
            return [Object3DProxy.degToRad(arr[0]), Object3DProxy.degToRad(arr[1])];
        };

        var DOM_TYPE = {
            LINK: 0,
            LABEL: 1
        };
        var tipsStyle = {
            padding: '0 8px',
            position: 'absolute',
            'font-family': 'PingFangSC-Regular',
            'font-size': '12px',
            color: '#333',
            'letter-spacing': 0,
            'line-height': '22px',
            background: '#FFF',
            border: '1px solid #CCC',
            'border-radius': '3px',
            'box-shadow': '0 4px 8px 0 rgba(0,0,0,0.10), 0 8px 16px 0 rgba(0,0,0,0.05)',
            'white-space': 'nowrap',
            top: 0,
            transform: 'translateY(calc(-100% - 13px)',
            display: 'none'
        };
        var arrowStyle = {
            position: 'absolute',
            width: 0,
            height: 0,
            'border-top': '6px solid #fff',
            'border-right': '6px solid transparent',
            'border-left': '6px solid transparent',
            top: 'calc(100% - 1px)',
            left: '23px'
        };

        var HotspotDom = /*#__PURE__*/function (_Display) {
            _inheritsLoose(HotspotDom, _Display);

            function HotspotDom(viewer, manager, config, mode) {
                var _this;

                if (mode === void 0) {
                    mode = SDK_MODE.SHOW;
                }

                _this = _Display.call(this, viewer) || this;
                _this.type = HOTSPOT_TYPE.DOM;
                _this.viewer = null;
                _this.manager = null;
                _this.config = null;
                _this.id = null;
                _this.display = null;
                _this.domContainer = null;
                _this.mode = null;
                _this.deltaX = 0;
                _this.deltaY = 0;
                _this.canvas = document.createElement('canvas');
                _this.domImage = new Image();
                _this.vect = Object3DProxy.newVector3();
                _this.domOpacity = 0;
                _this.domShowed = false;
                _this.dP = Object3DProxy.newVector2(0, 0);
                _this.offsetX = 0;
                _this.offsetY = 0;
                _this.tf = 15;

                _this.setDomType = function (type) {
                    _this.domType = type;

                    if (_this.domType === DOM_TYPE.LINK) {
                        _this.offsetX = -28;
                        _this.offsetY = -28;
                        _this.scalar = HOTSPOT_OPTIONS.LINK_RAY_LENGTH;
                    } else {
                        _this.offsetX = 0;
                        _this.offsetY = 0;
                        _this.scalar = HOTSPOT_OPTIONS.LABEL_RAY_LENGTH;
                    }
                };

                _this.start = function () {
                    _this.initObject3D();

                    _this.initDomContainer();

                    _this.initTip();

                    _this.bindEvent();
                };

                _this.reset = function () {
                    _this.manager.domHSContainer.appendChild(_this.domContainer);

                    _this.domOpacity = 0;
                };

                _this.bindEvent = function () {
                    if (_this.mode === SDK_MODE.EDIT) {
                        _this.domContainer.addEventListener('mousedown', _this.onMouseDown);

                        _this.domContainer.addEventListener('mouseover', _this.onMouseOver);

                        _this.domContainer.addEventListener('mouseout', _this.onDomMouseOut);

                        _this.viewer.container.addEventListener('mousemove', _this.onMouseMove);

                        _this.viewer.container.addEventListener('mouseup', _this.onMouseUp);

                        _this.viewer.container.addEventListener('mouseleave', _this.onMouseLeave);
                    }
                };

                _this.onMouseOver = function (event) {
                    if (_this.selected) {
                        return;
                    }

                    if (!_this.viewer.story.enableDrag) {
                        return;
                    }

                    _this.tips.style.display = 'block';
                };

                _this.onMouseDown = function (event) {
                    if (!_this.viewer.story.enableDrag) {
                        return;
                    } // console.log('mouse down');


                    _this.tips.style.display = 'none';
                    _this.selected = true;
                    _this.domContainerRect = _this.domContainer.getBoundingClientRect();
                    _this.deltaX = event.clientX - _this.domContainerRect.left + _this.offsetX;
                    _this.deltaY = event.clientY - _this.domContainerRect.top + _this.offsetY;
                    _this.domContainer.style.cursor = 'move';

                    _this.viewer.controllerManager.switchDragControls(false);

                    _this.manager.selectHotspot(_this.id, true);
                };

                _this.onMouseMove = function (event) {
                    if (!_this.viewer.story.enableDrag) {
                        return;
                    } // console.log('mouse move', this.selected);


                    if (!_this.selected) {
                        return;
                    }

                    if (!_this.mouse) {
                        _this.mouse = Object3DProxy.newVector2();
                    }

                    _this.mouse.x = (event.clientX - _this.viewer.containerRect.left - _this.deltaX) / _this.viewer.container.offsetWidth * 2 - 1;
                    _this.mouse.y = -((event.clientY - _this.viewer.containerRect.top - _this.deltaY) / _this.viewer.container.offsetHeight) * 2 + 1;

                    var ray = _this.manager.getRay(_this.mouse).ray;

                    var _ray$direction$multip = ray.direction.multiplyScalar(_this.scalar),
                        x = _ray$direction$multip.x,
                        y = _ray$direction$multip.y,
                        z = _ray$direction$multip.z;

                    _this.display.position.set(x, y, z);

                    _this.viewer.controllerManager.switchDragControls(true);

                    _this.updated = true;

                    _this.setDomPosition();
                };

                _this.onDomMouseOut = function () {
                    // this.onMouseUp();
                    _this.tips.style.display = 'none';
                };

                _this.onMouseUp = function () {
                    if (!_this.viewer.story.enableDrag) {
                        return;
                    } // console.log('mouse up');


                    _this.selected = false;
                    _this.domContainer.style.cursor = 'auto';

                    _this.viewer.controllerManager.switchDragControls(true);

                    if (!_this.updated) {
                        return;
                    } // this.manager.unSelectHotspot();


                    var _this$display$positio = _this.display.position,
                        x = _this$display$positio.x,
                        y = _this$display$positio.y,
                        z = _this$display$positio.z;

                    var hotspotInfo = _objectSpread2(_objectSpread2({}, _this.config), {}, {
                        pos: {
                            x: x,
                            y: y,
                            z: z
                        }
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_UPDATE,
                        sceneId: _this.manager.scene.sceneId,
                        hotspotId: _this.id,
                        hotspot: hotspotInfo
                    });

                    _this.updated = false;
                    _this.tips.style.display = 'block';
                };

                _this.onMouseLeave = function () {
                    // console.log('mouse leave');
                    _this.selected = false;
                    _this.domContainer.style.cursor = 'auto';

                    _this.viewer.controllerManager.switchDragControls(true);

                    if (!_this.updated) {
                        return;
                    }

                    var _this$display$positio2 = _this.display.position,
                        x = _this$display$positio2.x,
                        y = _this$display$positio2.y,
                        z = _this$display$positio2.z;

                    var hotspotInfo = _objectSpread2(_objectSpread2({}, _this.config), {}, {
                        pos: {
                            x: x,
                            y: y,
                            z: z
                        }
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_UPDATE,
                        sceneId: _this.manager.scene.sceneId,
                        hotspotId: _this.id,
                        hotspot: hotspotInfo
                    });
                };

                _this.domSpringPosition = function () {
                    var _this$manager$worldTo = _this.manager.worldToScreen(_this.display),
                        x = _this$manager$worldTo.x,
                        y = _this$manager$worldTo.y;

                    if (isNaN(x) || isNaN(y)) {
                        return;
                    }

                    if (!_this.sP) {
                        _this.sP = Object3DProxy.newVector2(x, y);
                    }

                    _this.dP.set(x, y);

                    var cX = (_this.dP.x - _this.sP.x) / _this.tf + _this.sP.x;
                    var cY = (_this.dP.y - _this.sP.y) / _this.tf + _this.sP.y;
                    _this.domContainer.style.transform = "translate(" + (x + _this.offsetX) + "px, " + (y + _this.offsetY) + "px)translateZ(0)";

                    _this.sP.set(cX, cY);
                };

                _this.viewer = viewer;
                _this.manager = manager;
                _this.config = config;
                _this.mode = mode;
                _this.id = config.id;

                _this.start();

                return _this;
            }

            var _proto = HotspotDom.prototype;

            _proto.initObject3D = function initObject3D() {
                this.display = Object3DProxy.newObject3D();
                this.display.visable = false;
                var _this$config$pos = this.config.pos,
                    x = _this$config$pos.x,
                    y = _this$config$pos.y,
                    z = _this$config$pos.z;
                this.display.position.set(x, y, z);
            };

            _proto.initDomContainer = function initDomContainer() {
                this.domContainer = document.createElement('div');
                this.domContainer.style.position = 'absolute';
                this.domContainer.style.alignItems = 'center';
                this.domContainer.style.opacity = '0';

                this._hide();

                this.manager.domHSContainer.appendChild(this.domContainer);
            };

            _proto.initTip = function initTip() {
                this.tips = document.createElement('div');
                this.arrow = document.createElement('span');
                this.tips.innerText = '';
                setCSS(this.tips, tipsStyle);
                setCSS(this.arrow, arrowStyle);
                this.tips.appendChild(this.arrow);
                this.domContainer.appendChild(this.tips);
            };

            _proto._show = function _show() {// 
            };

            _proto._hide = function _hide() {
                this.domContainer.style.display = 'none';
                this.domShowed = false;
            };

            _proto.setDomPosition = function setDomPosition() {
                var _this$manager$worldTo2 = this.manager.worldToScreen(this.display),
                    x = _this$manager$worldTo2.x,
                    y = _this$manager$worldTo2.y;

                this.offsetY = -this.domContainer.offsetHeight / 2;
                this.domContainer.style.transform = "translate(" + (x + this.offsetX) + "px, " + (y + this.offsetY) + "px)translateZ(0)";

                if (!this.sP) {
                    this.sP = Object3DProxy.newVector2(x, y);
                } else {
                    this.sP.set(x, y);
                }
            };

            _proto._update = function _update() {
                var pos = this.display.position;
                this.manager.scene.camera.getWorldDirection(this.vect);

                if (pos.angleTo(this.vect) < Math.PI / 2) {
                    if (this.viewer.controllerManager.rotating) {
                        this.domSpringPosition();
                    } else {
                        this.setDomPosition();
                    }

                    if (!this.domShowed) {
                        this.domContainer.style.display = 'flex';
                    }

                    this.domOpacity = Math.min(1, this.domOpacity + 0.035);

                    if (this.domOpacity < 1) {
                        this.domContainer.style.opacity = "" + this.domOpacity;
                    }
                } else {
                    this._hide();

                    this.domOpacity = 0;
                    this.domContainer.style.opacity = "" + this.domOpacity;
                }
            };

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }
            };

            return HotspotDom;
        }(Display);

        var urlPrefix = 'https://hydreigon-publish.cdn.bcebos.com/sdk-static%2Fpano%2Ficons%2F';
        var iconStyle = {
            width: '56px',
            height: '56px',
            'user-select': 'none'
        };
        var nameStyle = {
            background: 'rgba(0,0,0,0.6)',
            'margin-left': '8px',
            'font-family': 'PingFangSC-Regular',
            'font-size': '12px',
            color: '#FFF',
            'letter-spacing': 0,
            'line-height': '22px',
            padding: '6px 8px',
            width: 'max-content',
            'max-width': '160px',
            'word-break': 'break-word',
            'user-select': 'none',
            'border-radius': '3px'
        };

        var SceneLink2D = /*#__PURE__*/function (_HotspotDom) {
            _inheritsLoose(SceneLink2D, _HotspotDom);

            function SceneLink2D(viewer, manager, _config) {
                var _this;

                _this = _HotspotDom.call(this, viewer, manager, _config, SDK_MODE.EDIT) || this;

                _this.loadConfig = function (config) {
                    _this.config = config;
                };

                _this.createIcon = function () {
                    _this.icon = document.createElement('img');
                    _this.icon.src = urlPrefix + (_this.config.type === 'video' ? 'hs-video.svg' : "e-" + _this.config.className + "-nor.svg");
                    _this.icon.draggable = false;
                    setCSS(_this.icon, iconStyle);

                    _this.domContainer.appendChild(_this.icon);
                };

                _this.createLabel = function () {
                    _this.text = document.createElement('span');
                    _this.text.innerText = _this.config.name;
                    setCSS(_this.text, nameStyle);

                    _this.domContainer.appendChild(_this.text);
                };

                _this.selectHotspot = function () {
                    _this.icon.src = urlPrefix + (_this.config.type === 'video' ? 'hs-video-h.svg' : "e-" + _this.config.className + "-active.svg");
                    _this.domContainer.style.zIndex = '1';
                };

                _this.unSelectHotspot = function () {
                    _this.icon.src = urlPrefix + (_this.config.type === 'video' ? 'hs-video.svg' : "e-" + _this.config.className + "-nor.svg");
                    _this.domContainer.style.zIndex = '0';
                };

                _this.init();

                return _this;
            }

            var _proto = SceneLink2D.prototype;

            _proto.init = function init() {
                this.createIcon();
                this.createLabel();
                this.setDomType(DOM_TYPE.LINK);
            };

            _proto.show = function show() {
                this._show();
            };

            _proto.hide = function hide() {
                this._hide();
            };

            _proto.update = function update() {
                this._update();
            };

            _proto.dispose = function dispose() {
                _HotspotDom.prototype.dispose.call(this);
            };

            return SceneLink2D;
        }(HotspotDom);

        var ResourceType;
        (function (ResourceType) {
            ResourceType["PANO"] = "pano";
            ResourceType["SPIN"] = "spin";
            ResourceType["PANOVIDEO"] = "panovideo";
            ResourceType["DEPTHPANO"] = "depthpano";
        })(ResourceType || (ResourceType = {}));
        var RenderType;
        (function (RenderType) {
            RenderType["CUBE"] = "cube";
            RenderType["SPHERE"] = "sphere";
            RenderType["CUBE_LIST"] = "cube-list";
            RenderType["CUBE_MULTI"] = "cube-multi";
        })(RenderType || (RenderType = {}));

        // permission code
        var PanoCode;
        (function (PanoCode) {
            // render_type
            PanoCode[PanoCode["RT_CUBE_MULTI"] = 1001] = "RT_CUBE_MULTI";
            PanoCode[PanoCode["RT_CUBE_LIST"] = 1002] = "RT_CUBE_LIST";
            PanoCode[PanoCode["RT_CUBE"] = 1003] = "RT_CUBE";
            PanoCode[PanoCode["RT_SPHERE"] = 1004] = "RT_SPHERE";
            // interactions
            PanoCode[PanoCode["IX_DRAG"] = 1101] = "IX_DRAG";
            PanoCode[PanoCode["IX_GYRO"] = 1102] = "IX_GYRO";
            // hotSpot
            PanoCode[PanoCode["HS_2DHospot"] = 1201] = "HS_2DHospot";
            // config
            PanoCode[PanoCode["CF_UPDATE"] = 1301] = "CF_UPDATE";
            //animation
            PanoCode[PanoCode["AN_CUSTOMIZE"] = 1401] = "AN_CUSTOMIZE";
            PanoCode[PanoCode["AN_DEFAULT"] = 1402] = "AN_DEFAULT";
        })(PanoCode || (PanoCode = {}));
        var PanoVideoCode;
        (function (PanoVideoCode) {
            // render_type
            PanoVideoCode[PanoVideoCode["RT_SPHERE"] = 2001] = "RT_SPHERE";
            // interactions
            PanoVideoCode[PanoVideoCode["IX_DRAG"] = 2101] = "IX_DRAG";
            PanoVideoCode[PanoVideoCode["IX_GYRO"] = 2102] = "IX_GYRO";
            // hotSpot
            PanoVideoCode[PanoVideoCode["HS_2DHoSpot"] = 2201] = "HS_2DHoSpot";
            // config
            PanoVideoCode[PanoVideoCode["CF_UPDATE"] = 2301] = "CF_UPDATE";
            //animation
            PanoVideoCode[PanoVideoCode["AN_CUSTOMIZE"] = 2401] = "AN_CUSTOMIZE";
            PanoVideoCode[PanoVideoCode["AN_DEFAULT"] = 2402] = "AN_DEFAULT";
        })(PanoVideoCode || (PanoVideoCode = {}));
        var SpinCode;
        (function (SpinCode) {
            // render_type
            SpinCode[SpinCode["RT_CUBE_MULTI"] = 3001] = "RT_CUBE_MULTI";
            SpinCode[SpinCode["RT_RAW"] = 3002] = "RT_RAW";
            // interactions
            SpinCode[SpinCode["IX_DRAG"] = 3101] = "IX_DRAG";
            // hotSpot
            SpinCode[SpinCode["HS_2DHoSpot"] = 3201] = "HS_2DHoSpot";
            // config
            SpinCode[SpinCode["CF_UPDATE"] = 3301] = "CF_UPDATE";
            //animation
            SpinCode[SpinCode["AN_CUSTOMIZE"] = 3401] = "AN_CUSTOMIZE";
            SpinCode[SpinCode["AN_DEFAULT"] = 3402] = "AN_DEFAULT";
        })(SpinCode || (SpinCode = {}));
        var ModelCode;
        (function (ModelCode) {
            // render_type
            ModelCode[ModelCode["RT_OBJ"] = 4001] = "RT_OBJ";
            ModelCode[ModelCode["RT_GLTF"] = 4002] = "RT_GLTF";
            // interactions
            ModelCode[ModelCode["IX_DRAG"] = 4101] = "IX_DRAG";
            //animation
            ModelCode[ModelCode["AN_CUSTOMIZE"] = 4201] = "AN_CUSTOMIZE";
            ModelCode[ModelCode["AN_DEFAULT"] = 4202] = "AN_DEFAULT";
        })(ModelCode || (ModelCode = {}));

        class AuthenticationUtil {
            static checkCode(authentication, code) {
                return !!authentication ? authentication.hasPermission(code) : false;
            }
            // pano
            static checkPanoRenderType(authentication, config) {
                var _a;
                let code = 0;
                switch ((_a = config === null || config === void 0 ? void 0 : config.vrResource) === null || _a === void 0 ? void 0 : _a.render_type) {
                    case RenderType.CUBE: {
                        code = PanoCode.RT_CUBE;
                        break;
                    }
                    case RenderType.SPHERE: {
                        code = PanoCode.RT_SPHERE;
                        break;
                    }
                    case RenderType.CUBE_LIST: {
                        code = PanoCode.RT_CUBE_LIST;
                        break;
                    }
                    case RenderType.CUBE_MULTI: {
                        code = PanoCode.RT_CUBE_MULTI;
                        break;
                    }
                }
                if (authentication && code) {
                    return authentication.hasPermission(code);
                }
                else {
                    return false;
                }
            }
            // spin
            static checkSpinRenderType(authentication, config) {
                var _a;
                let code = 0;
                switch ((_a = config === null || config === void 0 ? void 0 : config.vrResource) === null || _a === void 0 ? void 0 : _a.render_type) {
                    case RenderType.SPHERE: {
                        // code = SpinCode.RT_RAW;
                        code = SpinCode.RT_CUBE_MULTI;
                        break;
                    }
                    case RenderType.CUBE_MULTI: {
                        code = SpinCode.RT_CUBE_MULTI;
                        break;
                    }
                }
                if (authentication && code) {
                    return authentication.hasPermission(code);
                }
                else {
                    return false;
                }
            }
            // panoVideo
            // model
            static checkModelRenderType(authentication, config) {
                let code = 0;
                if ((config === null || config === void 0 ? void 0 : config.render_type) === 'obj') {
                    code = ModelCode.RT_OBJ;
                }
                else if ((config === null || config === void 0 ? void 0 : config.render_type) === 'gltf') {
                    code = ModelCode.RT_GLTF;
                }
                else {
                    console.log('the render type of model is not supported presently;');
                    code = 0;
                }
                if (authentication && code) {
                    return authentication.hasPermission(code);
                }
                else {
                    return false;
                }
            }
        }

        var Hotspot3D = /*#__PURE__*/function (_Display) {
            _inheritsLoose(Hotspot3D, _Display);

            function Hotspot3D(viewer, config) {
                var _manager$viewer;

                var _this;

                if (!AuthenticationUtil.checkCode((_manager$viewer = manager.viewer) === null || _manager$viewer === void 0 ? void 0 : _manager$viewer.authentication, PanoCode.HS_2DHospot)) {
                    return _assertThisInitialized(_this);
                }

                _this = _Display.call(this, viewer) || this;
                _this.type = HOTSPOT_TYPE.THEED_D;
                _this.id = null;
                _this.viewer = null;
                _this.config = null;
                _this.display = null;

                _this._init = function () {
                    _this.display = Object3DProxy.newMesh();
                    _this.display.rotation.order = 'YXZ';
                    _this.display.visible = false;
                };

                _this.initGeometry = function (type, options) {
                    var _this$viewer;

                    if (options === void 0) {
                        options = {};
                    }

                    if (!AuthenticationUtil.checkCode((_this$viewer = _this.viewer) === null || _this$viewer === void 0 ? void 0 : _this$viewer.authentication, PanoCode.HS_2DHospot)) {
                        return;
                    }

                    _this.display.geometry = Object3DProxy.newPlane(options);
                };

                _this.initMaterial = function (source) {
                    var _this$viewer2;

                    console.log(source);

                    if (!AuthenticationUtil.checkCode((_this$viewer2 = _this.viewer) === null || _this$viewer2 === void 0 ? void 0 : _this$viewer2.authentication, PanoCode.HS_2DHospot)) {
                        return;
                    }

                    _this.viewer.loader.loadImage(source).then(function (texture) {
                        _this.display.material = Object3DProxy.newMeshBasicMaterial({
                            map: texture
                        });
                        Object3DProxy.setMaterialFilter(_this.display.material);
                        _this.display.material.transparent = true;
                    });
                };

                _this.getPosition = function () {
                    return _this.display.position;
                };

                _this.setPosition = function (position) {
                    _this.display.position.set(position.x, position.y, position.z);

                    _this.display.lookAt(0, 0, 0);
                };

                _this.getRotation = function () {
                    return _this.display.rotation;
                };

                _this.setRotation = function (rotation) {
                    _this.display.rotation.set(rotation.x, rotation.y, rotation.z);
                };

                _this.getScale = function () {
                    return _this.display.scale;
                };

                _this.setScale = function (scale) {
                    _this.display.scale.set(scale.x, scale.y, scale.z);
                };

                _this.viewer = viewer;
                _this.config = config;
                _this.id = config.id;

                _this._init();

                return _this;
            }

            var _proto = Hotspot3D.prototype;

            _proto.show = function show() {
                this.display.visible = true;
            };

            _proto.hide = function hide() {
                this.display.visible = false;
            };

            _proto.selectHotspot = function selectHotspot() {};

            _proto.unSelectHotspot = function unSelectHotspot() {};

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }

                this.display.material.map.dispose();
                this.display.material.dispose();
                this.display.geometry.dispose();
                this.display.material.map = undefined;
                this.display.material = undefined;
                this.display.geometry = undefined;
            };

            return Hotspot3D;
        }(Display);

        var Mask = /*#__PURE__*/function (_Hotspot3D) {
            _inheritsLoose(Mask, _Hotspot3D);

            function Mask(viewer, scene, _config) {
                var _this;

                _this = _Hotspot3D.call(this, viewer, _config) || this;

                _this.loadConfig = function (config) {
                    _this.config = config;

                    _this.initMaterial(_this.config.image);

                    _this.setPosition(_this.config.pos);

                    _this.initMaskOrigin();
                };

                _this.initMaskOrigin = function () {
                    var y = _this.scene.config.rotation.y;

                    if (!_this.config.fixDirection) {
                        y += Object3DProxy.degToRad(_this.config.origin || 0);
                    }

                    console.log(_this.getRotation.x);
                    _this.down = _this.config.pos.y < 0 ? -1 : 1;
                    _this.initX = Math.PI / 2 * _this.down;
                    _this.initY = y;
                    console.log(_this.initX);

                    _this.setRotation({
                        x: _this.initX,
                        y: y,
                        z: 0
                    });
                };

                _this.scene = scene;

                _this.initGeometry();

                _this.loadConfig(_config);

                return _this;
            }

            var _proto = Mask.prototype;

            _proto.update = function update() {
                if (this.config.fixDirection && this.viewer.controllerManager.camera) {
                    var cameraY = this.viewer.controllerManager.camera.rotation.y;
                    var deltaY = cameraY - this.scene.config.rotation.y;
                    var rotation = {
                        x: this.initX,
                        y: this.initY + deltaY,
                        z: 0
                    };
                    this.setRotation(rotation);
                }
            };

            _proto.dispose = function dispose() {
                _Hotspot3D.prototype.dispose.call(this);
            };

            return Mask;
        }(Hotspot3D);

        var labelCss = {
            height: '24px',
            width: '24px',
            display: 'inline-block',
            'background-image': 'url(https://hydreigon-dev.bj.bcebos.com/sdk-dev%2Fdist%2Fassets%2Fpano%2Flable-icon.svg)',
            'border-radius': '50%',
            'background-size': 'cover'
        };
        var textCss = {
            width: 'max-content',
            'max-width': '140px',
            'user-select': 'none',
            'border-color': '#fff',
            'border-width': '2px',
            'border-style': 'solid',
            'box-sizing': 'border-box',
            position: 'relative',
            'font-family': 'PingFangSC-Regular',
            'font-size': '12px',
            color: '#333',
            'letter-spacing': 0,
            'line-height': '22px',
            padding: '4px 8px',
            background: '#fff',
            'border-radius': '3px',
            'margin-left': '9px',
            'word-break': 'break-word'
        };
        var span1Css = {
            position: 'absolute',
            top: '50%',
            transform: 'translate(-100%, -50%)',
            left: '0px',
            'border-color': 'transparent #fff transparent transparent',
            'border-width': '7px',
            'border-style': 'solid'
        };
        var span2Css = {
            position: 'absolute',
            top: '50%',
            transform: 'translate(-100%, -50%)',
            left: '2px',
            'border-color': 'transparent #fff transparent transparent',
            'border-width': '7px',
            'border-style': 'solid'
        };

        var Label = /*#__PURE__*/function (_HotspotDom) {
            _inheritsLoose(Label, _HotspotDom);

            function Label(viewer, manager, _config, mode) {
                var _this;

                _this = _HotspotDom.call(this, viewer, manager, _config, mode) || this;

                _this.loadConfig = function (config) {
                    _this.config = config;
                };

                _this.createCircle = function () {
                    _this.circle = document.createElement('span');
                    setCSS(_this.circle, labelCss);

                    _this.domContainer.appendChild(_this.circle);
                };

                _this.createLabel = function () {
                    _this.text = document.createElement('span');
                    _this.innerSpan1 = document.createElement('span');
                    _this.innerSpan2 = document.createElement('span');
                    _this.text.innerText = _this.config.tip.slice(0, 20);
                    setCSS(_this.text, textCss);
                    setCSS(_this.innerSpan1, span1Css);
                    setCSS(_this.innerSpan2, span2Css);

                    _this.text.appendChild(_this.innerSpan1);

                    _this.text.appendChild(_this.innerSpan2);

                    _this.domContainer.appendChild(_this.text);
                };

                _this.selectHotspot = function () {
                    _this.text.style.borderColor = '#146CE1';
                    _this.innerSpan1.style.borderRightColor = '#146CE1';
                    _this.domContainer.style.zIndex = '1';
                };

                _this.unSelectHotspot = function () {
                    _this.text.style.borderColor = '#fff';
                    _this.innerSpan1.style.borderRightColor = '#fff';
                    _this.domContainer.style.zIndex = '0';
                };

                _this.id = _config.id;
                _this.hasDrawDom = false;

                _this.init();

                return _this;
            }

            var _proto = Label.prototype;

            _proto.init = function init() {
                this.createCircle();
                this.createLabel();
                this.bindEvent();
                this.setDomType(DOM_TYPE.LABEL);
            };

            _proto.show = function show() {
                this._show();
            };

            _proto.hide = function hide() {
                this._hide();
            };

            _proto.update = function update() {
                this._update();
            };

            _proto.dispose = function dispose() {
                _HotspotDom.prototype.dispose.call(this);
            };

            return Label;
        }(HotspotDom);

        var TipSprite = /*#__PURE__*/function (_Hotspot3D) {
            _inheritsLoose(TipSprite, _Hotspot3D);

            function TipSprite(viewer, _config, parent) {
                var _this;

                _this = _Hotspot3D.call(this, viewer, _config) || this;

                _this.loadConfig = function (config) {
                    _this.config = config;
                    var canvas = drawTipString(config.name.slice(0, 10));
                    var texture = new Object3DProxy.TextureLoader().load(canvas.toDataURL());
                    texture.wrapS = texture.wrapT = Object3DProxy.ClampToEdgeWrapping;
                    texture.magFilter = Object3DProxy.LinearFilter;
                    texture.minFilter = Object3DProxy.LinearFilter;
                    var material = Object3DProxy.newSpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    material.opacity = 0;
                    _this.display = Object3DProxy.newSprite(material);

                    _this.display.scale.set(canvas.width / 80, canvas.height / 80, 1);

                    _this.display.position.set(0, 0.85, 0);

                    _this.parent.display.add(_this.display);
                };

                _this.onClick = function () {
                    var _this$config$target = _this.config.target,
                        id = _this$config$target.id,
                        rotation = _this$config$target.rotation;

                    _this.viewer.switchToScene(id, rotation);
                };

                _this.onHover = function () {
                    _this.viewer.container.style.cursor = 'pointer';
                };

                _this.parent = parent;

                _this.initGeometry(null, {
                    width: 5,
                    height: 5
                });

                _this.loadConfig(_config);

                return _this;
            }

            var _proto = TipSprite.prototype;

            _proto.update = function update() {
                this.display.material.opacity = Math.min(1, this.display.material.opacity + 0.025);
            };

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }

                this.display.material.map.dispose();
                this.display.material.dispose();
                this.display.geometry.dispose();
                this.display.removeEventListener('click', this.onClick);
                this.display.removeEventListener('mouseover', this.onHover);
                this.display.material.map = null;
                this.display.material = null;
                this.display.geometry = null;
                this.display = null;
            };

            return TipSprite;
        }(Hotspot3D);

        var TEXTURE_INFO = {
            col: 35,
            row: 1,
            num: 35,
            frameTime: 33
        };

        var TextureAnimation = /*#__PURE__*/function () {
            function TextureAnimation(texture, tilesHoriz, tilesVert, numTiles, tileDisDuration) {
                this.texture = texture;
                this.tilesHoriz = tilesHoriz;
                this.tilesVert = tilesVert;
                this.numTiles = numTiles;
                this.tileDisDuration = tileDisDuration;
                this.currentDisplayTime = 0;
                this.currentTile = 0;
                this.texture.wrapS = Object3DProxy.RepeatWrapping;
                this.texture.repeat.set(1 / this.tilesHoriz, 1 / this.tilesVert);
            }

            var _proto = TextureAnimation.prototype;

            _proto.update = function update(time) {
                this.currentDisplayTime += time;

                while (this.currentDisplayTime > this.tileDisDuration) {
                    this.currentDisplayTime -= this.tileDisDuration;
                    this.currentTile++;

                    if (this.currentTile === this.numTiles) {
                        this.currentTile = 0;
                    }

                    var currentCol = this.currentTile % this.tilesHoriz;
                    this.texture.offset.x = currentCol / this.tilesHoriz;
                    var currentRow = Math.floor(this.currentTile / this.tilesHoriz);
                    this.texture.offset.y = currentRow / this.tilesVert;
                }
            };

            return TextureAnimation;
        }();

        var HotspotSprite = /*#__PURE__*/function (_Display) {
            _inheritsLoose(HotspotSprite, _Display);

            function HotspotSprite(viewer, manager, _config) {
                var _this;

                _this = _Display.call(this, viewer) || this;
                _this.manager = null;
                _this.config = null;
                _this.display = null;
                _this.anim = null;
                _this.isReady = false;
                _this.showed = false;
                _this.clock = Object3DProxy.newClock();
                _this.vect = Object3DProxy.newVector3();

                _this.loadConfig = function (config) {
                    _this.config = config;

                    _this.init();

                    _this.bindEvent();
                };

                _this.setScale = function (display) {
                    var pos = _this.display.position;

                    _this.manager.scene.camera.getWorldDirection(_this.vect);

                    var dz = Math.cos(pos.angleTo(_this.vect)) * HOTSPOT_OPTIONS.LINK_RAY_LENGTH;
                    var expectH = _this.viewer.container.offsetHeight * 1 / (2 * dz * Math.tan(Object3DProxy.degToRad(_this.manager.scene.camera.fov / 2)));
                    var scale = 50 / expectH; // 50
                    // console.log('scale:', scale);

                    display.scale.set(scale, scale, scale);
                };

                _this.onClick = function () {
                    // console.log('hs-click', this.config.id);
                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_CLICK,
                        hotspotId: _this.config.id,
                        config: _this.config
                    });

                    var _this$config$target = _this.config.target,
                        id = _this$config$target.id,
                        rotation = _this$config$target.rotation;

                    _this.viewer.switchToScene(id, rotation);
                };

                _this.onHover = function () {
                    // console.log('mouse over sprite');
                    _this.viewer.container.style.cursor = 'pointer';
                };

                _this.manager = manager;
                _this.config = _config;

                _this.init();

                _this.bindEvent();

                return _this;
            }

            var _proto2 = HotspotSprite.prototype;

            _proto2.bindEvent = function bindEvent() {
                // console.log('mouse bindevent sprite');
                this.display.removeEventListener('click', this.onClick);
                this.display.removeEventListener('mouseover', this.onHover);
                this.display.addEventListener('click', this.onClick);
                this.display.addEventListener('mouseover', this.onHover);
            };

            _proto2.init = function init() {
                var _this2 = this;

                this.display = Object3DProxy.newSprite();
                this.display.visible = false;
                var url = 'https://hydreigon-publish.cdn.bcebos.com/sdk-static%2Fpano%2Ficons%2F' + this.config.className + '-1.png';
                this.viewer.loader.loadImage(url).then(function (texture) {
                    _this2.anim = new TextureAnimation(texture, TEXTURE_INFO.col, TEXTURE_INFO.row, TEXTURE_INFO.num, TEXTURE_INFO.frameTime);
                    _this2.display.material = Object3DProxy.newSpriteMaterial({
                        map: texture
                    });
                    _this2.display.material.transparent = true;
                    _this2.display.material.opacity = 0;
                    Object3DProxy.setMaterialFilter(_this2.display.material);
                    _this2.isReady = true;
                });
                var _this$config$pos = this.config.pos,
                    x = _this$config$pos.x,
                    y = _this$config$pos.y,
                    z = _this$config$pos.z;
                this.display.position.set(x, y, z);
                this.setScale(this.display);
                this.tip = new TipSprite(this.viewer, this.config, this);
            };

            _proto2.update = function update() {
                if (this.showed && this.isReady) {
                    this.display.visible = true;
                    this.setScale(this.display);
                    this.anim.update(this.clock.getDelta() * 1000);
                    this.display.material.opacity = Math.min(1, this.display.material.opacity + 0.025);
                    this.tip.update();
                } else {
                    this.display.visible = false;
                }
            };

            _proto2.show = function show() {
                this.showed = true;
            };

            _proto2.hide = function hide() {
                this.display.visible = false;
            };

            _proto2.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                }

                this.display.material.map.dispose();
                this.display.material.dispose();
                this.display.removeEventListener('click', this.onClick);
                this.display.removeEventListener('mouseover', this.onHover);
                this.display.material = null;
                this.display.material = null;
                this.display = null;
            };

            _proto2.selectHotspot = function selectHotspot() {};

            _proto2.unSelectHotspot = function unSelectHotspot() {};

            return HotspotSprite;
        }(Display);

        var domHSContaierStyle = {
            position: 'absolute',
            top: '0',
            bottom: '0',
            left: '0',
            right: '0',
            overflow: 'hidden'
        };

        var HotspotManager = /*#__PURE__*/function () {
            function HotspotManager(viewer, scene, _config) {
                var _this = this;

                this.viewer = null;
                this.scene = null;
                this.config = null;
                this.hotspots = [];
                this.domHSContainer = null;
                this.mode = SDK_MODE.SHOW;
                this.showed = false;
                this.cameraChanged = true;
                this.enableDrag = false;

                this.parseConfig = function (config) {
                    if (config && config.length > 0) {
                        for (var i = 0, ii = config.length; i < ii; i++) {
                            _this.create(config[i]);
                        }
                    }
                };

                this.create = function (config) {
                    var hotspot = null;
                    var type = config.type || HOTSPOT_TYPE.THEED_D;

                    switch (type) {
                        case HOTSPOT_TYPE.SWITCH:
                            if (_this.mode === SDK_MODE.SHOW) {
                                hotspot = new HotspotSprite(_this.viewer, _this, config);
                            } else {
                                hotspot = new SceneLink2D(_this.viewer, _this, config);
                            }

                            break;

                        case HOTSPOT_TYPE.POLE:
                            hotspot = new Mask(_this.viewer, _this.scene, config);
                            break;

                        case HOTSPOT_TYPE.LABEL:
                            if (_this.mode === SDK_MODE.SHOW) {
                                hotspot = new Label(_this.viewer, _this, config, _this.mode);
                            } else {
                                hotspot = new Label(_this.viewer, _this, config, _this.mode);
                            }

                            break;

                        case HOTSPOT_TYPE.VIDEO:
                            if (_this.mode === SDK_MODE.SHOW) ; else {
                                config.className = 'link-front';
                                hotspot = new SceneLink2D(_this.viewer, _this, config);
                            }

                            break;
                    }

                    if (hotspot) {
                        _this.hotspots.push(hotspot);

                        _this.scene.rGroup.parent.add(hotspot.display);
                    }

                    return hotspot;
                };

                this.worldToScreen = function (obj, camera, container) {
                    if (camera === void 0) {
                        camera = _this.scene.camera;
                    }

                    if (container === void 0) {
                        container = _this.viewer.container;
                    }

                    var vector = Object3DProxy.newVector3();
                    vector.setFromMatrixPosition(obj.matrixWorld).project(camera);
                    var halfWidth = container.offsetWidth / 2;
                    var halfHeight = container.offsetHeight / 2;
                    var screenCoord = {
                        x: vector.x * halfWidth + halfWidth,
                        y: -vector.y * halfHeight + halfHeight
                    };
                    return screenCoord;
                };

                this.screenToWorld = function (x, y) {
                    var halfWidth = _this.viewer.container.offsetWidth / 2;
                    var halfHeight = _this.viewer.container.offsetHeight / 2;
                    var screenPt = Object3DProxy.newVector2((x - halfWidth) / halfWidth, -(y - halfHeight) / halfHeight); //

                    return _this.getRay(screenPt).ray.direction.multiplyScalar(HOTSPOT_OPTIONS.LABEL_RAY_LENGTH);
                };

                this.onCameraChange = function () {
                    _this.cameraChanged = true;

                    if (!_this.showed) {
                        return;
                    }

                    _this.hotspots.forEach(function (hotspot) {
                        hotspot.update();
                    });

                    _this.cameraChanged = false;
                };

                this.getRay = function (mouse) {
                    if (!_this.raycaster) {
                        _this.raycaster = Object3DProxy.newRaycaster({});
                    }

                    _this.raycaster.setFromCamera(mouse, _this.scene.camera);

                    return _this.raycaster;
                };

                this.getCoord = function (pX, pY) {
                    var _this$getRay$ray$dire = _this.getRay(Object3DProxy.newVector2(pX, pY)).ray.direction.multiplyScalar(HOTSPOT_OPTIONS.LABEL_RAY_LENGTH),
                        x = _this$getRay$ray$dire.x,
                        y = _this$getRay$ray$dire.y,
                        z = _this$getRay$ray$dire.z;

                    return {
                        x: x,
                        y: y,
                        z: z
                    };
                };

                this.addHotspot = function (hotspot) {
                    if (_this.mode === SDK_MODE.SHOW) {
                        _this.scene.rGroup.parent.add(hotspot.display);

                        return false;
                    }

                    if (!hotspot.pos) {
                        var _this$getRay$ray$dire2 = _this.getRay(Object3DProxy.newVector2(0, 0)).ray.direction.multiplyScalar(HOTSPOT_OPTIONS.LABEL_RAY_LENGTH),
                            x = _this$getRay$ray$dire2.x,
                            y = _this$getRay$ray$dire2.y,
                            z = _this$getRay$ray$dire2.z;

                        hotspot.pos = {
                            x: x,
                            y: y,
                            z: z
                        };
                    }

                    if (!_this.config) {
                        _this.config = _this.scene.config.hotspots = [];
                    } // this.config.push(hotspot);
                    // this.create(hotspot).show();


                    _this.hotspots.push(hotspot);

                    _this.scene.rGroup.parent.add(hotspot.display);

                    return true;
                };

                this.updateHotspot = function (id, hotspotConfig) {
                    if (_this.mode === SDK_MODE.SHOW) {
                        return false;
                    }

                    _this.hotspots.forEach(function (hotspot) {
                        if (hotspot.id === id) {
                            _this.removeHotspot(id);

                            _this.addHotspot(hotspotConfig);

                            return true;
                        }
                    });

                    return false;
                };

                this.removeHotspot = function (id) {
                    if (_this.mode === SDK_MODE.SHOW) {
                        return false;
                    }

                    var hotspot = null;

                    for (var i = 0, length = _this.hotspots.length; i < length; ++i) {
                        hotspot = _this.hotspots[i];

                        if (hotspot.id === id) {
                            if (hotspot.type === HOTSPOT_TYPE.DOM) {
                                _this.domHSContainer.removeChild(hotspot.domContainer);
                            }

                            _this.hotspots.splice(i, 1);

                            _this.config.splice(i, 1);

                            _this.scene.rGroup.parent.remove(hotspot.display);

                            return true;
                        }
                    }

                    return false;
                };

                this.removeAllHotspot = function () {
                    if (_this.mode === SDK_MODE.SHOW) {
                        return false;
                    }

                    for (var i = _this.hotspots.length; i > -1; --i) {
                        if (hotspot.type === HOTSPOT_TYPE.DOM) {
                            _this.domHSContainer.removeChild(hotspot.domContainer);
                        }

                        _this.hotspots.splice(i, 1);

                        _this.config.splice(i, 1);

                        _this.scene.rGroup.parent.remove(hotspot.display);
                    }

                    return true;
                };

                this.selectHotspot = function (id, isClickSprite) {
                    if (_this.mode === SDK_MODE.SHOW && _this.enableDrag) {
                        return false;
                    }

                    var success = false;

                    _this.hotspots.forEach(function (hotspot) {
                        if (hotspot.id === id) {
                            success = true;
                            hotspot.selectHotspot();

                            if (!isClickSprite) {
                                _this.scene.cameraLookAtAnimation(hotspot.display.position);
                            }
                        } else {
                            hotspot.unSelectHotspot();
                        }
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_SELECT,
                        id: id
                    });

                    return success;
                };

                this.unSelectHotspot = function (id) {
                    if (_this.mode === SDK_MODE.SHOW && _this.enableDrag) {
                        return false;
                    }

                    _this.hotspots.forEach(function (hotspot) {
                        hotspot.unSelectHotspot();
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_UNSELECT
                    });

                    return true;
                };

                this.viewer = viewer;
                this.scene = scene;
                this.config = _config;
                this.mode = scene.mode;
                this.createDomContainer();
                this.viewer.addEventListener(EVENT.CAMERA_CHANGE, this.onCameraChange); // this.parseConfig(this.config);
            }

            var _proto = HotspotManager.prototype;

            _proto.reset = function reset() {
                this.cameraChanged = true;
                this.show();
                this.hotspots.forEach(function (hotspot) {
                    if (hotspot.type === HOTSPOT_TYPE.DOM) {
                        hotspot.reset();
                    }
                }); // this.unSelectHotspot();
            };

            _proto.createDomContainer = function createDomContainer() {
                this.viewer.container.style.position = 'relative';
                this.domHSContainer = document.createElement('div');
                this.domHSContainer.id = this.scene.sceneId;
                this.domHSContainer.className = 'scene-hs';
                setCSS(this.domHSContainer, domHSContaierStyle);
                this.viewer.container.appendChild(this.domHSContainer);
            };

            _proto.update = function update() {
                this.hotspots.forEach(function (hotspot) {
                    hotspot.update();
                });
            };

            _proto.show = function show() {
                var _this2 = this;

                this.showed = true;
                var domContainers = this.viewer.container.querySelectorAll('.scene-hs');
                domContainers.forEach(function (dom) {
                    if (dom.id === _this2.scene.sceneId) {
                        dom.style.display = 'block';
                    } else {
                        dom.style.display = 'none';
                    }
                });
                this.hotspots.forEach(function (hotspot) {
                    hotspot.show();
                    hotspot.update();
                });
            };

            _proto.hide = function hide() {
                this.showed = false;
                var domContainers = this.viewer.container.querySelectorAll('.scene-hs');
                domContainers.forEach(function (dom) {
                    dom.style.display = 'none';
                });
            };

            _proto.dispose = function dispose() {
                var _this$domHSContainer$;

                this.hotspots.forEach(function (hotspot) {
                    hotspot.dispose();
                });
                (_this$domHSContainer$ = this.domHSContainer.parentElement) === null || _this$domHSContainer$ === void 0 ? void 0 : _this$domHSContainer$.removeChild(this.domHSContainer);
            };

            return HotspotManager;
        }();

        function random() {
            return Math.random();
        }

        function showParticles(scene, config) {
            if (config === void 0) {
                config = {};
            }

            var particalGroup = Object3DProxy.newGroup();
            particalGroup.name = config.id;
            var geometry = Object3DProxy.newBufferGeometry();
            var vertices = [];
            var materials = [];
            var textureLoader = Object3DProxy.newTextureLoader();
            var imgs = config.payload.imgs;
            var lgth = imgs.length;
            var s1 = textureLoader.load(imgs[0 % lgth]);
            var s2 = textureLoader.load(imgs[1 % lgth]);
            var s3 = textureLoader.load(imgs[2 % lgth]);
            var s4 = textureLoader.load(imgs[3 % lgth]);
            var s5 = textureLoader.load(imgs[4 % lgth]); // FIXME: 

            for (var i = 0; i < config.payload.quantity; i++) {
                var x = random() * 2000 - 1000;
                var y = random() * 2000 - 1000;
                var z = random() * 2000 - 1000;
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', Object3DProxy.newFloat32BufferAttribute(vertices, 3));
            var parameters = [[[0.9, 0.05, 0.5], s1, 10], [[1.0, 0.2, 0.5], s2, 12], [[0.95, 0.1, 0.5], s3, 11], [[0.8, 0, 0.5], s4, 5], [[0.85, 0, 0.5], s5, 8]];
            parameters = parameters.concat(parameters);

            for (var _i = 0; _i < parameters.length; _i++) {
                var color = parameters[_i][0];
                var sprite = parameters[_i][1];
                var size = parameters[_i][2];
                materials[_i] = Object3DProxy.newPointsMaterial({
                    size: size,
                    map: sprite,
                    blending: Object3DProxy.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });

                materials[_i].color.setHSL(color[0], color[1], color[2]);

                var particles = Object3DProxy.newPoints(geometry, materials[_i]);
                particles.rotation.x = random() * 6;
                particles.rotation.y = random() * 6;
                particles.rotation.z = random() * 6;
                particles.velocity = random() * config.payload.speed + 1;
                particalGroup.add(particles);
            }

            scene.rGroup.add(particalGroup);

            var update = function update() {
                var p;

                for (var _i2 = 0; _i2 < particalGroup.children.length; _i2++) {
                    p = particalGroup.children[_i2];
                    p.position.y -= p.velocity; // p.velocity += 0.1;

                    if (p.position.y <= -1000) {
                        p.position.y = 1000; // p.position.x = random() * 2000 - 1000;
                        // p.position.z = random() * 2000 - 1000;

                        var manhattanD = Math.abs(p.position.z) * 10 / 1000; // console.log('manhattanD:', p.position, manhattanD);

                        p.velocity = random() * config.payload.speed + 1 + manhattanD;
                    }
                }
            }; // scene.addAfterRender(update);


            particalGroup.update = update;
            return particalGroup;
        }

        const DEFAULT_OPTIONS = {
            camera: {
                fov: 60,
                near: 0.01,
                far: 10000
            }
        };
        class Scene$1 extends Base3D {
            constructor(viewer, sceneId) {
                super();
                this.isReady = false;
                this.mode = SDK_MODE.SHOW;
                this.sceneId = '';
                this.hotspotManager = null;
                this.config = null;
                this.meshList = [];
                this.cameraDeltaTimes = 30;
                this.afterRender = [];
                this.deltaCX = 0;
                this.deltaCY = 0;
                this.currentTimes = 0;
                this.levelLoaded = false;
                this.sceneLoaded = false;
                this.loadConfig = (config) => {
                    this.config = config;
                    this.parseConfig(config);
                };
                this.parseConfig = (config) => {
                    const { fov, fovRange, pitchRange, hotspots } = this.config;
                    this.initCamera(fov, fovRange, pitchRange);
                    this.initHotspotManager(hotspots);
                    this.createDisplay(config);
                };
                this.bindEvent = (display) => {
                    if (display instanceof Object3DProxy.Group) {
                        display.children.forEach(mesh => {
                            this._bindEvent(mesh);
                        });
                    }
                    else {
                        this._bindEvent(display);
                    }
                };
                this._bindEvent = (display) => {
                    display.addEventListener('mouseover', () => {
                        // console.log('mouse over mesh');
                        this.viewer.container.style.cursor = 'auto';
                    });
                    display.addEventListener('click', () => {
                        // console.log('mouse click mesh');
                        this.viewer.dispatchEvent({ type: EVENT.SCENE_CLICK });
                    });
                };
                this.createDisplay = (config) => {
                    console.log(config, 'create display');
                    switch (config.vrResource.render_type) {
                        case PROJECTION_TYPE.SPHERE: {
                            const mesh = new SphereMesh(this.viewer, config.vrResource.resource.source);
                            mesh.addEventListener(EVENT_INT.DISPLAY_LOADED, this.onDisplayLoadComplete);
                            mesh.addEventListener(EVENT_INT.DISPLAY_LOAD_ERROR, this.onDisplayLoadError);
                            mesh.startLoad();
                            break;
                        }
                        case PROJECTION_TYPE.CUBE_MULTI: {
                            const temConfig = Object.assign(Object.assign({}, config.vrResource.resource.source), { zoomFactory: config.zoomFactor });
                            const multires = new Multires(this.viewer, temConfig, this, this.camera);
                            multires.on(EVENT_INT.DISPLAY_LOADED, this.onDisplayLoadComplete);
                            multires.on(EVENT_INT.TILE_INIT_ERROR, this.onDisplayLoadError);
                            multires.on(EVENT_INT.TILE_IMAGE_ERROR, () => {
                                // TODO 
                                this.viewer.dispatchEvent({ type: EVENT.TILE_IMAGE_ERROR, scene: this });
                            });
                            this.multires = multires;
                            break;
                        }
                        case PROJECTION_TYPE.CUBE:
                        case PROJECTION_TYPE.CUBE_LIST: {
                            const cube = new CubeMesh(this.viewer, config.vrResource.resource.source);
                            cube.on(EVENT_INT.DISPLAY_LOADED, this.onDisplayLoadComplete);
                            cube.startLoad();
                            break;
                        }
                    }
                };
                this.initHotspotManager = (hotspots) => {
                    this.hotspotManager = new HotspotManager(this.viewer, this, hotspots);
                };
                this.initCamera = (fov, fovRange, pitchRange) => {
                    const cameraParameters = Object.assign(Object.assign({}, DEFAULT_OPTIONS.camera), { fov, aspect: this.viewer.container.offsetWidth / this.viewer.container.offsetHeight, near: 0.1, far: 1000000 });
                    this.camera = Object3DProxy.newCamera(cameraParameters);
                    this.camera.position.set(0, 0, 0);
                    this.camera.rotation.order = 'YXZ';
                    this.camera.fovRange = fovRange;
                    this.camera.pitchRange = pitchRange;
                };
                this.onDisplayLoadComplete = ({ mesh }) => {
                    console.log('onDisplayLoadComplete');
                    this.meshList.push(mesh);
                    this.rGroup.add(mesh.display);
                    this.bindEvent(mesh.display);
                    this.initFbo();
                    this.isReady = true;
                    this.viewer.dispatchEvent({ type: EVENT_INT.SCENE_READY, scene: this });
                    this.viewer.dispatchEvent({ type: EVENT.LOADED, sceneId: this.sceneId });
                    this.viewer.controllerManager.onSceneReady(this);
                    this.viewer.controllerManager.init();
                };
                this.initFbo = () => {
                    const renderTargetParameters = {
                        minFilter: Object3DProxy.NearestFilter,
                        magFilter: Object3DProxy.NearestFilter,
                        wrapS: Object3DProxy.ClampToEdgeWrapping,
                        wrapT: Object3DProxy.ClampToEdgeWrapping,
                        format: Object3DProxy.RGBFormat,
                        depthBuffer: false,
                        stencilBuffer: false
                    };
                    this.fbo = Object3DProxy.newWebGLRenderTarget(this.viewer.container.offsetWidth, this.viewer.container.offsetHeight, renderTargetParameters);
                };
                this.onDisplayLoadError = ({ error }) => {
                    this.viewer.dispatchEvent({ type: EVENT.SCENE_IMAGE_ERROR, sceneId: this.sceneId, error: error });
                };
                this.update = () => {
                    if (!this.isReady || !this.viewer.controllerManager.isReady) {
                        return;
                    }
                    this.camera.updateProjectionMatrix();
                    // console.log('opacity ', this.viewer.story.isLoaded);
                    if (this.viewer.story.isLoaded) {
                        this.hotspotManager.update();
                    }
                    if (this.cameraAnimationStart) {
                        this.updateCameraAnimation();
                    }
                    if (this.afterRender.length > 0) {
                        this.afterRender.forEach((fun) => {
                            fun();
                        });
                    }
                };
                this.addAfterRender = (fun) => {
                    this.afterRender.push(fun);
                };
                this.lookAtTarget = () => {
                    const { x, y, z, w } = this.config.lookAt;
                    this.camera.quaternion.set(x, y, z, w);
                };
                this.dispose = () => {
                    if (this.meshList && this.meshList instanceof Array) {
                        this.meshList.forEach(mesh => {
                            mesh.dispose();
                        });
                        this.meshList = [];
                    }
                    this.camera = null;
                    this.scene = null;
                    this.frustum = null;
                    this.frustumMatrix = null;
                    this.fbo = null;
                    this.multires = undefined;
                    // todo:
                    if (this.rGroup) {
                        this.rGroup = null;
                    }
                    if (this.hotspotManager) {
                        this.hotspotManager.dispose();
                        this.hotspotManager = null;
                    }
                };
                this.addHotspot = (hotspot) => {
                    return this.hotspotManager.addHotspot(hotspot);
                };
                this.updateHotspot = (id, hotspot) => {
                    console.log(id, hotspot);
                    return this.hotspotManager.updateHotspot(id, hotspot);
                };
                this.removeHotspot = (id) => {
                    return this.hotspotManager.removeHotspot(id);
                };
                this.removeAllHotspot = () => {
                    return this.hotspotManager.removeAllHotspot();
                };
                this.selectHotspot = (id) => {
                    return this.hotspotManager.selectHotspot(id);
                };
                this.unSelectHotspot = (id) => {
                    return this.hotspotManager.unSelectHotspot(id);
                };
                this.setDefaultRotation = (rotation) => {
                    this.config.rotation = rotation;
                    return true;
                };
                this.cameraLookAtAnimation = (position) => {
                    let ex1 = this.camera.rotation.x;
                    let ey1 = this.camera.rotation.y;
                    this.camera.lookAt(position);
                    let ex2 = this.camera.rotation.x;
                    let ey2 = this.camera.rotation.y;
                    this.camera.rotation.x = clampCircle(ex1, -Math.PI / 2, Math.PI / 2);
                    this.camera.rotation.y = clampCircle(ey1, 0, 2 * Math.PI);
                    this.viewer.dispatchEvent({ type: EVENT.CAMERA_ANIMATION_START });
                    this.cameraAnimationStart = true;
                    let dx = ex2 - ex1;
                    let dy = ey2 - ey1;
                    this.deltaCX = dx / this.cameraDeltaTimes;
                    this.deltaCY = clampCircle(dy, -Math.PI, Math.PI) / this.cameraDeltaTimes;
                    this.currentTimes = 0;
                };
                this.initLevelLoaded = () => {
                    this.levelLoaded = true;
                    this.checkSnapReady();
                };
                this.initSceneLoaded = () => {
                    this.sceneLoaded = true;
                    this.checkSnapReady();
                };
                this.checkSnapReady = () => {
                    if (this.levelLoaded && this.sceneLoaded) {
                        this.viewer.dispatchEvent({
                            type: EVENT.SNAPSHOT_READY,
                            sceneId: this.sceneId
                        });
                    }
                };
                this.addEffect = (effect) => {
                    let effectObj;
                    switch (effect.type) {
                        case EFFECT_TYPE.LIGHT:
                            effectObj = this.showSunshine(effect);
                            break;
                        case EFFECT_TYPE.PARTICLE:
                            effectObj = this.showParticles(effect);
                            break;
                    }
                    return effectObj;
                };
                this.removeEffect = (effectId) => {
                    const obj = this.rGroup.getObjectByName(effectId);
                    if (!obj) {
                        return false;
                    }
                    this.rGroup.remove(obj);
                    return true;
                };
                this.showSunshine = (config) => {
                    const light = this.genLight(config);
                    light.name = config.id;
                    this.rGroup.add(light);
                    return light;
                    // let light = Object3DProxy.newPointLight(0xffffff, 1.5, 2000);
                    // light.position.set(x, y, z);
                    // this.scene.add(light);
                };
                this.genLight = (config) => {
                    const { payload: { pos, hsl, imgs } } = config;
                    let light = Object3DProxy.newPointLight(0xffffff, 1.5, 2000);
                    light.color.setHSL(hsl.h, hsl.s, hsl.l);
                    light.position.set(pos.x, pos.y, pos.z);
                    const loader = Object3DProxy.newTextureLoader();
                    let lensflare = Object3DProxy.newLensflare();
                    let flare0 = loader.load(imgs[0]);
                    let flare1 = loader.load(imgs[1]);
                    lensflare.addElement(Object3DProxy.newLensflareElement(flare0, 700, 0, light.color));
                    lensflare.addElement(Object3DProxy.newLensflareElement(flare1, 60, 0.6));
                    lensflare.addElement(Object3DProxy.newLensflareElement(flare1, 70, 0.7));
                    lensflare.addElement(Object3DProxy.newLensflareElement(flare1, 120, 0.9));
                    lensflare.addElement(Object3DProxy.newLensflareElement(flare1, 70, 1));
                    light.add(lensflare);
                    return light;
                };
                this.showParticles = (config) => {
                    return showParticles(this, config);
                };
                this.viewer = viewer;
                this.sceneId = sceneId;
                this.scene = Object3DProxy.newScene();
                this.frustum = Object3DProxy.newFrustum();
                this.frustumMatrix = Object3DProxy.newMatrix4();
                this.rGroup = Object3DProxy.newGroup();
                this.mode = (viewer.options && viewer.options.mode) || SDK_MODE.SHOW;
                this.scene.background = Object3DProxy.newColor(0xffffff);
                this.scene.add(this.rGroup);
                // let quaternion = Object3DProxy.newQuaternion().setFromEuler(Object3DProxy.newEuler(0, Math.PI / 6, 0, 'YXZ'));
                // this.rGroup.applyQuaternion(quaternion.conjugate());
            }
            updateFrustum(camera = this.camera) {
                camera.updateMatrix();
                camera.updateMatrixWorld();
                camera.matrixWorldInverse.getInverse(camera.matrixWorld);
                this.frustumMatrix.identity();
                this.frustum.setFromProjectionMatrix(this.frustumMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
                return this.frustum;
            }
            updateCameraAnimation() {
                this.currentTimes++;
                if (this.currentTimes > this.cameraDeltaTimes) {
                    this.cameraAnimationStart = false;
                    this.viewer.dispatchEvent({ type: EVENT.CAMERA_ANIMATION_END });
                    return;
                }
                this.camera.rotation.x += this.deltaCX;
                this.camera.rotation.y += this.deltaCY;
                this.viewer.controllerManager.gyroControls.setRotation(this.camera.rotation.x, this.camera.rotation.y);
            }
        }
        function clampCircle(val, min, max) {
            let circle = max - min;
            if (val < min) {
                return val + circle * Math.ceil((min - val) / circle);
            }
            if (val > max) {
                return val - circle * Math.ceil((val - max) / circle);
            }
            return val;
        }

        // TODO 
        class Story extends Base3D {
            // animation = null;
            constructor(viewer) {
                super();
                this.isReady = false; // scene is ok
                this.isLoaded = false; // animation endransition end;
                this.sceneList = new Map();
                this.currentSceneId = null;
                this.currentScene = null;
                this.isLoadingNext = false;
                this.isFirst = true;
                this.isCached = false;
                this.loadConfig = (config) => {
                    this.log(config);
                    this.config = config;
                    this.parseConfig(config);
                };
                this.parseConfig = (config) => {
                    console.log('parseConfig', config);
                    if (!this.viewer) {
                        return;
                    }
                    this.viewer.removeEventListener(EVENT_INT.SCENE_READY, this.onSceneReady);
                    this.viewer.addEventListener(EVENT_INT.SCENE_READY, this.onSceneReady);
                    this.viewer.removeEventListener(EVENT.SCENE_TRANSITION, this.onSceneTransition);
                    this.viewer.addEventListener(EVENT.SCENE_TRANSITION, this.onSceneTransition);
                    // this.viewer.removeEventListener(EVENT_INT.ANIMATION_READY, this.onAnimationReady);
                    // this.viewer.addEventListener(EVENT_INT.ANIMATION_READY, this.onAnimationReady);
                    // this.viewer.removeEventListener(EVENT_INT.ANIMATION_END, this.onAnimationEnd);
                    // this.viewer.addEventListener(EVENT_INT.ANIMATION_END, this.onAnimationEnd);
                    this.viewer.removeEventListener(EVENT_INT.SCENE_LOADED, this.onSceneLoaded);
                    this.viewer.addEventListener(EVENT_INT.SCENE_LOADED, this.onSceneLoaded);
                    this.viewer.removeEventListener(EVENT.SCENE_IMAGE_ERROR, this.onSceneError);
                    this.viewer.addEventListener(EVENT.SCENE_IMAGE_ERROR, this.onSceneError);
                    // if (!!this.config.enterAnimation) {
                    //     this.viewer.enterAnimationFinished = false;
                    // } else {
                    //     this.viewer.enterAnimationFinished = true;
                    // }
                    this.switchToScene(this.config.id);
                };
                this.update = () => {
                    if (!this.isReady) {
                        return;
                    }
                    if (this.currentScene) {
                        this.currentScene.update();
                    }
                    // if (this.animation) {
                    //     this.animation.update(time);
                    // }
                };
                this.switchToScene = (sceneId, rotation) => {
                    this.viewer.enablePointEvent(false);
                    let scene = this.sceneList.get(sceneId);
                    if (scene) {
                        this.isCached = true;
                        scene.config.lookAt = rotation || scene.config.rotation;
                        this.onSceneReady({ scene });
                    }
                    else {
                        if (!this.isFirst) {
                            this.viewer.dispatchEvent({ type: EVENT.SCENE_LOADING });
                        }
                        this.isCached = false;
                        let sceneConfig = this.findSceneInfoById(sceneId);
                        if (sceneConfig) {
                            sceneConfig = Object.assign(Object.assign({}, sceneConfig), { lookAt: rotation || sceneConfig.rotation });
                            this.createScene(sceneConfig, sceneId);
                            console.log(this, '-----story config load');
                        }
                        else {
                            this.viewer.dispatchEvent({ type: EVENT.SCENE_CONFIG_ERROR, sceneId: sceneId });
                        }
                    }
                };
                this.findSceneInfoById = (id) => {
                    return this.config.id === id ? Object.assign({}, this.config) : null;
                };
                this.createScene = (config, sceneId) => {
                    const scene = new Scene$1(this.viewer, sceneId);
                    this.sceneList.set(scene.sceneId, scene);
                    this.currentScene = scene;
                    scene.loadConfig(config);
                    return scene;
                };
                this.onSceneReady = ({ scene }) => {
                    // this.isLoaded = false;
                    if (this.isFirst) {
                        this.tmpScene = scene;
                        this.currentScene = scene;
                        this.viewer.controllerManager.camera = scene.camera;
                        this.viewer.dispatchEvent({ type: EVENT.SCENE_LOADED });
                    }
                    else {
                        this.currentScene = scene;
                        this.currentSceneId = scene.sceneId;
                        this.currentScene.lookAtTarget();
                        this.viewer.container.style.cursor = 'auto';
                        this.isReady = true;
                        this.viewer.controllerManager.onSceneReady(scene);
                    }
                };
                this.onSceneError = ({ sceneId }) => {
                    this.sceneList.delete(sceneId);
                    this.viewer.enablePointEvent(true);
                };
                // onAnimationReady = ({scene}: any) => {
                //     this.scene = scene;
                //     if (this.config.clickEnter) {
                //         this.viewer.dispatchEvent({type: EVENT.CAN_ENTER});
                //     } else {
                //         this.triggerEnter();
                //     }
                // }
                this.triggerEnter = () => {
                    this.currentScene = this.scene;
                    this.isReady = true;
                    this.viewer.dispatchEvent({ type: EVENT.SCENE_LOADED, isFirst: true, sceneId: this.scene.sceneId });
                };
                // onAnimationEnd = () => {
                //     console.log('onAnimationEnd', this.tmpScene);
                //     this.viewer.dispatchEvent({type: EVENT_INT.LOADED, sceneId: this.currentScene.sceneId});
                //     this.currentScene = this.tmpScene;
                //     this.currentSceneId = this.tmpScene.sceneId;
                //     this.viewer.controllerManager.onSceneReady(this.tmpScene);
                //     this.isLoaded = true;
                //     this.viewer.enablePointEvent(true);
                //     this.currentScene.hotspotManager.show();
                //     const rotation = this.viewer.getCameraRotation();
                //     const fov = this.viewer.getFov();
                //     this.currentScene.initSceneLoaded();
                //     this.viewer.dispatchEvent({type: EVENT.CAMERA_CHANGE, cause: 'all', fov: fov, rotation: rotation});
                //     this.viewer.dispatchEvent({type: EVENT.LOADED, sceneId: this.currentScene.sceneId});
                //     Reporter.send(CMDID.LOADED);
                //     Reporter.startHeartBeat();
                //     this.isFirst = false;
                // }
                // TODO 
                this.onSceneTransition = () => {
                    this.currentScene.hotspotManager.hide();
                };
                this.onSceneLoaded = () => {
                    this.isLoaded = true;
                    if (this.isCached) {
                        this.currentScene.hotspotManager.reset();
                    }
                    else {
                        this.currentScene.hotspotManager.show();
                    }
                    this.viewer.enablePointEvent(true);
                    this.viewer.controllerManager.onSceneReady(this.currentScene);
                    this.viewer.dispatchEvent({
                        type: EVENT.SCENE_LOADED,
                        isFirst: this.isFirst,
                        sceneId: this.currentScene.sceneId
                    });
                    if (this.isFirst) {
                        this.viewer.dispatchEvent({ type: EVENT.LOADED, sceneId: this.currentScene.sceneId });
                        this.isFirst = false;
                    }
                    this.currentScene.initSceneLoaded();
                    const rotation = this.viewer.getCameraRotation();
                    const fov = this.viewer.getFov();
                    this.viewer.dispatchEvent({ type: EVENT.CAMERA_CHANGE, cause: 'all', fov: fov, rotation: rotation });
                };
                this.resize = () => {
                    this.sceneList.forEach(scene => {
                        scene.camera.aspect = this.viewer.container.offsetWidth / this.viewer.container.offsetHeight;
                        scene.camera.updateProjectionMatrix();
                    });
                };
                // TODO pi
                this.findSceneById = (sceneId) => {
                    return this.sceneList.get(sceneId);
                };
                this.removeScene = (sceneId) => {
                    const scene = this.sceneList.get(sceneId);
                    if (scene) {
                        scene.dispose();
                        this.sceneList.delete(sceneId);
                    }
                };
                this.addHotspot = (hotspot) => {
                    return this.currentScene.addHotspot(hotspot);
                };
                this.updateHotspot = (id, hotspotConfig, sceneId) => {
                    if (!sceneId) {
                        return this.currentScene.updateHotspot(id, hotspotConfig);
                    }
                    else {
                        let updated = false;
                        this.sceneList.forEach(scene => {
                            if (scene.sceneId === sceneId) {
                                scene.updateHotspot(id, hotspotConfig);
                                updated = true;
                            }
                        });
                        if (updated) {
                            return;
                        }
                        //otspot,
                        if (sceneId === this.config.id) {
                            let tmp = this.config;
                            let hotspot = null;
                            for (let i = 0, length = tmp.hotspots.length; i < length; ++i) {
                                hotspot = tmp.hotspots[i];
                                if (hotspot.id === id) {
                                    tmp.hotspots.splice(i, 1);
                                    tmp.hotspots.push(hotspotConfig);
                                    return;
                                }
                            }
                        }
                    }
                };
                this.removeHotspot = (id, sceneId) => {
                    let deleted = false;
                    if (!sceneId) {
                        deleted = this.currentScene.removeHotspot(id);
                    }
                    else {
                        this.sceneList.forEach(scene => {
                            if (scene.sceneId === sceneId) {
                                deleted = scene.removeHotspot(id);
                            }
                        });
                        if (deleted) {
                            return deleted;
                        }
                        //otspot,
                        if (sceneId === this.config.id) {
                            let tmp = this.config;
                            let hotspot = null;
                            for (let i = 0, length = tmp.hotspots.length; i < length; ++i) {
                                hotspot = tmp.hotspots[i];
                                if (hotspot.id === id) {
                                    tmp.hotspots.splice(i, 1);
                                    deleted = true;
                                    return deleted;
                                }
                            }
                        }
                    }
                    return deleted;
                };
                this.removeAllHotspot = () => {
                    return this.currentScene.removeAllHotspot();
                };
                this.selectHotspot = (id) => {
                    return this.currentScene.selectHotspot(id);
                };
                this.unSelectHotspot = (id) => {
                    return this.currentScene.unSelectHotspot(id);
                };
                this.setDefaultRotation = (rotation) => {
                    return this.currentScene.setDefaultRotation(rotation);
                };
                this.removeEffect = (effectId, sceneId) => {
                    const scene = this.sceneList.get(sceneId);
                    let result = true;
                    if (scene) {
                        result = scene.removeEffect(effectId);
                    }
                    else {
                        result = false;
                    }
                    return result;
                };
                this.viewer = viewer;
            }
            destroy() {
                if (this.sceneList) {
                    this.sceneList.forEach(scene => {
                        scene.dispose();
                    });
                    this.sceneList.clear();
                }
                //todo:
                if (this.tmpScene) {
                    this.tmpScene.dispose();
                    this.tmpScene = null;
                }
                if (this.currentScene) {
                    this.currentScene.dispose();
                    this.currentScene = null;
                }
                // @ts-ignore
                this.viewer = null;
                this.scene = null;
            }
            getHsManager(sceneId) {
                if (sceneId) {
                    const scene = this.sceneList.get(sceneId);
                    return scene ? scene.hotspotManager : null;
                }
                else {
                    return this.currentScene.hotspotManager;
                }
            }
        }

        /**
         * Copyright (c) 2015 NAVER Corp.
         * egjs projects are licensed under the MIT license
         */

        /* eslint-disable no-new-func, no-nested-ternary */
        var win = typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();
        /* eslint-enable no-new-func, no-nested-ternary */

        var doc = win.document;
        var userAgent = win.navigator.userAgent;
        var IS_SAFARI_ON_DESKTOP = userAgent.indexOf('Safari') !== -1 && userAgent.indexOf('Chrome') === -1 && userAgent.indexOf('Mac OS X') !== -1;
        var IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent);

        var DragControls = /*#__PURE__*/function () {
            function DragControls(manager, _camera, dom) {
                var _this = this;

                if (dom === void 0) {
                    dom = document.body;
                }

                this.setReversalEvent = function (reversal) {
                    _this.speedY = Math.abs(_this.speedY) * (reversal ? -1 : 1);
                };

                this.resetCameraPara = function (camera) {
                    _this.camera = camera;
                    _this.dstFov = _this.camera.fov;
                    _this.curFov = _this.camera.fov;
                    _this.fovRange = camera.fovRange || CAMERA_DEFAULT_OPTIONS.fovRange;
                };

                this.onScroll = function (event) {
                    if (event && event.stopPropagation) {
                        event.stopPropagation();
                        event.preventDefault();
                    } else {
                        window.event.cancelBubble = true;
                    }

                    if (!_this.enable) {
                        return;
                    } // 3hrome100


                    var d = Math.max(Math.abs(event.deltaY), 50);

                    _this.doScroll(event.deltaY > 0 ? d : -d);

                    _this.manager.viewer.dispatchEvent({
                        type: EVENT.PAUSE_AUTO_ROTATE
                    });
                };

                this.fovSpring = function () {
                    if (Math.abs(_this.dstFov - _this.curFov) <= 0.01) {
                        return;
                    }

                    _this.curFov = (_this.dstFov - _this.curFov) / _this.tf + _this.curFov;
                    _this.camera.fov = _this.curFov;

                    _this.camera.updateProjectionMatrix();

                    _this.fovChanged = true; // console.log('scale fovSpring');
                };

                this.update = function () {
                    _this.fovSpring();
                };

                this.doScroll = function (deltaY) {
                    // console.log('scale doscroll', deltaY);
                    // console.log(deltaY);
                    _this.scrolled = true;
                    _this.scrollDeltaY = deltaY;
                    _this.manager.interactiveTime = performance.now();
                    var y = deltaY * _this.fovSpeed;
                    var tmp = _this.dstFov + y;
                    _this.dstFov = Math.min(_this.fovRange[1], Math.max(_this.fovRange[0], tmp));
                    _this.action = 'pinch';
                };

                this.onMove = function (event) {
                    // console.log('mouse move');
                    if (event && event.stopPropagation) {
                        event.stopPropagation();
                        event.preventDefault();
                    } else {
                        window.event.cancelBubble = true;
                    }

                    if (!_this.down || !_this.enable) {
                        return;
                    } // console.log('onMove');


                    if (event.touches && event.touches.length) {
                        if (event.touches.length > 1) {
                            _this.preDis = _this.curDis;
                            var p1 = event.touches[0];
                            var p2 = event.touches[1];
                            _this.curDis = Math.sqrt((p1.clientX - p2.clientX) * (p1.clientX - p2.clientX) + (p1.clientY - p2.clientY) * (p1.clientY - p2.clientY));

                            if (_this.twoFinger) {
                                _this.enablePinch && _this.doScroll((_this.curDis - _this.preDis) * _this.mobileSpeedScale);
                            } else {
                                _this.twoFinger = true;
                            }

                            return;
                        }

                        event = event.touches[0];
                    }

                    _this.prePoint[0] = _this.curPoint[0];
                    _this.prePoint[1] = _this.curPoint[1];
                    _this.curPoint[0] = event.clientX;
                    _this.curPoint[1] = event.clientY;
                    var ratio = _this.curFov / 90;
                    _this.deltaX = (_this.curPoint[1] - _this.prePoint[1]) * _this.speedX * ratio;
                    _this.deltaY = (_this.curPoint[0] - _this.prePoint[0]) * _this.speedY * ratio;

                    _this.manager.gyroControls.updateDragDelta(_this.deltaX, _this.deltaY);

                    _this.changed = true;
                    _this.action = 'drag';

                    _this.manager.viewer.dispatchEvent({
                        type: EVENT.PAUSE_AUTO_ROTATE
                    });
                };

                this.onDown = function (event) {
                    // button === 2 
                    if (!_this.enable || event.button === 2) {
                        return;
                    }

                    _this.curTime = Date.now();
                    _this.manager.touching = true;
                    _this.down = true;

                    if (event.touches && event.touches.length) {
                        event = event.touches[0];
                    }

                    _this.curPoint[0] = event.clientX;
                    _this.curPoint[1] = event.clientY;
                };

                this.onUp = function (event) {
                    // console.log('mouse up');
                    if (_this.enable && _this.down) {
                        _this.manager.touching = false;
                        _this.manager.interactiveTime = performance.now();
                        _this.down = false;
                        _this.twoFinger = false;

                        var delta = Date.now() - _this.curTime; // console.log('delta::', delta);


                        if (delta < 300) {
                            _this.dumping();
                        }
                    }

                    if (_this.enable && _this.action) {
                        _this.action = '';
                    }
                };

                this.pinchEnable = function (enable) {
                    _this.enablePinch = enable;
                };

                this.isPinchEnabled = function () {
                    return _this.enablePinch;
                };

                this.setEnable = function (enable) {
                    _this.enable = enable;
                };

                this.dumping = function () {
                    if (!_this.enable) {
                        return;
                    }

                    if (Math.abs(_this.deltaX) <= _this.epsilon && Math.abs(_this.deltaY) <= _this.epsilon) {
                        cancelAnimationFrame(_this.raf);
                        return;
                    } // console.log('dumping');


                    _this.deltaY *= _this.dumpSpeed;
                    _this.deltaX *= _this.dumpSpeed;

                    _this.manager.gyroControls.updateDragDelta(_this.deltaX, _this.deltaY);

                    _this.changed = true;
                    _this.raf = requestAnimationFrame(_this.dumping);
                };

                this["switch"] = function (enable) {
                    _this.enable = enable;
                };

                this.destroy = function () {
                    _this.dispose();
                };

                this.addListeners = function () {
                    _this.dom.addEventListener('mousedown', _this.onDown);

                    _this.dom.addEventListener('mouseup', _this.onUp);

                    _this.dom.addEventListener('mousemove', _this.onMove);

                    _this.dom.addEventListener('mouseleave', _this.onUp);

                    _this.dom.addEventListener('touchstart', _this.onDown);

                    _this.dom.addEventListener('touchend', _this.onUp);

                    _this.dom.addEventListener('touchmove', _this.onMove); // mousewheelheel
                    // dom.addEventListener('mousewheel', this.onScroll);


                    _this.dom.addEventListener('wheel', _this.onScroll);
                };

                this.dispose = function () {
                    _this.removeListeners();
                };

                this.manager = manager;
                this.resetCameraPara(_camera);
                this.dom = dom;
                this.down = false;
                this.prePoint = [0, 0];
                this.curPoint = [0, 0];
                this.speedX = 0.002;
                this.speedY = 0.0025;
                this.dumpSpeed = 0.85;
                this.deltaX = 0;
                this.deltaY = 0;
                this.epsilon = 0.00001;
                this.fovSpeed = 1 / 200 * window.devicePixelRatio;
                this.fovSpeed *= IS_MOBILE ? -1 : 6;
                this.tf = 8;
                this.mobileSpeedScale = 10;
                this.twoFinger = false;
                this.preDis = 0;
                this.curDis = 0;
                this.enable = true;
                this.changed = false;
                this.fovChanged = false;
                this.enablePinch = true;
                this.addListeners();
                this.action = '';
                this.curTime = Date.now();
            }

            var _proto = DragControls.prototype;

            _proto.removeListeners = function removeListeners() {
                this.dom.removeEventListener('mousedown', this.onDown);
                this.dom.removeEventListener('mousemove', this.onMove);
                this.dom.removeEventListener('mouseup', this.onUp);
                this.dom.removeEventListener('mouseleave', this.onUp);
                this.dom.removeEventListener('touchstart', this.onDown);
                this.dom.removeEventListener('touchmove', this.onMove);
                this.dom.removeEventListener('touchend', this.onUp);
                this.dom.removeEventListener('wheel', this.onScroll);
            };

            return DragControls;
        }();

        var _Promise$3 = typeof Promise === 'undefined' ? es6Promise.Promise : Promise;
        var PERM_ALERT_OPERATION_TIME = 1000; // 1sesp

        var GyroControls = /*#__PURE__*/function () {
            function GyroControls(_camera) {
                var _this = this;

                this.reversalEv = false;
                this.enabledPitch = false;
                this.enable = true;

                this.destroy = function () {
                    _this.dispose();
                };

                this["switch"] = function (enable) {
                    _this.enable = enable;

                    if (enable) {
                        // x
                        _this.theta = _this.reversalEv ? _this.camera.rotation.x : _this.camera.rotation.y;
                        _this.phi = _this.reversalEv ? _this.camera.rotation.y : _this.camera.rotation.x;
                        return _this.initDeviceEvent();
                    } else {
                        return _Promise$3.resolve(_this.dispose());
                    }
                };

                this.dispose = function () {
                    if (window.DeviceMotionEvent) {
                        window.removeEventListener('devicemotion', _this.onDeviceChangeWrapper);
                    }

                    _this.gyroStat = false;
                    _this.hasOpened = false;
                };

                this.resetRotation = function () {
                    _this.phi = 0;
                    _this.theta = 0;
                };

                this.resetCameraPara = function (camera) {
                    _this.camera = camera;
                    _this.pitchRange = camera.pitchRange || CAMERA_DEFAULT_OPTIONS.pitchRange;
                    _this.pitchRange = convertToRadArr(_this.pitchRange);

                    _this.resetRotation();
                };

                this.initDeviceEvent = function () {
                    return new _Promise$3(function (resolve, reject) {
                        var startTs = Date.now();

                        if (window.DeviceMotionEvent !== undefined && typeof window.DeviceMotionEvent.requestPermission === 'function') {
                            window.DeviceMotionEvent.requestPermission().then(function (response) {
                                if (response === 'granted') {
                                    _this.gyroStat = true;
                                    _this.onDeviceChangeWrapper = _this.onDeviceChange;
                                    window.addEventListener('devicemotion', _this.onDeviceChangeWrapper, false);
                                    resolve(2);

                                    if (Date.now() - startTs > PERM_ALERT_OPERATION_TIME) {
                                        Reporter.send(CMDID.PERMISSION, {
                                            result: 1
                                        });
                                    }
                                } else {
                                    _this.gyroStat = false;
                                    reject(4);

                                    if (Date.now() - startTs > PERM_ALERT_OPERATION_TIME) {
                                        Reporter.send(CMDID.PERMISSION, {
                                            result: 0
                                        });
                                    }
                                }
                            })["catch"](function (error) {
                                console.error('Unable to use DeviceMotionEvent API:', error);
                                _this.gyroStat = false;
                                reject(3);
                            });
                        } else {
                            _this.gyroStat = true;

                            _this.onDeviceChangeWrapper = function (event) {
                                _this.onDeviceChange(event, resolve);
                            };

                            _this.startTime = performance.now();
                            window.addEventListener('devicemotion', _this.onDeviceChangeWrapper, false);
                            window.clearTimeout(_this.timeoutId);
                            _this.timeoutId = setTimeout(function () {
                                if (!_this.hasOpened) {
                                    _this.dispose();

                                    reject(-1);
                                }
                            }, 800);
                        }
                    });
                };

                this.setPitchRange = function (pitchRange) {
                    _this.pitchRange = convertToRadArr(pitchRange);
                    console.log('set pitch:', pitchRange);
                    return true;
                };

                this.pitchEnabled = function (enable) {
                    _this.enabledPitch = enable;
                };

                this.isGyroOpen = function () {
                    return _this.gyroStat;
                };

                this.onDeviceChange = function (event, resolve) {
                    if (!_this.hasOpened) {
                        _this.hasOpened = true;

                        if (resolve) {
                            resolve(1);
                        }
                    }

                    if (_this.disabled) {
                        return;
                    }

                    var portrait = event.portrait !== undefined ? event.portrait : window.matchMedia('(orientation: portrait)').matches;
                    var orientation;

                    if (event.orientation !== undefined) {
                        orientation = event.orientation;
                    } else if (window.orientation !== undefined) {
                        orientation = window.orientation;
                    } else {
                        orientation = -90;
                    } // chrome65a


                    if (!_this.checkedEventType) {
                        if (Math.abs(event.rotationRate.alpha) > 0.1 || Math.abs(event.rotationRate.beta) > 0.1) {
                            var m = Math.max(Math.abs(event.rotationRate.alpha), Math.abs(event.rotationRate.beta));

                            if (m > 20) {
                                _this.isRadEvent = false;
                                _this.checkedEventType = true;
                            }
                        } else {
                            // 
                            return;
                        }
                    }

                    var alpha = _this.isRadEvent ? event.rotationRate.alpha : MathUtils.degToRad(event.rotationRate.alpha);
                    var beta = _this.isRadEvent ? event.rotationRate.beta : MathUtils.degToRad(event.rotationRate.beta);
                    beta *= _this.reversalEv ? -1 : 1;

                    if (portrait) {
                        _this.phi = _this.phi + alpha * _this.velo;
                        _this.theta = _this.theta - beta * _this.velo * -1;
                    } else {
                        _this.phi = orientation === -90 ? _this.phi + beta * _this.velo : _this.phi - beta * _this.velo;
                        _this.theta = orientation === -90 ? _this.theta - alpha * _this.velo : _this.theta + alpha * _this.velo;
                    }

                    _this.adjustPhi();

                    _this.changed = true;

                    _this.update();
                };

                this.updateDragDelta = function (phi, theta) {
                    _this.phi += phi;
                    _this.theta += theta;

                    _this.adjustPhi();

                    _this.update();
                };

                this.setRotation = function (x, y) {
                    _this.phi = _this.reversalEv ? y : x;
                    _this.theta = _this.reversalEv ? x : y;
                };

                this.adjustPhi = function () {
                    if (_this.reversalEv) {
                        _this.theta = _this.isPitchEnabled() ? MathUtils.clamp(_this.theta, _this.pitchRange[0], _this.pitchRange[1]) : _this.theta;
                    } else {
                        _this.phi = _this.isPitchEnabled() ? MathUtils.clamp(_this.phi, _this.pitchRange[0], _this.pitchRange[1]) : _this.phi;
                    }
                };

                this.update = function () {
                    if (!_this.enable) {
                        return false;
                    }

                    if (_this.phi === _this.previousPhi && _this.theta === _this.previousTheta) {
                        return false;
                    }

                    _this.previousPhi = _this.phi;
                    _this.previousTheta = _this.theta; // console.log('reversalEv', this.reversalEv);

                    _this.camera.rotation.x = _this.reversalEv ? _this.theta : _this.phi;
                    _this.camera.rotation.y = _this.reversalEv ? _this.phi : _this.theta;
                    return true;
                };

                this.isLowerAndroidChrome65 = function () {
                    var ua = navigator.userAgent.toLowerCase();

                    if (ua.indexOf('android') > -1 && ua.indexOf('chrome') > -1) {
                        var s = ua.match(/chrome\/([\d\.]+)/);

                        if (s && s.length > 1 && s[1]) {
                            var v = s[1].split('.');

                            if (v && v.length >= 1) {
                                return parseInt(v[0], 10) <= 65;
                            }
                        }
                    }
                };

                this.resetCameraPara(_camera);
                this.velo = 0.02;
                this.gyroStat = false;
                this.changed = false;
                this.hasOpened = false;
                this.isRadEvent = false; // MotionEvent

                this.checkedEventType = true;

                if (navigator.userAgent.toLowerCase().indexOf('android') > -1) {
                    var lowerChrome65 = this.isLowerAndroidChrome65();

                    if (lowerChrome65 !== undefined) {
                        this.isRadEvent = lowerChrome65;
                        this.checkedEventType = true;
                    } else {
                        this.isRadEvent = true;
                        this.checkedEventType = false;
                    }
                }
            }

            var _proto = GyroControls.prototype;

            _proto.isPitchEnabled = function isPitchEnabled() {
                return this.enabledPitch;
            };

            return GyroControls;
        }();

        var clock = new Clock();
        var SPEED_RATIO = Math.PI / 12000;
        var MOVE_THRESHOLD = 10 * (window.devicePixelRatio || 1);

        var ControllerManager = /*#__PURE__*/function () {
            function ControllerManager(viewer) {
                var _this = this;

                this.viewer = null;
                this.parameter = {};
                this.currentScene = null;
                this.camera = null;
                this.raycaster = null;
                this.isReady = false;
                this.dragControls = null;
                this.gyroControls = null;
                this.autoChanged = false;
                this.touching = false;
                this.interactiveTime = 0;
                this.speed = SPEED_RATIO;
                this.mouse = Object3DProxy.newVector2();
                this.mouseDown = false;
                this.mouseMove = false;
                this.curPoint = [];
                this.prePoint = [];
                this.pointerDistance = 0;
                this.enabledPitch = true;
                this.enablePinch = true;
                this.enableDrag = true;
                this.enableGyro = true;

                this.init = function () {
                    _this.raycaster = Object3DProxy.newRaycaster({});

                    _this.resetRaycaster();

                    return _this;
                };

                this.getIntersects = function (event) {
                    _this.mouse.x = event.clientX / _this.viewer.container.offsetWidth * 2 - 1;
                    _this.mouse.y = -(event.clientY / _this.viewer.container.offsetHeight) * 2 + 1;

                    _this.raycaster.setFromCamera(_this.mouse, _this.camera);

                    var res = _this.raycaster.intersectObjects(_this.currentScene.scene.children, true);

                    return res;
                };

                this.bindEvent = function (event, callback) {
                    if (!_this.raycaster) {
                        return;
                    }

                    var intersects = _this.getIntersects(event);

                    if (intersects.length > 0) {
                        var res = intersects.filter(function (res) {
                            return res && res.object;
                        })[0];
                        callback(res.object);
                    }
                };

                this.bindContainerMouseMove = function (event) {
                    _this.prePoint = _this.curPoint;

                    if (event.touches) {
                        event = event.touches[0];
                    }

                    _this.curPoint = [event.clientX, event.clientY];
                    var x = _this.curPoint[0] - _this.prePoint[0];
                    var y = _this.curPoint[1] - _this.prePoint[1];
                    _this.pointerDistance += Math.sqrt(x * x + y * y);

                    _this.bindEvent(event, function (obj) {
                        obj.dispatchEvent({
                            type: 'mouseover',
                            raycaster: _this.raycaster
                        });

                        if (_this.mouseDown) {
                            _this.mouseMove = true;

                            _this.viewer.dispatchEvent({
                                type: EVENT.PAUSE_AUTO_ROTATE
                            });
                        }
                    });
                };

                this.bindContainerTouchStart = function (event) {
                    // console.log('touch start');
                    _this.pointerDistance = 0;

                    if (event.touches) {
                        event = event.touches[0];
                    }

                    _this.curPoint = [event.clientX, event.clientY];
                    _this.mouseDown = true;
                };

                this.bindContainerTouchMove = function (event) {
                    // console.log('touch move');
                    _this.prePoint = _this.curPoint;

                    if (event.touches) {
                        event = event.touches[0];
                    }

                    _this.curPoint = [event.clientX, event.clientY];
                    var x = _this.curPoint[0] - _this.prePoint[0];
                    var y = _this.curPoint[1] - _this.prePoint[1];
                    _this.pointerDistance += Math.sqrt(x * x + y * y);

                    if (_this.mouseDown) {
                        _this.mouseMove = true;

                        _this.viewer.dispatchEvent({
                            type: EVENT.CONTROLLER_DRAG
                        });
                    }
                };

                this.bindContainerTouchEnd = function (event) {
                    // console.log('touch end');
                    _this.bindEvent(event, function (obj) {
                        // console.log('touch', obj);
                        if (_this.mouseDown && _this.pointerDistance <= MOVE_THRESHOLD) {
                            obj.dispatchEvent({
                                type: 'click'
                            });
                        }

                        _this.mouseDown = false;
                        _this.mouseMove = false;
                    });
                };

                this.onSceneReady = function (scene) {
                    _this.currentScene = scene;
                    _this.camera = scene.camera;

                    if (_this.dragControls && _this.gyroControls) {
                        _this.gyroControls.resetCameraPara(scene.camera);

                        _this.dragControls.resetCameraPara(scene.camera);
                    } else {
                        _this.dragControls = new DragControls(_this, _this.currentScene.camera, _this.viewer.container);
                        _this.gyroControls = new GyroControls(_this.currentScene.camera);

                        _this.reversalEvent(_this.viewer.config.reversalEvent | false);

                        _this.gyroControls["switch"](_this.enableGyro);

                        _this.gyroControls.pitchEnabled(_this.enabledPitch);

                        _this.dragControls["switch"](_this.enableDrag);

                        _this.dragControls.pinchEnable(_this.enablePinch);

                        _this.dragControls.setReversalEvent(_this.viewer.config.reversalEvent | false); // this.gyroControls.switch(this.viewer.config.gyro);

                    }

                    _this.gyroControls.setRotation(_this.camera.rotation.x, _this.camera.rotation.y); // this.resetRaycaster();


                    _this.isReady = true;
                };

                this.getFov = function () {
                    return _this.camera.getEffectiveFOV();
                };

                this.setFov = function (fov) {
                    _this.camera.fov = fov;

                    if (_this.dragControls) {
                        _this.dragControls.dstFov = _this.dragControls.curFov = fov;
                    }

                    _this.camera.updateProjectionMatrix();

                    return true;
                };

                this.getCameraRotation = function () {
                    if (!_this.camera) {
                        console.error('no camera exists');
                        return undefined;
                    }

                    return _this.camera.rotation;
                };

                this.getCameraQuaternion = function () {
                    if (!_this.camera) {
                        console.error('no camera exists');
                        return undefined;
                    }

                    var euler = _this.camera.rotation;
                    var q = new Quaternion().setFromEuler(euler);
                    return q;
                };

                this.setCameraRotation = function (rotation) {
                    var _this$gyroControls;

                    var x = rotation.x,
                        y = rotation.y,
                        z = rotation.z;

                    _this.camera.rotation.set(x, y, z);

                    (_this$gyroControls = _this.gyroControls) === null || _this$gyroControls === void 0 ? void 0 : _this$gyroControls.setRotation(x, y);

                    _this.camera.updateMatrix();

                    _this.camera.updateProjectionMatrix();

                    return true;
                };

                this.setCameraQuaternion = function (q) {
                    var _this$gyroControls2;

                    if (!_this.camera) {
                        console.error('no camera exists');
                        return false;
                    }

                    var x = q.x,
                        y = q.y,
                        z = q.z,
                        w = q.w;
                    var qt = new Quaternion(x, y, z, w);

                    _this.camera.quaternion.set(x, y, z, w);

                    _this.camera.rotation.setFromQuaternion(qt);

                    var r = _this.camera.rotation;
                    (_this$gyroControls2 = _this.gyroControls) === null || _this$gyroControls2 === void 0 ? void 0 : _this$gyroControls2.setRotation(r.x, r.y);

                    _this.camera.updateMatrix();

                    _this.camera.updateProjectionMatrix();

                    return true;
                };

                this.setCameraPosition = function (position) {
                    var x = position.x,
                        y = position.y,
                        z = position.z;

                    _this.camera.position.set(x, y, z);

                    _this.camera.updateMatrix();

                    _this.camera.updateProjectionMatrix();

                    return true;
                };

                this.getPitchRange = function () {
                    return _this.camera.pitchRange;
                };

                this.setPitchRange = function (pitchRange) {
                    console.log('pitch:', _this.currentScene.sceneId, pitchRange);
                    _this.camera.pitchRange = pitchRange;

                    _this.gyroControls.setPitchRange(pitchRange);

                    return true;
                };

                this.pitchEnabled = function (enable) {
                    var _this$gyroControls3;

                    _this.enabledPitch = enable;
                    (_this$gyroControls3 = _this.gyroControls) === null || _this$gyroControls3 === void 0 ? void 0 : _this$gyroControls3.pitchEnabled(enable);
                };

                this.isPitchEnabled = function () {
                    return _this.enabledPitch;
                };

                this.pinchEnable = function (enable) {
                    var _this$dragControls;

                    _this.enablePinch = enable;
                    (_this$dragControls = _this.dragControls) === null || _this$dragControls === void 0 ? void 0 : _this$dragControls.pinchEnable(enable);
                };

                this.dragEnable = function (enable) {
                    var _this$dragControls2;

                    _this.enableDrag = enable;
                    (_this$dragControls2 = _this.dragControls) === null || _this$dragControls2 === void 0 ? void 0 : _this$dragControls2.setEnable(enable);
                };

                this.isPinchEnabled = function () {
                    return _this.enablePinch;
                };

                this.setFovRange = function (fovRange) {
                    _this.camera.fovRange = fovRange;
                    _this.dragControls.fovRange = fovRange;
                    return true;
                };

                this.getFovRange = function () {
                    return _this.camera.fovRange;
                };

                this.isGyroOpen = function () {
                    var _this$gyroControls4;

                    return ((_this$gyroControls4 = _this.gyroControls) === null || _this$gyroControls4 === void 0 ? void 0 : _this$gyroControls4.isGyroOpen()) || false;
                };

                this.switchGyro = function (enable) {
                    var _this$gyroControls5;

                    _this.enableGyro = enable;
                    return (_this$gyroControls5 = _this.gyroControls) === null || _this$gyroControls5 === void 0 ? void 0 : _this$gyroControls5["switch"](enable);
                };

                this.switchDragControls = function (enable) {
                    if (_this.dragControls) {
                        _this.dragControls["switch"](enable);
                    }
                };

                this.update = function (time) {
                    var _this$dragControls3, _this$gyroControls6;

                    if (!_this.isReady) {
                        return;
                    }

                    (_this$dragControls3 = _this.dragControls) === null || _this$dragControls3 === void 0 ? void 0 : _this$dragControls3.update();
                    (_this$gyroControls6 = _this.gyroControls) === null || _this$gyroControls6 === void 0 ? void 0 : _this$gyroControls6.update();

                    _this.computeCameraChange();

                    clock.getDelta();
                };

                this.computeCameraChange = function () {
                    var _this$dragControls4, _this$dragControls5, _this$gyroControls7;

                    var rotation = _this.getCameraRotation();

                    var fov = _this.getFov();

                    if ((_this$dragControls4 = _this.dragControls) === null || _this$dragControls4 === void 0 ? void 0 : _this$dragControls4.changed) {
                        _this.viewer.dispatchEvent({
                            type: EVENT.CAMERA_CHANGE,
                            cause: 'touch',
                            fov: fov,
                            rotation: rotation
                        });

                        _this.dragControls.changed = false;
                    }

                    if ((_this$dragControls5 = _this.dragControls) === null || _this$dragControls5 === void 0 ? void 0 : _this$dragControls5.fovChanged) {
                        _this.viewer.dispatchEvent({
                            type: EVENT.CAMERA_CHANGE,
                            cause: 'touch-pinch',
                            fov: fov,
                            rotation: rotation
                        });

                        _this.dragControls.fovChanged = false;
                    }

                    if (_this.autoChanged) {
                        _this.viewer.dispatchEvent({
                            type: EVENT.CAMERA_CHANGE,
                            cause: 'auto',
                            fov: fov,
                            rotation: rotation
                        });

                        _this.autoChanged = false;
                    }

                    if ((_this$gyroControls7 = _this.gyroControls) === null || _this$gyroControls7 === void 0 ? void 0 : _this$gyroControls7.changed) {
                        _this.viewer.dispatchEvent({
                            type: EVENT.CAMERA_CHANGE,
                            cause: 'gyro',
                            fov: fov,
                            rotation: rotation
                        });

                        _this.gyroControls.changed = false;
                    }
                };

                this.reversalEvent = function (b) {
                    _this.gyroControls.reversalEv = b;
                };

                this.viewer = viewer; // 3ddomlick3dlick
            }

            var _proto = ControllerManager.prototype;

            _proto.removeListeners = function removeListeners() {
                var _this$dragControls6;

                this.viewer.container.removeEventListener('mousedown', this.bindContainerTouchStart);
                this.viewer.container.removeEventListener('mousemove', this.bindContainerMouseMove);
                this.viewer.container.removeEventListener('click', this.bindContainerTouchEnd);
                this.viewer.container.removeEventListener('touchstart', this.bindContainerTouchStart);
                this.viewer.container.removeEventListener('touchmove', this.bindContainerTouchMove);
                (_this$dragControls6 = this.dragControls) === null || _this$dragControls6 === void 0 ? void 0 : _this$dragControls6.removeListeners();
            };

            _proto.addListeners = function addListeners() {
                var _this$dragControls7;

                this.viewer.container.addEventListener('mousedown', this.bindContainerTouchStart, false);
                this.viewer.container.addEventListener('mousemove', this.bindContainerMouseMove, false);
                this.viewer.container.addEventListener('click', this.bindContainerTouchEnd, false);
                this.viewer.container.addEventListener('touchstart', this.bindContainerTouchStart, false);
                this.viewer.container.addEventListener('touchmove', this.bindContainerTouchMove, false);
                (_this$dragControls7 = this.dragControls) === null || _this$dragControls7 === void 0 ? void 0 : _this$dragControls7.addListeners();
            };

            _proto.resetRaycaster = function resetRaycaster() {
                this.removeListeners();
                this.addListeners();
            };

            _proto.destroy = function destroy() {
                this.removeListeners();
                this.currentScene = this.camera = this.raycaster = null;
                this.dragControls = this.gyroControls = null;
            };

            return ControllerManager;
        }();

        function disablePointerEvent(nodeEle) {
            nodeEle.style.pointerEvents = 'none';
        }
        function enablePointerEvent(nodeEle) {
            nodeEle.style.pointerEvents = 'all';
        }

        /*
	 * @files: version.js
	 * @Author: guowubiao
	 * @Date: 2020-03-18 13:14
	 */
        var SDK_VERSION = '1.0.0.1';
        var SDK_SUPPLY_ID = 1;

        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function (obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function (obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }

            return _typeof(obj);
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
        }
        /**
         * @file vr-report module
         * @author xiaolong
         */
        //  http://agroup.baidu.com/sw_bb_rd_kernel/md/article/1461284

        /**
         * @description ey
         */


        var bodyContent = {
            common: 'c',
            // body
            diffrenet: 'd' // body

        };
        var keyId = {
            defaulted: 0,
            // 
            softId: 'soft_id',
            //   ---int
            deviceId: 'cid',
            //   ---string
            packageVersion: 'cversion',
            //   ---string
            ipAddress: 'cip',
            // P  ---string
            osType: 'os_type',
            // (windows, mac, ios, android)  ---string
            osVersion: 'os_version',
            //   ---string
            customId: 'custom_id',
            // ID ---string
            supplyId: 'supply_id',
            //  ---int
            reportLevel: "X-report-level",
            // 1
            reportNouce: 'X-report-nouce',
            // 
            //   
            timeStamp: 'send_ts',
            // NIX() ---int
            protocolVersion: 'protocol_version',
            // 
            userId: 'user_id',
            // UID ---int
            // 
            cmdId: 'cmd_id' // ---int

        };
        /**
         * @description 
         */

        var ReportUtils = /*#__PURE__*/function () {
            function ReportUtils() {
                _classCallCheck(this, ReportUtils);

                this.header = {
                    'content-type': 'application/json; charset=utf-8'
                };
                this.request = this.browserPostData;
            }

            _createClass(ReportUtils, [{
                key: "postData",
                value: function postData(url, body, callback) {
                    var header = {};
                    header[keyId.reportNouce] = Date.now() + '.' + this._generateRandomID(8);
                    this.extendJson(header, this.header);

                    this._replaceUndefineKey(body);

                    this.request({
                        url: url,
                        method: 'post',
                        json: true,
                        headers: header,
                        body: body
                    }, function (error, response, body) {
                        // error=null respone=res body=chunck
                        var statusCode = null;

                        if (response) {
                            statusCode = response.statusCode;
                        }

                        callback({
                            statusCode: statusCode,
                            response: response,
                            body: body
                        });
                    });
                }
            }, {
                key: "extendJson",
                value: function extendJson(target, source) {
                    for (var obj in source) {
                        target[obj] = source[obj];
                    }

                    return target;
                }
            }, {
                key: "deepCopy",
                value: function deepCopy(source) {
                    var result = {};

                    for (var key in source) {
                        result[key] = _typeof(source[key]) === 'object' ? this.deepCopy(source[key]) : source[key];
                    }

                    return result;
                }
            }, {
                key: "extendHeader",
                value: function extendHeader(content) {
                    this.extendJson(this.header, content);
                }
            }, {
                key: "initHeader",
                value: function initHeader() {
                    this.header = {
                        'content-type': 'application/json; charset=utf-8'
                    };
                }
            }, {
                key: "isNodeClient",
                value: function isNodeClient() {
                    var result = typeof window === 'undefined' ? true : false;
                    return result;
                }
            }, {
                key: "_generateRandomID",
                value: function _generateRandomID(n) {
                    var rnd = '';

                    for (var i = 0; i < n; ++i) {
                        rnd += Math.floor(Math.random() * 10);
                    }

                    return rnd;
                }
            }, {
                key: "_replaceUndefineKey",
                value: function _replaceUndefineKey(json) {
                    if (json.length >= 1) {
                        for (var i = 0, l = json.length; i < l; ++i) {
                            this._replaceUndefineKey(json[i]);
                        }
                    } else {
                        for (var key in json) {
                            var element = json[key];

                            if (!element && element !== 0 && element !== false) {
                                json[key] = '';
                            } else if (_typeof(element) == "object") {
                                this._replaceUndefineKey(element);
                            }
                        }
                    }
                }
            }, {
                key: "generateUUID",
                value: function generateUUID() {
                    var d = new Date().getTime();
                    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                        var r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
                    });
                    return uuid;
                }
            }, {
                key: "browserPostData",
                value: function browserPostData(info, callback) {
                    // Default options are marked with *
                    fetch(info.url, {
                        body: JSON.stringify(info.body),
                        // must match 'Content-Type' header
                        cache: 'no-cache',
                        // *default, no-cache, reload, force-cache, only-if-cached
                        credentials: 'include',
                        // include, same-origin, *omit
                        headers: new Headers(info.headers),
                        method: info.method,
                        // *GET, POST, PUT, DELETE, etc.
                        mode: 'cors',
                        // no-cors, cors, *same-origin
                        redirect: 'follow',
                        // manual, *follow, error
                        referrer: 'no-referrer' // *client, no-referrer

                    }).then(function (response) {
                        return response.json().then(function (body) {
                            callback(null, {
                                statusCode: response.status
                            }, body);
                        });
                    })["catch"](function (error) {
                        console.error('Error:', error);
                        callback(error, null, null);
                    });
                }
            }]);

            return ReportUtils;
        }();

        var reportUtils = new ReportUtils();
        /**
         * @file vr-report module
         * @author xiaolong
         */

        var BaseReport = /*#__PURE__*/function () {
            function BaseReport(name) {
                _classCallCheck(this, BaseReport);

                this.className = null;
                this.dataReportManager = null;
                this.init(name);
            }

            _createClass(BaseReport, [{
                key: "init",
                value: function init(name) {
                    this.className = name;
                }
            }, {
                key: "attachDataReportManager",
                value: function attachDataReportManager(dataReportManager) {
                    this.dataReportManager = dataReportManager;
                }
            }, {
                key: "getClassName",
                value: function getClassName() {
                    return this.className;
                }
            }]);

            return BaseReport;
        }();
        /**
         * @description 
         */


        var DataReportManager = /*#__PURE__*/function () {
            function DataReportManager() {
                _classCallCheck(this, DataReportManager);

                this.url = null;
                this.headerPublicInfo = {};
                this.bodyPublicInfo = {};
                this.reportInstances = {};
                this.isOpenLog = true;
                this.isOpenReport = true;
                this.logFunction = null;
                this.reportBuffer = [];
                this.reportTimer = null;
            }
            /**
             * @description 
             * @param {string} url  rl
             * @param {Object} headerPublicInfo  httpRey
             * @param {Object} bodyPublicInfo  
             * @param() {instance} reportInstances  
             */


            _createClass(DataReportManager, [{
                key: "init",
                value: function init(url, headerPublicInfo, bodyPublicInfo) {
                    var reportInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
                    this.url = url; // header

                    this.headerPublicInfo = headerPublicInfo;
                    this.headerPublicInfo[keyId.reportLevel] = 1;
                    reportUtils.extendHeader(this.headerPublicInfo); // body

                    this.bodyPublicInfo = bodyPublicInfo; // 

                    for (var instance in reportInstances) {
                        if (reportInstances[instance] instanceof BaseReport) {
                            reportInstances[instance].attachDataReportManager(this);
                            this.reportInstances[instance] = reportInstances[instance];
                        }
                    }

                    this._cycleReport();
                }
                /**
                 * @description 
                 * @param {Object} headerPublicInfo  httpRey
                 */

            }, {
                key: "addHeaderPublicInfo",
                value: function addHeaderPublicInfo(headerPublicInfo) {
                    for (var key in headerPublicInfo) {
                        this.headerPublicInfo[key] = headerPublicInfo[key];
                    }

                    reportUtils.extendHeader(this.headerPublicInfo);
                }
                /**
                 * @description 
                 * @param {Object} bodyPublicInfo  
                 */

            }, {
                key: "addBodyPublicInfo",
                value: function addBodyPublicInfo(bodyPublicInfo) {
                    for (var key in bodyPublicInfo) {
                        this.bodyPublicInfo[key] = bodyPublicInfo[key];
                    }
                }
                /**
                 * @description 
                 * @param {instance} instanceReport  xample
                 */

            }, {
                key: "attachCmdClass",
                value: function attachCmdClass(instanceReport) {
                    instanceReport.attachDataReportManager(this);
                    this.reportInstances[instanceReport.getClassName()] = instanceReport;
                }
                /**
                 * @description 
                 */

            }, {
                key: "unInit",
                value: function unInit() {
                    clearInterval(this.reportTimer);
                }
                /**
                 * @description log
                 * @param {boolean} isOpen  log
                 */

            }, {
                key: "setIsOpenLog",
                value: function setIsOpenLog(isOpen) {
                    this.isOpenLog = isOpen;
                }
                /**
                 * @description 
                 * @param {boolean} isOpen  
                 */

            }, {
                key: "setIsOpenReport",
                value: function setIsOpenReport(isOpen) {
                    this.isOpenReport = isOpen;
                }
                /**
                 * @description 
                 * @param {number} cmdId  d
                 * @param {Object} dataD  
                 * @param {Function} callback  
                 */

            }, {
                key: "immediatelyReportData",
                value: function immediatelyReportData(cmdId, dataD, callback) {
                    var _this = this;

                    if (this.isOpenReport) {
                        var data = {};
                        data[bodyContent.common] = reportUtils.deepCopy(this.bodyPublicInfo);
                        data[bodyContent.common][keyId.cmdId] = cmdId;
                        data[bodyContent.common][keyId.timeStamp] = Date.now(); // data[reportConfig.bodyContent.common][reportConfig.keyId.protocolVersion] = 'v1';

                        data[bodyContent.diffrenet] = dataD;
                        var contentUUID = reportUtils.generateUUID();

                        this._outLog("".concat(contentUUID, "# immediatelyReportData send request content: ") + JSON.stringify(data));

                        reportUtils.postData(this.url, data, function (result) {
                            _this._outLog("".concat(contentUUID, "# immediatelyReportData post result: ") + JSON.stringify(result));

                            if (result.statusCode !== 200) {
                                _this.reportBuffer.push(data);
                            }

                            callback(result);
                        });
                    }
                }
                /**
                 * @description 10
                 * @param {number} cmdId  d
                 * @param {Object} dataD  
                 */

            }, {
                key: "delayReportData",
                value: function delayReportData(cmdId, dataD) {
                    if (this.isOpenReport) {
                        var data = {};
                        data[bodyContent.common] = reportUtils.deepCopy(this.bodyPublicInfo);
                        data[bodyContent.common][keyId.cmdId] = cmdId;
                        data[bodyContent.common][keyId.timeStamp] = Date.now(); // data[reportConfig.bodyContent.common][reportConfig.keyId.protocolVersion] = 'v1';

                        data[bodyContent.diffrenet] = dataD;

                        this._outLog('delayReportData push content: ' + JSON.stringify(data));

                        this.reportBuffer.push(data);
                    }
                }
            }, {
                key: "_cycleReport",
                value: function _cycleReport() {
                    var _this2 = this;

                    this.reportTimer = setInterval(function () {
                        if (_this2.reportBuffer && _this2.reportBuffer.length > 0) {
                            var contentUUID = reportUtils.generateUUID();

                            _this2._outLog("".concat(contentUUID, "# _cycleReport content: ") + JSON.stringify(_this2.reportBuffer));

                            reportUtils.postData(_this2.url, _this2.reportBuffer, function (result) {
                                _this2._outLog("".concat(contentUUID, "# _cycleReport post result: ") + JSON.stringify(result));

                                if (result.statusCode === 200) {
                                    _this2.reportBuffer = [];
                                }
                            });
                        }
                    }, 10000);
                }
                /**
                 * @description 
                 */

            }, {
                key: "flushReport",
                value: function flushReport() {
                    var _this3 = this;

                    if (this.reportBuffer && this.reportBuffer.length > 0) {
                        var contentUUID = reportUtils.generateUUID();

                        this._outLog("".concat(contentUUID, "# flushReport content: ") + JSON.stringify(this.reportBuffer));

                        reportUtils.postData(this.url, this.reportBuffer, function (result) {
                            _this3._outLog("".concat(contentUUID, "# flushReport post result: ") + JSON.stringify(result));

                            if (result.statusCode === 200) {
                                _this3.reportBuffer = [];
                            }
                        });
                    }
                }
                /**
                 * @description log
                 * @param {Function} reoprtFunc  log
                 */

            }, {
                key: "setReportLogFunction",
                value: function setReportLogFunction(reoprtFunc) {
                    this.logFunction = reoprtFunc;
                }
            }, {
                key: "_outLog",
                value: function _outLog(result) {
                    if (this.isOpenLog) {
                        if (this.logFunction) {
                            this.logFunction(result);
                            this.logFunction(result);
                        } else {
                            console.log('DataReportManager log output: ' + result);
                        }
                    }
                }
            }, {
                key: "login",
                value: function login(uid) {
                    this.bodyPublicInfo[keyId.userId] = uid;
                }
            }, {
                key: "logout",
                value: function logout() {
                    this.bodyPublicInfo[keyId.userId] = '';
                }
            }]);

            return DataReportManager;
        }();

        var dataReportManager = new DataReportManager();

        /*
	 * @files: detect.js
	 * @Author: guowubiao
	 * @Date: 2020-03-17 17:48
	 */
        var ua = navigator.userAgent.toLowerCase();

        function getOSInfo() {
            var name = 'Unknown';
            var version = 'Unknown';

            if (ua.indexOf('win') > -1) {
                name = 'Windows';

                if (ua.indexOf('windows nt 5.0') > -1) {
                    version = 'Windows 2000';
                } else if (ua.indexOf('windows nt 5.1') > -1 || ua.indexOf('windows nt 5.2') > -1) {
                    version = 'Windows XP';
                } else if (ua.indexOf('windows nt 6.0') > -1) {
                    version = 'Windows Vista';
                } else if (ua.indexOf('windows nt 6.1') > -1 || ua.indexOf('windows 7') > -1) {
                    version = 'Windows 7';
                } else if (ua.indexOf('windows nt 6.2') > -1 || ua.indexOf('windows 8') > -1) {
                    version = 'Windows 8';
                } else if (ua.indexOf('windows nt 6.3') > -1) {
                    version = 'Windows 8.1';
                } else if (ua.indexOf('windows nt 6.2') > -1 || ua.indexOf('windows nt 10.0') > -1) {
                    version = 'Windows 10';
                } else {
                    version = 'Unknown';
                }
            } else if (ua.indexOf('iphone') > -1) {
                name = 'Iphone';
                version = _findVersion('os ');
            } else if (ua.indexOf('mac') > -1) {
                name = 'Mac';
                version = _findVersion('mac os x ');
            } else if (ua.indexOf('x11') > -1 || ua.indexOf('unix') > -1 || ua.indexOf('sunname') > -1 || ua.indexOf('bsd') > -1) {
                name = 'Unix';
            } else if (ua.indexOf('linux') > -1) {
                if (ua.indexOf('android') > -1) {
                    name = 'Android';
                    version = _findVersion('android ');
                } else {
                    name = 'Linux';
                }
            } else {
                name = 'Unknown';
            }

            return {
                name: name,
                version: version
            };
        }

        function _findVersion(key) {
            if (ua.indexOf(key) > 0) {
                var reg = new RegExp(key + '[\\d._]+', 'gi');
                var v_info = ua.match(reg);
                return (v_info + '').replace(/[^0-9|_.]/gi, '').replace(/_/gi, '.');
            }

            return 'Unknown';
        }

        function getBrowserInfo() {
            var name = 'Unknown';
            var names = {
                IE: window.ActiveXObject || 'ActiveXObject' in window,
                // IE
                Chrome: ua.indexOf('chrome') > -1 && ua.indexOf('safari') > -1,
                // Chrome
                Firefox: ua.indexOf('firefox') > -1,
                // 
                Opera: ua.indexOf('opera') > -1,
                // Opera
                Safari: ua.indexOf('safari') > -1 && ua.indexOf('chrome') === -1,
                // safari
                Edge: ua.indexOf('edge') > -1,
                // Edge
                QQBrowser: /qqbrowser/.test(ua),
                // qq
                WeixinBrowser: /micromessenger/.test(ua),
                // 
                BaiduBrowser: /baidubrowser/.test(ua),
                // 
                BaiduAPP: /baiduboxapp/.test(ua),
                // 
                UCBrowser: /ucbrowser/.test(ua) // UC

            }; // eslint-disable-next-line no-unused-vars

            for (var n in names) {
                if (names[n]) {
                    name = n;
                }
            }

            var v;
            v = (v = ua.match(/rv:([\d.]+)\) like gecko/)) ? v[1] : (v = ua.match(/msie ([\d\.]+)/)) ? v[1] : (v = ua.match(/edge\/([\d\.]+)/)) ? v[1] : (v = ua.match(/firefox\/([\d\.]+)/)) ? v[1] : (v = ua.match(/(?:opera|opr).([\d\.]+)/)) ? v[1] : (v = ua.match(/chrome\/([\d\.]+)/)) ? v[1] : (v = ua.match(/version\/([\d\.]+).*safari/)) ? v[1] : 'Unknown';
            return {
                name: name,
                version: v
            };
        }

        function isIp() {
            var origin = location.hostname;
            var regexp = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
            var valid = regexp.test(origin);

            if (!valid) {
                return false;
            }

            return origin.split('.').every(function (num) {
                if (num.length > 1 && num.charAt(0) === '0') {
                    return false;
                } else if (parseInt(num, 10) > 255) {
                    return false;
                }

                return true;
            });
        }

        function isLocalHost() {
            var origin = location.hostname;
            return -1 < origin.indexOf('localhost');
        }

        const CMD_ID = {
            PV: 101,
            ERROR: 102 // 
        };
        var PV_REPORT_KEY;
        (function (PV_REPORT_KEY) {
            PV_REPORT_KEY[PV_REPORT_KEY["resource_type"] = 1] = "resource_type";
            PV_REPORT_KEY[PV_REPORT_KEY["site_url"] = 2] = "site_url";
            PV_REPORT_KEY[PV_REPORT_KEY["pv"] = 3] = "pv";
        })(PV_REPORT_KEY || (PV_REPORT_KEY = {}));
        var ERROR_REPORT_KEY;
        (function (ERROR_REPORT_KEY) {
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["resource_type"] = 1] = "resource_type";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["site_url"] = 2] = "site_url";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["error_type"] = 3] = "error_type";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["error_stack"] = 4] = "error_stack";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["error_src"] = 5] = "error_src";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["error_msg"] = 6] = "error_msg";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["colno"] = 7] = "colno";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["lineno"] = 8] = "lineno";
            ERROR_REPORT_KEY[ERROR_REPORT_KEY["filename"] = 9] = "filename";
        })(ERROR_REPORT_KEY || (ERROR_REPORT_KEY = {}));

        //@ts-ignore
        class TechReporter extends BaseReport {
            getClassName() {
                return 'TechReport';
            }
            reportPV(data, callback) {
                if (isIp() || isLocalHost()) {
                    return;
                }
                let reportData = Object.assign({ site_url: window.location.href, pv: 1 }, data);
                this.dataReportManager.immediatelyReportData(CMD_ID.PV, {
                    [PV_REPORT_KEY.resource_type]: reportData.resource_type,
                    [PV_REPORT_KEY.pv]: reportData.pv,
                    [PV_REPORT_KEY.site_url]: reportData.site_url
                }, () => {
                    callback === null || callback === void 0 ? void 0 : callback();
                });
            }
            reportError(event, data, callback) {
                var _a, _b, _c, _d, _e, _f;
                if (isIp() || isLocalHost()) {
                    return;
                }
                if (event instanceof ErrorEvent) {
                    let reportData = Object.assign(Object.assign({ colno: event.colno, lineno: event.lineno, filename: event.filename }, data), (event.error.data || {}));
                    this.dataReportManager.immediatelyReportData(CMD_ID.ERROR, {
                            [ERROR_REPORT_KEY.resource_type]: reportData.resource_type,
                            [ERROR_REPORT_KEY.site_url]: window.location.href,
                            [ERROR_REPORT_KEY.error_type]: reportData.error_type || 'unknown hydreigon sdk error',
                            [ERROR_REPORT_KEY.error_stack]: reportData.error_stack || event.error.stack,
                            [ERROR_REPORT_KEY.error_src]: reportData.error_src,
                            [ERROR_REPORT_KEY.error_msg]: reportData.error_msg || event.error.message,
                            [ERROR_REPORT_KEY.colno]: reportData.colno,
                            [ERROR_REPORT_KEY.lineno]: reportData.lineno,
                            [ERROR_REPORT_KEY.filename]: reportData.filename
                        },
                        //@ts-ignore
                        error => {
                            callback === null || callback === void 0 ? void 0 : callback(error);
                        });
                }
                else if (event instanceof WebGLContextEvent) {
                    let reportData = Object.assign(Object.assign({}, data), { error_type: event.type });
                    this.dataReportManager.immediatelyReportData(CMD_ID.ERROR, {
                            [ERROR_REPORT_KEY.resource_type]: reportData.resource_type,
                            [ERROR_REPORT_KEY.site_url]: window.location.href,
                            [ERROR_REPORT_KEY.error_type]: reportData.error_type
                        },
                        //@ts-ignore
                        error => {
                            callback === null || callback === void 0 ? void 0 : callback(error);
                        });
                }
                else {
                    let reportData = Object.assign(Object.assign(Object.assign({}, data), event.reason), (event.reason.data || {}));
                    this.dataReportManager.immediatelyReportData(CMD_ID.ERROR, {
                            [ERROR_REPORT_KEY.resource_type]: reportData.resource_type,
                            [ERROR_REPORT_KEY.site_url]: window.location.href,
                            [ERROR_REPORT_KEY.error_type]: reportData.error_type || 'unknown hydreigon sdk error',
                            [ERROR_REPORT_KEY.error_msg]: ((_a = event.reason) === null || _a === void 0 ? void 0 : _a.message) || ((_c = (_b = event.reason) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.error_msg) || '',
                            [ERROR_REPORT_KEY.error_stack]: ((_d = event.reason) === null || _d === void 0 ? void 0 : _d.stack) || ((_f = (_e = event.reason) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.error_stack) || ''
                        },
                        //@ts-ignore
                        error => {
                            callback === null || callback === void 0 ? void 0 : callback(error);
                        });
                }
            }
        }

        //@ts-ignore
        const os = getOSInfo();
        const browser = getBrowserInfo();
        const TEST_URL = '//vr-data.baidu-int.com/report/to/penglai';
        const PROD_URL = '//vr-data.baidu.com/report/to/penglai';
        const PROD_DOMAINS = ['penglai.baidu.com', 'vr.baidu.com'];
        const HEAD_PUBLIC_INFO = {
            soft_id: 324,
            cid: '1',
            cversion: SDK_VERSION,
            cip: '0',
            os_type: os.name,
            os_version: os.version,
            custom_id: '0',
            supply_id: 0
        };
        const BODY_PUBLIC_INFO = {
            protocol_version: 'v1',
            browser_type: browser.name,
            browser_version: browser.version,
            send_ts: 0
        };
        function initPaloReporter(supplyId, customId) {
            const head_info = Object.assign(Object.assign({}, HEAD_PUBLIC_INFO), { supply_id: supplyId, custom_id: customId });
            let reportUrl;
            if (PROD_DOMAINS.includes(location.hostname)) {
                reportUrl = PROD_URL;
            }
            else if (location.hostname.indexOf('.baidu.') > -1) {
                // 
                reportUrl = TEST_URL;
            }
            else {
                reportUrl = PROD_URL;
            }
            //@ts-ignore
            dataReportManager.unInit();
            //@ts-ignore
            dataReportManager.init(reportUrl, head_info, BODY_PUBLIC_INFO, {
                techReporter: new TechReporter()
            });
        }
        function getTechReporter() {
            return dataReportManager.reportInstances.techReporter || null;
        }

        /*
	 * @file: ReporterManager
	 * @author: yuanzhenkun@baidu.com
	 * @Date: 2019-08-21 14:33:02
	 * @description:
	 */
        var debugPkg = false;

        try {
            if ("PRO" === 'DEV') {
                debugPkg = true;
            }
        } catch (e) {
            console.log(e.message);
        }

        var Reporter$1 = function Reporter() {
            var _this = this;

            this.init = function (debug) {
                if (debug === void 0) {
                    debug = false;
                }

                if (_this._inited) {
                    return;
                }

                _this._inited = true;
                _this.debug = debug;

                _this.reportPVDirectly(); // if (!window._hmt) {
                //     window._hmt = [];
                // }
                // const siteId = this.getSrc();
                // let hm = document.createElement('script');
                // hm.src = 'https://hm.baidu.com/hm.js?' + siteId;
                // let s = document.getElementsByTagName('script')[0];
                // s.parentNode.insertBefore(hm, s);
                // window._hmt.push(['_setAccount', siteId]);
                // window.addEventListener('error', this._onErrorListener);

            };

            this.reportPVDirectly = function () {
                var img = new Image();
                img.src = "https://hm.baidu.com/hm.gif?si=" + _this.getSrc() + "&et=0&nv=0&st=4&v=pixel-1.0&rnd=" + Math.floor(Math.random() * 0x80000000);
            };

            this.getSrc = function () {
                if (debugPkg || _this.isIp() || _this.debug) {
                    // debug || releasep || releaseebug
                    return _this.getSrcByEnv(false);
                } else {
                    return _this.getSrcByEnv(true);
                }
            };

            this.isIp = function () {
                var origin = location.hostname;
                var regexp = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
                var valid = regexp.test(origin);

                if (!valid) {
                    return false;
                }

                return origin.split('.').every(function (num) {
                    if (num.length > 1 && num.charAt(0) === '0') {
                        return false;
                    } else if (parseInt(num, 10) > 255) {
                        return false;
                    }

                    return true;
                });
            };

            this.getSrcByEnv = function (isRelease) {
                return isRelease ? '9d8640117b20e49fe09d33f851e0b1a1' // release
                    : '782cda46d107a645d6a739a968454479'; // debug
            };

            this._onErrorListener = function (event) {
                console.log(event);

                _this.reportEvent('error', 'error', 'error', event.message);
            };

            this.reportEvent = function (module, action, optLabel, optValue) {
                if (optLabel === void 0) {
                    optLabel = 'defaultLable';
                }

                if (optValue === void 0) {
                    optValue = 1;
                }

                // console.log('report');
                // window._hmt.push(['_trackEvent', module, action, optLabel, optValue]);
                var img = new Image();
                img.src = "https://hm.baidu.com/hm.gif?si=" + _this.getSrc() + "&et=4&ep=" + module + "*" + action + "*" + optLabel + "*" + optValue + "&nv=0&st=4&v=pixel-1.0&rnd=" + Math.floor(Math.random() * 0x80000000);
            };

            this._inited = false;
        };

        var HMReporter = new Reporter$1();

        class VRError extends Error {
            /**
             * @param message
             */
            constructor(message) {
                super(message);
                this.message = message;
            }
        }

        //  SDK 
        class ReporterManager {
            constructor() {
                this._enable = true; // sdk
                this._inited = false;
                this.initEnableState();
            }
            init(supplyId, customId, debug = false) {
                if (!this._enable) {
                    return;
                }
                if (!this._inited) {
                    this._inited = true;
                    HMReporter.init(debug);
                    initPaloReporter(supplyId, customId);
                }
            }
            reportPV(data, callback) {
                var _a;
                if (!this._enable) {
                    return;
                }
                if (!('resource_type' in data)) {
                    throw new VRError("the data has not property 'resource_type'");
                }
                // 
                HMReporter.reportPVDirectly();
                // palo 
                (_a = getTechReporter()) === null || _a === void 0 ? void 0 : _a.reportPV(data, callback);
            }
            reportError(event, data, callback) {
                if (!this._enable) {
                    return;
                }
                if (!('resource_type' in data)) {
                    console.warn("the data has not property 'resource_type'");
                    return;
                }
                const techReporter = getTechReporter();
                if (!techReporter) {
                    console.log('the init function of the Reporter may not be called');
                    return;
                }
                techReporter.reportError(event, data, callback);
            }
            initEnableState() {
                this._enable = isIp() || isLocalHost() ? false : true;
            }
        }
        function handleAndFilterError(event, data) {
            var _a, _b, _c, _d;
            let error;
            if (event instanceof ErrorEvent) {
                error = event.error;
            }
            else if (event instanceof WebGLContextEvent) {
                error = new VRError('vr webgl context lost');
            }
            else {
                error = event.reason;
            }
            // yd
            if (error &&
                (error instanceof VRError ||
                    ((_a = error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('vr')) ||
                    ((_b = error.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(error).includes('sdk')) ||
                    ((_c = error.toLowerCase) === null || _c === void 0 ? void 0 : _c.call(error).includes('hydreigon')) ||
                    ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.includes('hydreigon')))) {
                Reporter$2.reportError(event, data);
            }
        }
        const Reporter$2 = new ReporterManager();

        var EVENTS_INNER;
        (function (EVENTS_INNER) {
            EVENTS_INNER["ZOOM_FROM_HOME"] = "hyd-inner-zoom-from-home";
            EVENTS_INNER["ZOOM_TO_HOME"] = "hyd-inner-zoom-to-home";
            EVENTS_INNER["ZOOM_FROM_MAX"] = "hyd-inner-zoom-from-max";
            EVENTS_INNER["ZOOM_TO_MAX"] = "hyd-inner-zoom-to-max";
            EVENTS_INNER["ZOOM_CHANGE"] = "hyd-inner-zoom-change";
            EVENTS_INNER["SPIN"] = "hyd-inner-view-spin";
            EVENTS_INNER["SPIN_START"] = "hyd-inner-view-spin-start";
            EVENTS_INNER["ROTATE_START"] = "hyd-inner-rotate-start";
            EVENTS_INNER["IMAGE_ERROR"] = "hyd-inner-image-error";
            EVENTS_INNER["FORCE_UPDATE_CONTROL_CAMERA_ROTATION"] = "FORCE_UPDATE_CONTROL_CAMERA_ROTATION";
        })(EVENTS_INNER || (EVENTS_INNER = {}));

        var AnimationState;
        (function (AnimationState) {
            AnimationState["START"] = "start";
            AnimationState["STOP"] = "stop";
            AnimationState["PAUSE"] = "pause";
            AnimationState["RESUME"] = "resume";
            AnimationState["UPDATE"] = "update";
        })(AnimationState || (AnimationState = {}));
        const EXPIRE_TIME = 100;
        class AbstractAnimation extends EventDispatcher {
            constructor(name, duration = 0) {
                super();
                this.duration = 0;
                this.lastTime = 0;
                this.currentTime = 0;
                this.deltaTime = 0;
                this.totalTime = 0;
                this.queueKey = Symbol();
                this.state = AnimationState.STOP;
                this.name = name;
                this.duration = duration;
            }
            update() {
                if (this.state !== AnimationState.START) {
                    return this;
                }
                this.lastTime = this.currentTime;
                this.currentTime = Date.now();
                this.deltaTime = this.currentTime - this.lastTime;
                if (this.deltaTime >= EXPIRE_TIME) {
                    return this;
                }
                this.totalTime += Math.min(this.deltaTime, 20);
                // 
                this.onUpdate();
                this.dispatchEvent({ type: AnimationState.UPDATE, target: this });
                return this;
            }
            start(needEvent = true) {
                // 
                if (this.state !== AnimationState.STOP) {
                    return this;
                }
                this.totalTime = 0;
                this.lastTime = Date.now();
                this.currentTime = Date.now();
                this.state = AnimationState.START;
                needEvent &&
                this.dispatchEvent({
                    type: AnimationState.START,
                    target: this
                });
                return this;
            }
            stop(needEvent = true) {
                // 
                this.totalTime = 0;
                this.lastTime = 0;
                this.currentTime = 0;
                this.state = AnimationState.STOP;
                needEvent &&
                this.dispatchEvent({
                    type: AnimationState.STOP,
                    target: this
                });
                return this;
            }
            pause() {
                // 
                if (this.state !== AnimationState.START) {
                    return this;
                }
                this.state = AnimationState.PAUSE;
                this.dispatchEvent({
                    type: AnimationState.PAUSE,
                    target: this
                });
                return this;
            }
            resume() {
                // 
                if (this.state !== AnimationState.PAUSE) {
                    return this;
                }
                this.lastTime = Date.now();
                this.currentTime = Date.now();
                this.dispatchEvent({
                    type: AnimationState.RESUME,
                    target: this
                });
                return this;
            }
        }
        AbstractAnimation.AnimationState = AnimationState;

        const SPEED_RATIO$1 = Math.PI / 12000;
        class AutoRotationAnimation extends AbstractAnimation {
            constructor(panoViewer, delay = 3000, speed = 4) {
                super('AutoRotationAnimation', Infinity);
                this.config = null;
                this.camera = null;
                this.delay = 1500;
                this.onUpdate = () => {
                    if (this.needPause) {
                        return;
                    }
                    let { x, y, z } = this.camera.rotation;
                    y += (SPEED_RATIO$1 * this.speed * this.deltaTime) / 16;
                    this.camera.rotation.set(x, y, z);
                    this.view.dispatchEvent({
                        type: EVENT.CAMERA_CHANGE,
                        cause: 'anim',
                        fov: this.camera.fov,
                        rotation: {
                            x: this.camera.rotation.x,
                            y: this.camera.rotation.y,
                            z
                        }
                    });
                };
                this.delay = delay;
                this.speed = speed;
                this.view = panoViewer;
                this.camera = panoViewer.story.currentScene.camera;
                this.needPause = false;
                // panoViewer.addEventListener(EVENT.CONTROLLER_DRAG, () => {
                //     this.needPause = true;
                //     if (timeout !== false) {
                //         clearTimeout(timeout);
                //     }
                // });
                // // delay
                // panoViewer.container.addEventListener('click', () => {
                //     timeout = setTimeout(() => {
                //         this.needPause = false;
                //     }, delay) as any;
                // });
            }
            dispose() {
                this.camera = null;
                // @ts-ignore
                this.view = null;
            }
        }

        // TODO z
        class CameraLookatAnimation extends AbstractAnimation {
            constructor(camera, point) {
                super('CameraLookatAnimation', Infinity);
                this.config = null;
                this.delayTime = 1500;
                this.oldEuler = new Euler();
                this.newEuler = new Euler();
                this.frame = 0;
                this.maxFrame = 40;
                this.camera = camera;
                this.oldEuler.copy(camera.rotation);
                camera.lookAt(new Vector3(point.x, point.y, point.z));
                this.newEuler.copy(camera.rotation);
                camera.rotation.copy(this.oldEuler);
                let deltaX = this.newEuler.x - this.oldEuler.x;
                let deltaY = this.newEuler.y - this.oldEuler.y;
                deltaY = deltaY - Math.floor(deltaY / Math.PI / 2) * Math.PI * 2; // 
                if (deltaY > Math.PI) {
                    deltaY = deltaY - Math.PI * 2;
                }
                this.speedX = deltaX / this.maxFrame;
                this.speedY = deltaY / this.maxFrame;
            }
            onUpdate() {
                let { x, y, z } = this.camera.rotation;
                this.camera.rotation.set(x + this.speedX, y + this.speedY, z);
                this.frame++;
                if (this.frame === this.maxFrame) {
                    this.stop();
                }
            }
            dispose() {
                // @ts-ignore
                this.camera = null;
                // @ts-ignore
                this.oldEuler = null;
                // @ts-ignore
                this.newEuler = null;
            }
        }

        const ANIMATION_OPTIONS = {
            fovStart: 150,
            posYStart: 100
        };
        // let old = 0;
        // let startTime = -1;
        class LittlePlanetAnimation extends AbstractAnimation {
            // staticFovfov
            constructor(viewer, duration = 2000, delay = 500, staticFov = 0) {
                super('LittlePlanetAnimation', 2000);
                this.viewer = null;
                this.config = null;
                this.scene = null;
                this.sceneId = null;
                this.fbo = null;
                this.currentScene = null;
                this.camera = null;
                this.totalFrameNum = 120;
                this.delayFrameNum = 90;
                // delayTime = 1500;
                // totalTime = 2000;
                // currentTime = 0;
                this.currFrameNum = 0;
                this.interpolateAnimation = (time) => {
                    const fov = this.staticFov;
                    const { x, y, z } = this.endRotation;
                    const xStart = -Math.PI / 2;
                    const yStart = y - (Math.PI * 2) / 3;
                    let { fovStart } = ANIMATION_OPTIONS;
                    const posYStart = this.viewer.geometrySize;
                    if (this.totalTime < this.delayTime) {
                        this.camera.fov = fovStart;
                        this.camera.position.set(0, posYStart, 0);
                        this.camera.rotation.set(xStart, yStart, 0);
                        this.camera.updateProjectionMatrix();
                        this.currFrameNum++;
                        return;
                    }
                    if (this.totalTime >= this.duration + this.delayTime) {
                        // 
                        this.viewer.dispatchEvent({ type: EVENT_INT.ANIMATION_END });
                        this.viewer.enterAnimationFinished = true;
                        this.camera.position.set(0, 0, 0);
                        this.camera.rotation.set(x, y, z);
                        this.stop();
                        return;
                    }
                    this.currFrameNum++;
                    const rate = (this.totalTime - this.delayTime) / this.duration;
                    const currFov = fovStart - (fovStart - fov) * rate;
                    if (this.scene.multires) {
                        this.scene.multires.outCube.setMorph(1 - Math.pow(rate, 5));
                    }
                    this.camera.fov = currFov;
                    const posY = posYStart - posYStart * rate;
                    this.camera.position.set(0, posY, 0);
                    const rotationX = xStart - (xStart - x) * rate;
                    const rotationY = yStart - (yStart - y) * rate;
                    this.camera.rotation.set(rotationX, rotationY, z);
                    this.viewer.dispatchEvent({
                        type: EVENT.CAMERA_CHANGE,
                        cause: 'anim',
                        fov: currFov,
                        rotation: {
                            x: rotationX,
                            y: rotationY,
                            z
                        }
                    });
                    this.camera.updateProjectionMatrix();
                };
                this.delayTime = delay;
                this.viewer = viewer;
                this.scene = viewer.story.currentScene;
                this.sceneId = this.scene.sceneId;
                this.fbo = this.scene.fbo;
                this.config = this.scene.config;
                this.staticFov = staticFov || this.scene.config.fov || this.scene.config.fov + 20;
                this.init();
            }
            init() {
                this.currentScene = this.scene.scene;
                this.camera = this.scene.camera;
                this.viewer.dispatchEvent({ type: EVENT_INT.ANIMATION_READY, scene: this.scene });
                let r = this.scene.config.rotation;
                let euler = new Euler(0, 0, 0, 'YXZ');
                if (r) {
                    let q = new Quaternion(r.x, r.y, r.z, r.w);
                    euler.setFromQuaternion(q);
                }
                this.endRotation = {
                    x: euler.x,
                    y: euler.y,
                    z: euler.z
                };
                this.start();
            }
            onUpdate() {
                // console.log('fps update:', this.viewer.fps);
                this.interpolateAnimation(this.deltaTime);
            }
            start() {
                super.start();
                return this;
            }
            dispose() {
                if (this.currentScene) {
                    this.currentScene.dispose();
                    this.currentScene = null;
                }
                this.sceneId = null;
                this.scene = null;
                this.camera = null;
                this.fbo = null;
                this.config = null;
                this.viewer = null;
                this.endRotation = null;
            }
        }

        /**
         * @author HypnosNova / https://www.threejs.org.cn/gallery
         * All gltransitions are rewrited from https://gl-transitions.com/
         *
         * License: MIT
         */
        var BasicTransitionShader = {
            uniforms: {},
            fragmentShader: ['vec4 transition (vec2 uv) {', 'return mix (', 'getFromColor( uv ),', 'getToColor( uv ),', 'progress', ');', '}'].join('\n')
        };

        var GLTransitioner = /*#__PURE__*/function () {
            function GLTransitioner(width, height, _transitionShader, _uniforms, isNotFBO) {
                var _this = this;

                if (_transitionShader === void 0) {
                    _transitionShader = BasicTransitionShader;
                }

                this.setTransitionShader = function (transitionShader, uniforms) {
                    if (transitionShader === void 0) {
                        transitionShader = BasicTransitionShader;
                    }

                    _this.uniforms = {
                        tDiffuse1: {
                            value: uniforms.tDiffuse1
                        },
                        tDiffuse2: {
                            value: uniforms.tDiffuse2
                        },
                        mixRatio: {
                            value: 0.0
                        },
                        progress: {
                            value: 0.0
                        }
                    };

                    for (var key in transitionShader.uniforms) {
                        _this.uniforms[key] = {
                            value: uniforms[key] || transitionShader.uniforms[key].value
                        };
                    }

                    _this.material = new Object3DProxy.ShaderMaterial({
                        uniforms: _this.uniforms,
                        vertexShader: ['varying vec2 vUv;', 'void main() {', 'vUv = vec2( uv.x, uv.y );', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
                        fragmentShader: ['uniform float mixRatio;', 'uniform sampler2D tDiffuse1;', 'uniform sampler2D tDiffuse2;', 'uniform float progress;', 'varying vec2 vUv;', 'vec4 getFromColor ( vec2 uv ) { ', 'return texture2D( tDiffuse1, uv ); ', '}', 'vec4 getToColor ( vec2 uv ) { ', 'return texture2D( tDiffuse2, uv);', '}', transitionShader.fragmentShader, 'void main() {', 'gl_FragColor = transition( vUv );', '}'].join('\n')
                    });
                    _this.quad.material = _this.material;
                };

                this.camera = new Object3DProxy.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.scene = Object3DProxy.newScene();
                this.quad = new Object3DProxy.Mesh(new Object3DProxy.PlaneBufferGeometry(2, 2));
                this.scene.add(this.quad);
                this.isNotFBO = isNotFBO;

                if (_transitionShader) {
                    this.setTransitionShader(_transitionShader, _uniforms);
                }

                this.fbo = Object3DProxy.newWebGLRenderTarget(width || window.innerWidth, height || window.innerHeight, {
                    minFilter: Object3DProxy.LinearFilter,
                    magFilter: Object3DProxy.LinearFilter,
                    format: Object3DProxy.RGBFormat,
                    stencilBuffer: false
                });
            }

            var _proto = GLTransitioner.prototype;

            _proto.update = function update(renderer) {
                this.material.uniforms.progress.value = Math.min(this.material.uniforms.progress.value, 1);
                this.material.uniforms.progress.value = Math.max(this.material.uniforms.progress.value, 0);

                if (this.isNotFBO) {
                    renderer.setRenderTarget(null);
                    renderer.render(this.scene, this.camera);
                } else {
                    renderer.setRenderTarget(this.fbo);
                    renderer.render(this.scene, this.camera);
                }
            };

            _proto.setTexture = function setTexture(texture1, texture2) {
                this.uniforms = {
                    tDiffuse1: {
                        value: texture1
                    },
                    tDiffuse2: {
                        value: texture2
                    },
                    mixRatio: {
                        value: 0.0
                    },
                    progress: {
                        value: 0.0
                    }
                };
            };

            return GLTransitioner;
        }();

        class SceneTransitionAnimation extends AbstractAnimation {
            constructor(renderer, width, height, view1, view2, duration = 500) {
                var _a, _b, _c, _d;
                super('SceneTransitionAnimation', duration);
                this.speed = 0.0333;
                this.onUpdate = () => {
                    if (this.transitioner.material) {
                        this.transitioner.material.uniforms.progress.value += (this.speed * this.deltaTime) / 16;
                        this.transitioner.material.uniforms.progress.value = Math.min(this.transitioner.material.uniforms.progress.value, 1);
                        this.transitioner.update(this.renderer);
                        if (this.transitioner.material.uniforms.progress.value === 1) {
                            this.stop();
                        }
                    }
                    else {
                        this.stop();
                    }
                };
                this.renderer = renderer;
                this.viewer = view2;
                this.transitioner = new GLTransitioner(width, height, undefined, {
                    tDiffuse1: (_b = (_a = view1.story.currentScene) === null || _a === void 0 ? void 0 : _a.fbo) === null || _b === void 0 ? void 0 : _b.texture,
                    tDiffuse2: (_d = (_c = view2.story.currentScene) === null || _c === void 0 ? void 0 : _c.fbo) === null || _d === void 0 ? void 0 : _d.texture
                }, true);
            }
            dispose() {
                // @ts-ignore
                this.transitioner = null;
                // @ts-ignore
                this.renderer = null;
            }
        }

        const SPEED_FOV = -Math.PI / 12000;
        class ZoomAnimation extends AbstractAnimation {
            constructor(viewer, fovStart, fovEnd, speed = SPEED_FOV, duration = 1000) {
                super('ZoomAnimation', duration);
                this.config = null;
                this.camera = null;
                this.delayTime = 1500;
                this.viewer = viewer;
                this.camera = viewer.story.currentScene.camera;
                this.fovStart = fovStart || 90;
                this.fovEnd = fovEnd || this.camera.fov;
                this.fovRange = Math.min(this.fovEnd - this.fovStart, 0);
                this.speed = speed;
            }
            setEndState() {
                this.camera.fov = this.fovEnd;
                this.camera.updateMatrix();
                this.camera.updateProjectionMatrix();
            }
            onUpdate() {
                this.camera.fov += (this.fovRange * this.deltaTime) / 1000;
                this.camera.updateMatrix();
                this.camera.updateProjectionMatrix();
                if (Math.abs(this.camera.fov - this.fovEnd) < Math.abs(this.speed * this.deltaTime * 60) ||
                    (this.speed > 0 && this.camera.fov > this.fovEnd) ||
                    (this.speed < 0 && this.camera.fov < this.fovEnd)) {
                    this.setEndState();
                    this.stop();
                }
            }
            dispose() {
                this.config = null;
                this.viewer = null;
                this.camera = null;
            }
        }

        (function (AnimationType) {
            AnimationType["AutoRotationAnimation"] = "AutoRotationAnimation";
            AnimationType["LittlePlanetAnimation"] = "LittlePlanetAnimation";
            AnimationType["LittlePlanetAnimationAndZoom"] = "LittlePlanetAnimationAndZoom";
            AnimationType["ZoomAnimation"] = "ZoomAnimation";
            AnimationType["SceneTransitionAnimation"] = "SceneTransitionAnimation";
            AnimationType["CameraLookatAnimation"] = "CameraLookatAnimation";
        })(exports.AnimationType || (exports.AnimationType = {}));
        // 
        class AnimationQueue extends EventDispatcher {
            constructor(queueKey) {
                super();
                this.name = 'AnimationQueue';
                this.element = [];
                this.state = AnimationState.STOP;
                this.currentAnimation = null;
                this.isPaused = false;
                // 
                this.playNext = () => {
                    var _a, _b;
                    // 
                    (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.removeEventListener(AnimationState.STOP, this.playNext);
                    (_b = this.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop(false);
                    this.element.shift();
                    // 
                    this.start(false);
                    return this;
                };
                this.queueKey = queueKey;
            }
            push(ani) {
                this.element.push(ani);
            }
            start(needEvent = true) {
                let firstEle = this.element[0];
                if (firstEle) {
                    this.state = AnimationState.START;
                    this.currentAnimation = firstEle;
                    firstEle.addEventListener(AnimationState.STOP, this.playNext);
                    firstEle.start(needEvent);
                    if (needEvent) {
                        this.dispatchEvent({ type: AnimationState.START, target: this });
                        firstEle.dispatchEvent({ type: AnimationState.START, target: this });
                    }
                }
                else {
                    // 
                    this.stop();
                }
                return this;
            }
            // 
            stop(needEvent = true) {
                var _a;
                this.element = [];
                if (this.currentAnimation) {
                    // this.currentAnimation.stop();
                    (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.removeEventListener(AnimationState.STOP, this.playNext);
                    this.currentAnimation = null;
                }
                needEvent && this.dispatchEvent({ type: AnimationState.STOP, target: this, queueKey: this.queueKey });
                return this;
            }
            pause() {
                var _a;
                this.isPaused = true;
                (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.dispatchEvent({ type: AnimationState.PAUSE, target: this });
                return this;
            }
            resume() {
                var _a;
                this.isPaused = false;
                (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.dispatchEvent({ type: AnimationState.RESUME, target: this });
                return this;
            }
            update() {
                if (this.isPaused) {
                    return this;
                }
                if (this.currentAnimation) {
                    this.currentAnimation.update();
                }
                return this;
            }
            // 
            onUpdate() {
                return;
            }
            dispose() {
                this.currentAnimation = null;
                this.element.forEach(iAnimation => {
                    iAnimation.dispose();
                });
                this.element = [];
            }
        }
        class AnimationManager {
            constructor(panoViewer) {
                this.dispose = () => {
                    // let values = this.animationQueueMap.values();
                    // for (let q of values) {
                    //     q.dispose();
                    // }
                    // @ts-ignore
                    this.animationQueueMap = null;
                    this.panoViewer = null;
                };
                this.animationQueueMap = new Map();
                this.panoViewer = panoViewer;
            }
            stopAnimation(key, needEvent) {
                var _a;
                (_a = this.animationQueueMap.get(key)) === null || _a === void 0 ? void 0 : _a.stop(needEvent);
            }
            stopAllAnimation() {
                this.animationQueueMap.forEach((animationQueue) => {
                    animationQueue.stop();
                });
            }
            createAnimation(animationName, ...rest) {
                let animation;
                switch (animationName) {
                    case exports.AnimationType.AutoRotationAnimation: {
                        animation = new AutoRotationAnimation(rest[0], rest[1], rest[2]);
                        let cb = () => {
                            this.panoViewer.dispatchEvent({
                                type: EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION
                            });
                        };
                        animation.addEventListener(AnimationState.UPDATE, cb);
                        // animation.addEventListener(AnimationState.STOP, stopCb);
                        break;
                    }
                    case exports.AnimationType.CameraLookatAnimation: {
                        animation = new CameraLookatAnimation(rest[0], rest[1]);
                        let cb = () => {
                            this.panoViewer.dispatchEvent({
                                type: EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION
                            });
                            animation.removeEventListener(AnimationState.STOP, cb);
                        };
                        animation.addEventListener(AnimationState.UPDATE, cb);
                        break;
                    }
                    case exports.AnimationType.LittlePlanetAnimation: {
                        animation = new LittlePlanetAnimation(rest[0], rest[1], rest[2]);
                        let cb = () => {
                            this.panoViewer.dispatchEvent({
                                type: EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION
                            });
                            animation.removeEventListener(AnimationState.STOP, cb);
                        };
                        animation.addEventListener(AnimationState.STOP, cb);
                        animation.addEventListener(AnimationState.START, () => {
                            var _a, _b, _c;
                            (_c = (_b = (_a = animation.scene) === null || _a === void 0 ? void 0 : _a.multires) === null || _b === void 0 ? void 0 : _b.outCube) === null || _c === void 0 ? void 0 : _c.setMorph(1);
                        });
                        break;
                    }
                    case exports.AnimationType.LittlePlanetAnimationAndZoom: {
                        animation = new AnimationQueue(Symbol());
                        let animation1 = new LittlePlanetAnimation(rest[0], rest[1], rest[2], rest[0].story.currentScene.config.fov + 20);
                        let animation2 = new ZoomAnimation(rest[0], rest[0].story.currentScene.config.fov + 20, rest[4], rest[5]);
                        animation.push(animation1);
                        animation.push(animation2);
                        let cb = () => {
                            this.panoViewer.dispatchEvent({
                                type: EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION
                            });
                            animation1.removeEventListener(AnimationState.STOP, cb);
                        };
                        animation1.addEventListener(AnimationState.STOP, cb);
                        animation1.addEventListener(AnimationState.START, () => {
                            var _a, _b, _c;
                            (_c = (_b = (_a = animation1.scene) === null || _a === void 0 ? void 0 : _a.multires) === null || _b === void 0 ? void 0 : _b.outCube) === null || _c === void 0 ? void 0 : _c.setMorph(1);
                        });
                        animation.name = exports.AnimationType.LittlePlanetAnimationAndZoom;
                        break;
                    }
                    case exports.AnimationType.ZoomAnimation: {
                        animation = new ZoomAnimation(rest[0], rest[2] + 20, rest[2], rest[3]);
                        break;
                    }
                    case exports.AnimationType.SceneTransitionAnimation: {
                        animation = new SceneTransitionAnimation(rest[0], rest[1], rest[2], rest[3], rest[4]);
                        break;
                    }
                    default:
                        throw new Error('Invalid animation name');
                }
                animation.addEventListener(AnimationState.START, () => {
                    this.panoViewer.dispatchEvent({
                        type: EVENT.ANIMATION_START,
                        animationType: animation.name,
                        queueKey: animation.queueKey
                    });
                });
                animation.addEventListener(AnimationState.STOP, () => {
                    this.panoViewer.dispatchEvent({
                        type: EVENT.ANIMATION_END,
                        animationType: animation.name,
                        queueKey: animation.queueKey
                    });
                    // if (animation.name !== 'AutoRotationAnimation') {
                    //     animation.dispose();
                    // }
                });
                animation.addEventListener(AnimationState.PAUSE, () => {
                    this.panoViewer.dispatchEvent({
                        type: EVENT.ANIMATION_PAUSE,
                        animationType: animation.name,
                        queueKey: animation.queueKey
                    });
                });
                animation.addEventListener(AnimationState.RESUME, () => {
                    this.panoViewer.dispatchEvent({
                        type: EVENT.ANIMATION_RESUME,
                        animationType: animation.name,
                        queueKey: animation.queueKey
                    });
                });
                return animation;
            }
            update() {
                this.animationQueueMap.forEach((animationQueue) => {
                    if (animationQueue.state === AnimationState.START) {
                        animationQueue.update();
                    }
                });
            }
            pause(key) {
                let animation = this.animationQueueMap.get(key);
                if (animation) {
                    animation.pause();
                }
                return this;
            }
            resume(key) {
                let animation = this.animationQueueMap.get(key);
                if (animation) {
                    animation.resume();
                }
                return this;
            }
            // 
            // playueueKeylay
            play(animationName, ...rest) {
                let queueKey = Symbol();
                let animations = new AnimationQueue(queueKey);
                if (typeof animationName === 'string') {
                    let animation = this.createAnimation(animationName, ...rest);
                    animations.push(animation);
                    animations.name = animation.name;
                    animation.queueKey = queueKey;
                }
                else {
                    let index = 0;
                    for (let item of animationName) {
                        let animation = this.createAnimation(item, rest[0][index]);
                        animations.push(animation);
                        index++;
                    }
                }
                animations.start(true);
                animations.update();
                this.animationQueueMap.set(queueKey, animations);
                return queueKey;
            }
        }
        AnimationManager.AnimationType = exports.AnimationType;

        const SignatureURL = {
            dev: 'https://bcc-vr-platform-test-c17.bcc-bjrs.baidu.com/vr/authentication/api/v1/app/privilege/get',
            production: 'https://vrstudio.baidu.com/vr/authentication/api/v1/app/privilege/get'
        };
        /**
         * Implements HMAC-SHA256-HEX manually
         * @param key key
         * @param message message
         * @returns
         * Notelocalhostttps
         */
        const enc = new TextEncoder();
        function hmacSha256Hex(key, message) {
            console.time('signature');
            return crypto.subtle
                .importKey('raw', enc.encode(key), {
                    name: 'HMAC',
                    hash: { name: 'SHA-256' }
                }, false, ['sign', 'verify'])
                .then(key => {
                    return crypto.subtle.sign({
                        name: 'HMAC',
                        hash: { name: 'SHA-256' }
                    }, key, enc.encode(message));
                })
                .then(signature => {
                    const hashArray = Array.from(new Uint8Array(signature));
                    // convert bytes to hex string
                    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    console.timeEnd('signature');
                    return hashHex;
                });
        }
        function generateSigningKey(sk, authStringPrefix) {
            return hmacSha256Hex(sk, authStringPrefix);
        }
        function generateSignature(signingKey, canonicalRequest) {
            return hmacSha256Hex(signingKey, canonicalRequest);
        }
        function toISO8601Date() {
            const currentTime = new Date();
            let formattedDate = currentTime.getFullYear() +
                '-' +
                (currentTime.getMonth() + 1).toString().padStart(2, '0') +
                '-' +
                currentTime.getDate().toString().padStart(2, '0') +
                'T' +
                currentTime.getHours().toString().padStart(2, '0') +
                ':' +
                currentTime.getMinutes().toString().padStart(2, '0') +
                ':' +
                currentTime.getSeconds().toString().padStart(2, '0') +
                'Z';
            return formattedDate;
        }
        /**
         * 
         * @param authStringPrefix sk
         * @param canonicalRequest TTP
         * @param sk secretKey
         * @returns signature
         */
        function signature(authStringPrefix, canonicalRequest, sk) {
            return generateSigningKey(sk, authStringPrefix).then((signingKey) => {
                console.log('Authentication::signingKey', signingKey);
                return generateSignature(signingKey, canonicalRequest);
            });
        }
        /**
         * 
         * @param accessKey ak
         * @param secretKey sk
         * @param request 
         * @param signTime 
         * @param expireTime 
         */
        function getAuthentication(accessKey, secretKey, request, signTime = toISO8601Date(), expireTime = 1800) {
            let authStringPrefix = `bce-auth-v1/${accessKey}/${signTime}/${expireTime}`;
            console.log('Authentication::authStringPrefix:\n', authStringPrefix);
            const getQuery = (url) => {
                const seg = url.href.split('?');
                return seg.length > 1 ? seg[1] : '';
            };
            const getHeaders = (headers) => {
                let kv = '';
                let key = '';
                if (headers && Object.keys(headers).length > 0) {
                    const keys = Object.keys(headers).sort();
                    for (let i = 0; i < keys.length; i++) {
                        kv += `${keys[i].toLowerCase()}:${encodeURIComponent(headers[keys[i]])}`;
                        key += keys[i].toLowerCase();
                        if (i !== keys.length - 1) {
                            kv += '\n';
                            key += ';';
                        }
                    }
                }
                return [key, kv];
            };
            let canonicalRequest = `${request.type.toUpperCase()}\n${request.urlInstance.pathname}\n${getQuery(request.urlInstance)}\n`;
            request.headers = Object.assign(Object.assign({}, request.headers), { host: request.urlInstance.hostname });
            const [key, kv] = getHeaders(request.headers);
            if (kv) {
                canonicalRequest += kv;
            }
            console.log('Authentication::canonicalRequest:\n', canonicalRequest);
            return signature(authStringPrefix, canonicalRequest, secretKey).then((authentication) => {
                console.log('Authentication::authentication', authentication);
                return `${authStringPrefix}/${key}/${authentication}`;
            });
        }

        //user authentication manager
        class Authentication {
            constructor(ak, sk) {
                this.permissionCodeList = new Set();
                this.enabled = true;
                this.ak = ak;
                this.sk = sk;
            }
            // get user permission list form server to init 'permissionCodeList';
            init() {
                return this.updatePermissionList();
            }
            setEnabled(enabled) {
                this.enabled = enabled;
            }
            // 
            updatePermissionList() {
                if (!this.ak || !this.sk) {
                    return Promise.reject(new Error('ak or sk is undefined'));
                }
                else {
                    return new Promise((resolve, reject) => {
                        const success = (data) => {
                            this.parseData(data);
                            resolve && resolve(this);
                        };
                        const error = (error) => {
                            reject && reject(error);
                        };
                        return requestPermission(this.ak, this.sk).then(success, error);
                    });
                }
            }
            parseData(data) {
                if (data && data.data instanceof Array) {
                    data.data.forEach((item) => {
                        this.permissionCodeList.add(parseInt(item));
                    });
                }
            }
            hasPermission(code) {
                if (!this.enabled) {
                    return true;
                }
                return this.permissionCodeList.has(code) ? true : false;
            }
        }
        function requestPermission(ak, sk) {
            // url env
            const url = SignatureURL.production;
            const requestParams = {
                url,
                urlInstance: new URL(url),
                type: 'GET'
            };
            // 
            // let signature =
            //    'bce-auth-v1/6e84fd301f6d11ec96210242ac130002/2021-9-30T21:59:48Z/1800/host/e001b5f46f2e32531578eb256c0e8a7b9adf2987a1358568c203e166d39f4319';
            // return new Promise((resolve, reject) => {
            //     request({
            //         ...requestParams,
            //         headers: {
            //             Authorization : signature
            //         },
            //         addUrlCorsOrigin: false,
            //         success: (data: any) => {
            //             // console.log('success');
            //             resolve(JSON.parse(data));
            //         },
            //         error: (error: any) => {
            //             console.log(error);
            //             reject(error);
            //         }
            //     });
            // });
            return getAuthentication(ak, sk, Object.assign({}, requestParams)).then((signature) => {
                console.log('Authentication::signature', signature);
                return new Promise((resolve, reject) => {
                    request(Object.assign(Object.assign({}, requestParams), { headers: {
                            Authorization: signature,
                            os_type: 'web'
                        }, addUrlCorsOrigin: false, success: (data) => {
                            // console.log('success');
                            resolve(JSON.parse(data));
                        }, error: (error) => {
                            console.log(error);
                            reject(error);
                        } }));
                });
            });
        }

        /**
         * @classdesc SDK3d/2d
         *
         * @class
         * @name Hydreigon.PanoViewer
         *
         * @param {HTMLElement} parent lement.
         * @param {Object|string} config SDKjsonconfigurl
         * @param {string|undefined} ak ak
         * @param {string|undefined} sk sk
         * @param {Object} options
         *
         * @param {number} options.mode SDK010
         * @param {string} options.debugLayer SDK
         * @param {boolean} options.debug ebug
         *
         */
        class PanoViewer extends Base3D {
            constructor(parent, ak = undefined, sk = undefined, options = {}) {
                super();
                this.story = new Story(this);
                this.loader = new Loader$1(this);
                this.destroyed = false;
                /**
                 * 
                 *
                 * @method Hydreigon.PanoViewer#init
                 * @param {PanoConfiguration} config 
                 * @return {Promise}, resolveeject
                 */
                this.init = (config) => {
                    if (!config) {
                        throw new Error('the config is undefined');
                    }
                    const loadTemp = () => {
                        // authentication
                        if (!AuthenticationUtil.checkPanoRenderType(this.authentication, config)) {
                            throw new Error('the sdk has not permission;');
                        }
                        if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.IX_DRAG)) {
                            this.controllerManager.dragEnable(false);
                        }
                        if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.IX_GYRO)) {
                            this.controllerManager.switchGyro(false);
                        }
                        // authentication
                        this.config = config;
                        this._loadConfig(this.config);
                    };
                    return new Promise((resolve, reject) => {
                        const success = () => {
                            loadTemp();
                            resolve && resolve(this);
                        };
                        const error = (error) => {
                            reject && reject(error);
                        };
                        return this.authentication.init().then(success, error);
                    });
                };
                /**
                 * 
                 *
                 * @method Hydreigon.PanoViewer#forceUpdateRotation
                 * @return {void}
                 */
                this.forceUpdateRotation = () => {
                    if (!this.config) {
                        return;
                    }
                    let rotation = new Euler().copy(this.story.currentScene.camera.rotation);
                    let fov = this.story.currentScene.camera.fov;
                    this.setCameraRotation(rotation);
                    this.setFov(fov);
                };
                this._loadConfig = (config) => {
                    if (config && typeof config === 'string') {
                        this.loader
                            .loadJson(config)
                            .then((data) => {
                                this._parseConfig(data);
                            })
                            .catch((error) => {
                                this.dispatchEvent({ type: EVENT.OPTIONS_ERROR });
                                console.error(error);
                            });
                    }
                    else {
                        this._parseConfig(config);
                    }
                };
                this._parseConfig = (config) => {
                    this.story.loadConfig(config);
                };
                // fpsTime = 0;
                // computeFps = time => {
                //     console.log('fps:', this.fps);
                //     if ((this.fpsTime || 0) > 5) {
                //         return;
                //     }
                //     if (!this.lastTime) {
                //         this.lastTime = performance.now();
                //     } else {
                //         const curTime = performance.now();
                //         const currFps = 1000 / (curTime - this.lastTime);
                //         this.lastTime = curTime;
                //         // this.fps = ((this.fps || 60) + currFps) / 2;
                //         // console.log('fps:', this.fps, this.fpsTime);
                //         this.fpsTime++;
                //     }
                // }
                this._updateLogic = (time) => {
                    this.story.update();
                    this.controllerManager.update(time);
                };
                /**
                 * Size
                 * @method Hydreigon.PanoViewer#onWindowResize
                 * @return {void}
                 */
                this.onWindowResize = () => {
                    if (!this.config) {
                        return;
                    }
                    // this.renderManager.resize();
                    this.containerRect = this.container.getBoundingClientRect();
                    this.story.resize();
                };
                if (typeof parent === 'string') {
                    parent = document.getElementById(parent) || document.body;
                }
                this.authentication = new Authentication(ak, sk);
                this.animationManager = new AnimationManager(this);
                this.parent = parent;
                this.container = this.parent;
                this.containerRect = this.container.getBoundingClientRect();
                this.controllerManager = new ControllerManager(this);
                this.options = options;
                this.debug = !!this.options.debug;
                this.supplyId = this.options.supplyId ? this.options.supplyId : SDK_SUPPLY_ID;
                if (!options.disableReport) {
                    Reporter$2.init(this.supplyId, this.options.contentId, this.debug);
                    Reporter$2.reportPV({ resource_type: 1 });
                    this._initErrorReport();
                }
                window.addEventListener('resize', this.onWindowResize);
                this.addEventListener(EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION, this.forceUpdateRotation);
            }
            showEffect(effects) {
                throw new Error('Method not implemented.');
            }
            _initErrorReport() {
                window.addEventListener('error', PanoViewer._handleError);
                window.addEventListener('unhandledrejection', PanoViewer._handleError);
            }
            static _handleError(event) {
                handleAndFilterError(event, { resource_type: 1 });
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#switchView
             * @param {PanoConfiguration} config 
             * @return {Promise} resolveeject
             */
            switchView(config) {
                return this.init(config);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#update
             * @param {number} time
             * @return {void}
             */
            update(time) {
                // this.computeFps(time);
                this.dispatchEvent({ type: EVENT.BEFORE_RENDER });
                this._updateLogic(time);
                this.animationManager.update();
                this.dispatchEvent({ type: EVENT.AFTER_RENDER });
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#destroy
             * @return {void}
             */
            destroy() {
                if (this.destroyed) {
                    return;
                }
                this.destroyed = true;
                this.animationManager.dispose();
                // @ts-ignore
                this.animationManager = null;
                if (this.controllerManager) {
                    this.controllerManager.destroy();
                    // @ts-ignore
                    this.controllerManager = null;
                }
                // this.renderManager && this.renderManager.destroy();
                if (this.story) {
                    this.story.destroy();
                    // todo
                    // @ts-ignore
                    this.story = undefined;
                }
                this.config = null;
                // @ts-ignore
                this.loader = undefined;
                this.options = undefined;
                window.removeEventListener('resize', this.onWindowResize);
                this.removeEventListener(EVENTS_INNER.FORCE_UPDATE_CONTROL_CAMERA_ROTATION, this.forceUpdateRotation);
                this.clearSubscribers();
            }
            /**
             * ov
             *
             * @method Hydreigon.PanoViewer#getFov
             * @return {number} fov
             */
            getFov() {
                return this.controllerManager.getFov();
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#enablePointEvent
             * @param {boolean} enable true, false
             * @return {void}
             */
            enablePointEvent(enable) {
                if (enable) {
                    enablePointerEvent(this.container);
                }
                else {
                    disablePointerEvent(this.container);
                }
            }
            // API
            // addScenes = scenes => {
            //     this.config.views = [
            //         ...this.config.views,
            //         ...scenes
            //     ];
            // }
            /**
             * ov
             *
             * @method Hydreigon.PanoViewer#getMinFov
             * @return {number} min fov
             */
            getMinFov() {
                const fovRange = this.controllerManager.getFovRange();
                if (!fovRange && fovRange.length !== 2) {
                    throw Error('the fovRange data of panoViewer is invalid');
                }
                return fovRange[0];
            }
            /**
             * ov
             *
             * @method Hydreigon.PanoViewer#getMaxFov
             * @return {number} max fov
             */
            getMaxFov() {
                const fovRange = this.controllerManager.getFovRange();
                if (!fovRange && fovRange.length !== 2) {
                    throw Error('the fovRange data of panoViewer is invalid');
                }
                return fovRange[1];
            }
            /**
             * ov
             *
             * @method Hydreigon.PanoViewer#setFov
             * @param {number} fov - ov
             * @return {boolean}
             */
            setFov(fov) {
                return this.controllerManager.setFov(fov);
            }
            /**
             * ov
             *
             * @method Hydreigon.PanoViewer#setFovRange
             * @param {number} min - min
             * @param {number} max - max
             * @return {boolean}
             */
            setFovRange(min, max) {
                if (min > max) {
                    throw Error('the min value is not greater then the max value.');
                }
                const fovRange = [min, max];
                return this.controllerManager.setFovRange(fovRange);
            }
            /**
             * Pitch
             *
             * @method Hydreigon.PanoViewer#getPitchRange
             * @return {Array} pitchRangemin, max] minax
             */
            getPitchRange() {
                return this.controllerManager.getPitchRange();
            }
            /**
             * itch
             *
             * @method Hydreigon.PanoViewer#setPitchRange
             * @param {number} min - min
             * @param {number} max - max
             * @return {boolean}
             */
            setPitchRange(min, max) {
                if (min > max) {
                    throw Error('the min value is not greater then the max value.');
                }
                const pitchRange = [min, max];
                return this.controllerManager.setPitchRange(pitchRange);
            }
            /**
             * pitch
             *
             * @method Hydreigon.PanoViewer#pitchEnabled
             * @param {boolean}   true false 
             */
            pitchEnabled(enable) {
                this.controllerManager.pitchEnabled(enable);
            }
            /**
             * pitch
             *
             * @method Hydreigon.PanoViewer#pitchEnabled
             * @return {boolean} true  false 
             */
            isPitchEnabled() {
                return this.controllerManager.isPitchEnabled();
            }
            /**
             * min Pitch
             *
             * @method Hydreigon.PanoViewer#getMinPitch
             * @return {number}  
             */
            getMinPinch() {
                const pitchRange = this.controllerManager.getPitchRange();
                if (!pitchRange && pitchRange.length !== 2) {
                    throw Error('the pitchRange data of panoViewer is invalid');
                }
                return pitchRange[0];
            }
            /**
             * max Pitch
             *
             * @method Hydreigon.PanoViewer#getMaxPitch
             * @return {number}  
             */
            getMaxPinch() {
                const pitchRange = this.controllerManager.getPitchRange();
                if (!pitchRange && pitchRange.length !== 2) {
                    throw Error('the pitchRange data of panoViewer is invalid');
                }
                return pitchRange[1];
            }
            /**
             * pinch
             *
             * @method Hydreigon.PanoViewer#pinchEnable
             * @param {boolean}   true false 
             */
            pinchEnable(enable) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.IX_DRAG)) {
                    return false;
                }
                // authentication
                this.controllerManager.pinchEnable(enable);
            }
            /**
             * pinch
             *
             * @method Hydreigon.PanoViewer#isPinchEnabled
             * @return {boolean} true  false 
             */
            isPinchEnabled() {
                return this.controllerManager.isPinchEnabled();
            }
            /**
             * Rotation
             *
             * @method Hydreigon.PanoViewer#getCameraRotation
             * @return {Object} rotation{x, y, z}
             */
            getCameraRotation() {
                return this.controllerManager.getCameraRotation();
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#getCameraQuaternion
             * @return {Object} {x, y, z w}
             */
            getCameraQuaternion() {
                return this.controllerManager.getCameraQuaternion();
            }
            /**
             * Rotation
             *
             * @method Hydreigon.PanoViewer#setCameraRotation
             * @param {Object} rotation - {x, y, z}
             * @returns {boolean} true false
             */
            setCameraRotation(rotation) {
                return this.controllerManager.setCameraRotation(rotation);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#setCameraQuaternion
             * @param {Object} quaternion - {x, y, z, w}
             * @returns {boolean} true false
             */
            setCameraQuaternion(quaternion) {
                return this.controllerManager.setCameraQuaternion(quaternion);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#setDefaultRotation
             * @param {Object} rotation - {x, y, z}
             * @returns {boolean} true false
             */
            setDefaultRotation(rotation) {
                return this.story.setDefaultRotation(rotation);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#degToRad
             * @param {float} deg - 
             * @returns {float} 
             */
            degToRad(deg) {
                return Object3DProxy.degToRad(deg);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#radToDeg
             * @param {float} rad - 
             * @returns {float} 
             */
            radToDeg(rad) {
                return Object3DProxy.radToDeg(rad);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#isGyroOpen
             * @returns {boolean} true false
             */
            isGyroOpen() {
                return this.controllerManager.isGyroOpen();
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#switchGyro
             * @param {boolean} enable
             * @returns {Promise}
             */
            switchGyro(enable) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.IX_GYRO)) {
                    return false;
                }
                // authentication
                return this.controllerManager.switchGyro(enable);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#addHotspot
             * @param {Object} hotspot - 
             * @returns {boolean} true false
             */
            addHotspot(hotspot) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.HS_2DHospot)) {
                    return false;
                }
                // authentication
                return this.story.addHotspot(hotspot);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#updateHotspot
             * @param {string} id - d
             * @param {Object} hotspot - 
             * @param {string} sceneId - Id
             * @returns {boolean} true false
             */
            updateHotspot(id, hotspot, sceneId) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.HS_2DHospot)) {
                    return false;
                }
                // authentication
                return this.story.updateHotspot(id, hotspot, sceneId);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#removeHotspot
             * @param {string} id - d
             * @param {string} sceneId - id
             * @returns {boolean} true false
             */
            removeHotspot(id, sceneId) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.HS_2DHospot)) {
                    return false;
                }
                // authentication
                return this.story.removeHotspot(id, sceneId);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#removeAllHotspot
             * @returns {boolean} true  false
             */
            removeAllHotspot() {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.HS_2DHospot)) {
                    return false;
                }
                // authentication
                return this.story.removeAllHotspot();
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#selectHotspot
             * @param {string} id - d
             * @param {string} sceneId - id
             * @returns {boolean} true false
             */
            selectHotspot(id) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.HS_2DHospot)) {
                    return false;
                }
                // authentication
                return this.story.selectHotspot(id);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#unSelectHotspot
             * @param {string} id - d
             * @returns {boolean} true false
             */
            unSelectHotspot(id) {
                return this.story.unSelectHotspot(id);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#requestSnapShot
             * @returns {string} base64
             */
            requestSnapShot(renderer) {
                if (!this.story.currentScene) {
                    return null;
                }
                const { scene, camera } = this.story.currentScene;
                renderer.render(scene, camera);
                return renderer.domElement.toDataURL('image/jpg');
            }
            /**
             * ID
             *
             * @method Hydreigon.PanoViewer#getSupplyId
             * @return {string} ID
             */
            getSupplyId() {
                return this.supplyId;
            }
            /**
             * D
             *
             * @method Hydreigon.PanoViewer#setSupplyId
             * @param {string} supplyId ID
             * @return {void}
             */
            setSupplyId(supplyId) {
                this.supplyId = supplyId;
            }
            /**
             * SDK
             *
             * @method Hydreigon.PanoViewer#getVersion
             * @return {string} version
             */
            getVersion() {
                return SDK_VERSION;
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#setDebug
             * @param {boolean} debug truefalse
             * @return {void}
             */
            setDebug(debug) {
                this.debug = debug;
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#isDebug
             * @return {boolean} debug truefalse
             */
            isDebug() {
                return this.debug;
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#triggerEnter
             * @return {void}}
             */
            triggerEnter() {
                this.story.triggerEnter();
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#screenToPanoCoord
             * @param {number}  x x
             * @param {number}  y y
             * @return {object} {x: number, y: number, z: number} 
             */
            screenToPanoCoord(x, y) {
                return this.story.currentScene.hotspotManager.screenToWorld(x, y);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#getCoord
             * @param {number}  x x
             * @param {number}  y y
             * @return {object} {x: number, y: number, z: number} 
             */
            getCoord(x, y) {
                return this.story.currentScene.hotspotManager.getCoord(x, y);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#showHotspotContainer
             * @return {void}
             */
            showHotspotContainer() {
                let dom = this.story.currentScene.hotspotManager.domHSContainer;
                if (dom) {
                    this.container.appendChild(dom);
                }
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#hideHotspotContainer
             * @return {void}
             */
            hideHotspotContainer() {
                if (this.story && this.story.currentScene && this.story.currentScene.hotspotManager) {
                    let dom = this.story.currentScene.hotspotManager.domHSContainer;
                    if (dom && dom.parentElement) {
                        dom.parentElement.removeChild(dom);
                    }
                }
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#panoToScreenCoord
             * @param {object}  obj x: number, y: number, z: number}
             * @param {Camera}  camera 
             * @return {HTMLElement} container 
             */
            panoToScreenCoord(obj, camera = this.story.currentScene.camera, container = this.container) {
                let vector = Object3DProxy.newVector3(obj.x, obj.y, obj.z);
                vector.project(camera);
                const halfWidth = container.offsetWidth / 2;
                const halfHeight = container.offsetHeight / 2;
                const screenCoord = {
                    x: vector.x * halfWidth + halfWidth,
                    y: -vector.y * halfHeight + halfHeight
                };
                return screenCoord;
            }
            /**
             * ceneId
             *
             * @method Hydreigon.PanoViewer#getHsManager
             * @param {string} sceneId - Id
             * @return {HotspotManager} hotspotManager
             */
            getHsManager(sceneId) {
                return this.story.getHsManager(sceneId);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#reversalEvent
             * @param {boolean} b true  false 
             * @return {void}
             */
            reversalEvent(b) {
                this.controllerManager && this.controllerManager.reversalEvent(b);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#addEffect
             * @param {object} effect 
             * @return {void}
             */
            addEffect(effect) {
                return this.story.currentScene.addEffect(effect);
            }
            /**
             * (ffect)
             *
             * @method Hydreigon.PanoViewer#removeEffect
             * @param {string} effect 
             * @param {string} sceneId id
             * @return {boolean} true false
             */
            removeEffect(effectId, sceneId) {
                return this.story.removeEffect(effectId, sceneId);
            }
            /**
             * 
             *
             * @method Hydreigon.PanoViewer#showEffects
             * @param {object[]} effects 
             * @return {void}
             */
            showEffects(effects) {
                if (effects.length > 0) {
                    effects.forEach(effect => {
                        this.showEffect(effects);
                    });
                }
            }
            /**
             * hydreigon
             *
             * @method Hydreigon.PanoViewer#forceShowPiece
             * @return {void}
             */
            forceShowPiece() {
                // @ts-ignore
                // this.multires?.forceShowPiece();
                this.story.currentScene.multires.forceShowPiece();
            }
            /**
             * 
             * *
             * 
             * playueueKeylay
             *
             * @method Hydreigon.PanoViewer#performAnimation
             * @param {string} animationName - 
             * @return {Symbol} ID
             */
            performAnimation(animationName, ...rest) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.AN_DEFAULT)) {
                    return Symbol();
                }
                // authentication
                return this.animationManager.play(animationName, ...rest);
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#stopAllAnimation
             * @return {PanoViewer} this
             */
            stopAllAnimation() {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.AN_DEFAULT)) {
                    return this;
                }
                // authentication
                this.animationManager.stopAllAnimation();
                return this;
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#stopAnimation
             * @param {Symbol} key - ID
             * @param {boolean} needEvent - 
             * @return {PanoViewer} this
             */
            stopAnimation(key, needEvent) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.AN_DEFAULT)) {
                    return this;
                }
                // authentication
                this.animationManager.stopAnimation(key, needEvent);
                return this;
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#pauseAnimation
             * @param {Symbol} key - ID
             * @return {PanoViewer} this
             */
            pauseAnimation(key) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.AN_DEFAULT)) {
                    return this;
                }
                // authentication
                this.animationManager.pause(key);
                return this;
            }
            /**
             * 
             * @method Hydreigon.PanoViewer#resumeAnimation
             * @param {Symbol} key - ID
             * @return {PanoViewer} this
             */
            resumeAnimation(key) {
                // authentication
                if (!AuthenticationUtil.checkCode(this.authentication, PanoCode.AN_DEFAULT)) {
                    return this;
                }
                // authentication
                this.animationManager.resume(key);
                return this;
            }
        }

        // rafaf 
        // startefstoptart
        class RafManager {
        }
        RafManager.tasks = [];
        RafManager.add = (task) => {
            if (!RafManager.tasks.includes(task)) {
                RafManager.tasks.push(task);
            }
        };
        RafManager.remove = (task) => {
            let index = RafManager.tasks.indexOf(task);
            if (index === -1)
                return;
            RafManager.tasks.splice(index, 1);
        };
        RafManager.update = () => {
            for (let item of RafManager.tasks) {
                item();
            }
            return requestAnimationFrame(RafManager.update);
        };
        RafManager.start = () => {
            return requestAnimationFrame(RafManager.update);
        };
        RafManager.rafId = RafManager.start();
        RafManager.stop = () => {
            cancelAnimationFrame(RafManager.rafId);
        };

        const DEFAULT_OPTIONS$1 = {
            webgl: {
                antialias: true,
                alpha: true,
                premultipliedAlpha: false,
                stencil: false,
                preserveDrawingBuffer: true
            }
        };
        function renderToTexture(renderer, scene, target) {
            renderer.setRenderTarget(target);
            renderer.render(scene.scene, scene.camera);
        }
        class RenderManager {
            // iewportcene3dparentviewport
            constructor(parentElement) {
                this.currentViewer = null;
                this.startTime = 0;
                this.sceneChanged = false;
                this.isFirst = true;
                this.handleContextChange = (event) => {
                    event.preventDefault();
                    // @ts-ignore
                    let isLoss = this.mainRenderer.getContext().getError() === this.mainRenderer.getContext().CONTEXT_LOST_WEBGL;
                    // console.log('webgl context isLoss', isLoss);
                    if (document.visibilityState === 'visible' && isLoss) {
                        RafManager.start();
                        // it only work in next frame.
                        setTimeout(() => {
                            // this method will call restorContext using webgl WEBGL_lose_context extension. more detail see threejs source code.
                            // @ts-ignore
                            this.mainRenderer.forceContextRestore();
                        }, 0);
                    }
                };
                this.handleContextRestored = (event) => {
                    event.preventDefault();
                    if (document.visibilityState === 'visible') {
                        RafManager.start();
                        // @ts-ignore
                        this.mainRenderer.forceContextRestore();
                    }
                    // window.location.reload();
                };
                this.resize = () => {
                    this.mainRenderer.setSize(this.parentElement.offsetWidth, this.parentElement.offsetHeight);
                };
                // nimationManger  Transitioner 
                this.render = (viewer = this.currentViewer) => {
                    if (!viewer || !viewer.story.tmpScene) {
                        return;
                    }
                    renderToTexture(this.mainRenderer, viewer.story.tmpScene, null);
                    viewer.update(Date.now());
                };
                // 
                this.renderToTexture = (viewer = this.currentViewer) => {
                    if (!viewer) {
                        return;
                    }
                    renderToTexture(this.mainRenderer, viewer.story.tmpScene, viewer.story.tmpScene.fbo);
                };
                if (typeof parentElement === 'string') {
                    parentElement = document.getElementById(parentElement) || document.body;
                }
                this.mainRenderer = Object3DProxy.newWebGLRenderer(DEFAULT_OPTIONS$1.webgl);
                this.canvas = this.mainRenderer.domElement;
                this.mainRenderer.setPixelRatio(window.devicePixelRatio || 1);
                this.parentElement = parentElement;
                this.mainRenderer.setSize(parentElement.offsetWidth, parentElement.offsetHeight);
                parentElement.appendChild(this.mainRenderer.domElement);
                this.canvas.addEventListener('webglcontextlost', event => {
                    // this.parentElement.innerText = '';
                    // this.parentElement.style.textAlign = 'center';
                    // this.parentElement.style.lineHeight = this.parentElement.offsetHeight + 'px';
                    // you must call this method. otherwise it will throw an error: WebGL: INVALID_OPERATION: restoreContext: context restoration not allowed.
                    event.preventDefault();
                    // // cancel render loop;
                    RafManager.stop();
                    this.handleContextChange(event);
                    // RenderManager.onWebglLost(event);
                }, false);
                // handle auto-restore situration.
                this.canvas.addEventListener('webglcontextrestored', this.handleContextRestored, false);
                document.addEventListener('visibilitychange', this.handleContextChange, false);
                // @ts-ignore
                // window.renderer = this.mainRenderer;
                window.addEventListener('resize', this.resize);
            }
            static create(container) {
                let manager = RenderManager.managerMap.get(container);
                if (manager) {
                    return manager;
                }
                else {
                    manager = new RenderManager(container);
                    RenderManager.managerMap.set(container, manager);
                }
                return manager;
            }
            static destroy(container) {
                let manager = RenderManager.managerMap.get(container);
                if (manager) {
                    manager.dispose();
                    RenderManager.managerMap.delete(container);
                }
            }
            setSize(width, height) {
                this.mainRenderer.setSize(width, height);
            }
            // PanoViewerceneScene
            setCurrentViewer(viewer) {
                this.currentViewer = viewer;
            }
            dispose() {
                this.mainRenderer.dispose();
                // @ts-ignore
                this.mainRenderer = undefined;
                this.currentViewer = null;
            }
        }
        RenderManager.managerMap = new Map();
        RenderManager.onWebglLost = (event) => { };

        var DOM_TYPE$1 = {
            LINK: 0,
            LABEL: 1
        };

        var CHotspotDom = /*#__PURE__*/function (_Display) {
            _inheritsLoose(CHotspotDom, _Display);

            function CHotspotDom(manager, dom, config, mode) {
                var _manager$viewer;

                var _this;

                if (mode === void 0) {
                    mode = SDK_MODE.EDIT;
                }

                if (!AuthenticationUtil.checkCode((_manager$viewer = manager.viewer) === null || _manager$viewer === void 0 ? void 0 : _manager$viewer.authentication, PanoCode.HS_2DHospot)) {
                    return _assertThisInitialized(_this);
                }

                _this = _Display.call(this, manager.viewer) || this;
                _this.type = HOTSPOT_TYPE.DOM;
                _this.viewer = null;
                _this.manager = null;
                _this.config = null;
                _this.id = null;
                _this.display = null;
                _this.domContainer = null;
                _this.mode = null;
                _this.deltaX = 0;
                _this.deltaY = 0;
                _this.canvas = document.createElement('canvas');
                _this.domImage = new Image();
                _this.vect = Object3DProxy.newVector3();
                _this.domOpacity = 0;
                _this.domShowed = true;
                _this.dP = Object3DProxy.newVector2(0, 0);
                _this.tf = 15;
                _this.scalar = HOTSPOT_OPTIONS.LINK_RAY_LENGTH;
                _this.enableDrag = false;

                _this.start = function () {
                    var _this$viewer;

                    if (!AuthenticationUtil.checkCode((_this$viewer = _this.viewer) === null || _this$viewer === void 0 ? void 0 : _this$viewer.authentication, PanoCode.HS_2DHospot)) {
                        return;
                    }

                    _this.initObject3D();

                    _this.initDomContainer();

                    _this.bindEvent();

                    _this.manager.scene.rGroup.parent.add(_this.display);

                    _this.manager.hotspots.push(_assertThisInitialized(_this));
                };

                _this.setDomType = function (type) {
                    _this.domType = type;

                    if (_this.domType === DOM_TYPE$1.LINK) {
                        _this.scalar = HOTSPOT_OPTIONS.LINK_RAY_LENGTH;
                    } else {
                        _this.scalar = HOTSPOT_OPTIONS.LABEL_RAY_LENGTH;
                    }
                };

                _this.reset = function () {
                    _this.manager.domHSContainer.appendChild(_this.domContainer);

                    _this.domOpacity = 0;
                };

                _this.bindEvent = function () {
                    if (_this.mode === SDK_MODE.EDIT) {
                        _this.domContainer.addEventListener('mousedown', _this.onMouseDown);

                        _this.domContainer.addEventListener('mouseover', _this.onMouseOver);

                        _this.domContainer.addEventListener('mouseout', _this.onDomMouseOut);

                        _this.viewer.container.addEventListener('mousemove', _this.onMouseMove);

                        _this.viewer.container.addEventListener('mouseup', _this.onMouseUp);

                        _this.viewer.container.addEventListener('mouseleave', _this.onMouseLeave);
                    }
                };

                _this.onMouseOver = function (event) {// if (this.selected) {
                    //     return;
                    // }
                    // if (!enableDrag) {
                    //     return;
                    // }
                };

                _this.onMouseDown = function (event) {
                    if (!_this.enableDrag) {
                        return;
                    }

                    console.log('mouse down');
                    _this.selected = true;
                    _this.domContainerRect = _this.domContainer.getBoundingClientRect();
                    _this.deltaX = event.clientX - _this.domContainerRect.left;
                    _this.deltaY = event.clientY - _this.domContainerRect.top;
                    _this.domContainer.style.cursor = 'move';

                    _this.viewer.controllerManager.switchDragControls(false);
                };

                _this.onMouseMove = function (event) {
                    if (!_this.enableDrag) {
                        return;
                    }

                    if (!_this.selected) {
                        return;
                    }

                    if (!_this.mouse) {
                        _this.mouse = Object3DProxy.newVector2();
                    }

                    _this.mouse.x = (event.clientX - _this.viewer.containerRect.left - _this.deltaX) / _this.viewer.container.offsetWidth * 2 - 1;
                    _this.mouse.y = -((event.clientY - _this.viewer.containerRect.top - _this.deltaY) / _this.viewer.container.offsetHeight) * 2 + 1;

                    var ray = _this.manager.getRay(_this.mouse).ray;

                    var _ray$direction$multip = ray.direction.multiplyScalar(_this.scalar),
                        x = _ray$direction$multip.x,
                        y = _ray$direction$multip.y,
                        z = _ray$direction$multip.z;

                    _this.display.position.set(x, y, z);

                    _this.viewer.controllerManager.switchDragControls(true);

                    _this.updated = true;

                    _this.setDomPosition();
                };

                _this.onDomMouseOut = function () {// this.onMouseUp();
                };

                _this.onMouseUp = function () {
                    if (!_this.enableDrag) {
                        return;
                    } // console.log('mouse up');


                    _this.selected = false;
                    _this.domContainer.style.cursor = 'auto';

                    _this.viewer.controllerManager.switchDragControls(true);

                    if (!_this.updated) {
                        return;
                    } // this.manager.unSelectHotspot();


                    var _this$display$positio = _this.display.position,
                        x = _this$display$positio.x,
                        y = _this$display$positio.y,
                        z = _this$display$positio.z;

                    var hotspotInfo = _objectSpread2(_objectSpread2({}, _this.config), {}, {
                        pos: {
                            x: x,
                            y: y,
                            z: z
                        }
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_UPDATE,
                        sceneId: _this.manager.scene.sceneId,
                        hotspotId: _this.id,
                        hotspot: hotspotInfo
                    });

                    _this.updated = false;
                };

                _this.onMouseLeave = function () {
                    if (!_this.viewer || !_this.viewer.controllerManager) {
                        return;
                    } // console.log('mouse leave');


                    _this.selected = false;
                    _this.domContainer.style.cursor = 'auto';

                    _this.viewer.controllerManager.switchDragControls(true);

                    if (!_this.updated) {
                        return;
                    }

                    var _this$display$positio2 = _this.display.position,
                        x = _this$display$positio2.x,
                        y = _this$display$positio2.y,
                        z = _this$display$positio2.z;

                    var hotspotInfo = _objectSpread2(_objectSpread2({}, _this.config), {}, {
                        pos: {
                            x: x,
                            y: y,
                            z: z
                        }
                    });

                    _this.viewer.dispatchEvent({
                        type: EVENT.HS_UPDATE,
                        sceneId: _this.manager.scene.sceneId,
                        hotspotId: _this.id,
                        hotspot: hotspotInfo
                    });
                };

                _this.show = function () {
                    _this.domShowed = true;
                };

                _this.hide = function () {
                    _this.domShowed = false;
                };

                _this.domSpringPosition = function () {
                    var _this$manager$worldTo = _this.manager.worldToScreen(_this.display),
                        x = _this$manager$worldTo.x,
                        y = _this$manager$worldTo.y;

                    if (isNaN(x) || isNaN(y)) {
                        return;
                    }

                    if (!_this.sP) {
                        _this.sP = Object3DProxy.newVector2(x, y);
                    }

                    _this.dP.set(x, y);

                    var cX = (_this.dP.x - _this.sP.x) / _this.tf + _this.sP.x;
                    var cY = (_this.dP.y - _this.sP.y) / _this.tf + _this.sP.y;
                    _this.domContainer.style.transform = "translate(" + x + "px, " + y + "px)translateZ(0)";

                    _this.sP.set(cX, cY);
                };

                _this.getHsPosition = function () {
                    return _this.display.position;
                };

                _this.update = function () {
                    if (_this.manager && _this.manager.scene && _this.manager.scene.camera && _this.viewer && _this.viewer.controllerManager) {
                        var pos = _this.display.position;

                        _this.manager.scene.camera.getWorldDirection(_this.vect);

                        if (pos.angleTo(_this.vect) < Math.PI / 2) {
                            if (_this.viewer.controllerManager.rotating) {
                                _this.domSpringPosition();
                            } else {
                                _this.setDomPosition();
                            }

                            _this.domOpacity = Math.min(1, _this.domOpacity + 0.035);

                            if (_this.domOpacity < 1) {
                                _this.domContainer.style.opacity = "" + _this.domOpacity;
                            }

                            _this.domContainer.style.display = _this.domShowed ? 'flex' : 'none';
                        } else {
                            _this.domContainer.style.display = 'none';
                            _this.domOpacity = 0;
                            _this.domContainer.style.opacity = "" + _this.domOpacity;
                        }
                    }
                };

                _this.enableHsDrag = function (enable) {
                    _this.enableDrag = enable;
                };

                if (manager instanceof HotspotManager) {
                    _this.manager = manager;
                    _this.viewer = manager.viewer;
                    _this.dom = dom;
                    _this.config = config;
                    _this.mode = mode;
                    _this.id = config.id;

                    _this.start();
                } else {
                    throw new TypeError('constructor args are not valid');
                }

                return _this;
            }

            var _proto = CHotspotDom.prototype;

            _proto.initObject3D = function initObject3D() {
                this.display = Object3DProxy.newObject3D();
                this.display.visable = false;
                var halfWidth = this.viewer.container.offsetWidth / 2;
                var halfHeight = this.viewer.container.offsetHeight / 2;

                var _ref = this.config.pos || this.manager.screenToWorld(halfWidth, halfHeight),
                    x = _ref.x,
                    y = _ref.y,
                    z = _ref.z;

                this.display.position.set(x, y, z);
            };

            _proto.initDomContainer = function initDomContainer() {
                this.domContainer = document.createElement('div');
                this.domContainer.style.display = 'none';
                this.domContainer.style.opacity = '0';
                this.domContainer.style.position = 'absolute';
                this.domContainer.style.alignItems = 'center';
                this.manager.domHSContainer.appendChild(this.domContainer);
                this.domContainer.appendChild(this.dom);
            };

            _proto.setDomPosition = function setDomPosition() {
                var _this$manager$worldTo2 = this.manager.worldToScreen(this.display),
                    x = _this$manager$worldTo2.x,
                    y = _this$manager$worldTo2.y;

                this.domContainer.style.transform = "translate(" + x + "px, " + y + "px)translateZ(0)";

                if (!this.sP) {
                    this.sP = Object3DProxy.newVector2(x, y);
                } else {
                    this.sP.set(x, y);
                }
            };

            _proto.dispose = function dispose() {
                if (this.display.parent) {
                    this.display.parent.remove(this.display);
                    this.domContainer.removeChild(this.dom);
                }

                if (this.domContainer) {
                    this.domContainer.removeEventListener('mousedown', this.onMouseDown);
                    this.domContainer.removeEventListener('mouseover', this.onMouseOver);
                    this.domContainer.removeEventListener('mouseout', this.onDomMouseOut);
                }

                if (this.viewer && this.viewer.container) {
                    this.viewer.container.removeEventListener('mousemove', this.onMouseMove);
                    this.viewer.container.removeEventListener('mouseup', this.onMouseUp);
                    this.viewer.container.removeEventListener('mouseleave', this.onMouseLeave);
                }

                this.viewer = null;
                this.manager = null;
            };

            return CHotspotDom;
        }(Display);

        /**
         * @file: js util
         * @author: hucijiao(hucijiao@baidu.com)
         * @date: 2019-10-25 17:49:38
         * @Last Modified by: hucijiao(hucijiao@baidu.com)
         * @Last Modified time: 2020-04-09 18:03:33
         */
        function isNumber(n) {
            return !!n && typeof n === 'number';
        }

        class PanoConfiguration {
            constructor(vrResource) {
                this.id = '';
                this.sceneType = 'pano';
                this.sceneName = '';
                this.thumbnailUrl = '';
                this.fov = 70;
                this.fovRange = [1, 179];
                this.pitchRange = [-90, 90];
                this.zoomFactor = 1;
                this.rotation = { x: 0, y: 0, z: 0, w: 1 };
                this.hotspots = []; //
                const validInfo = this._validate(vrResource);
                if (!validInfo.valid) {
                    throw Error(validInfo.errorInfo);
                }
                this.vrResource = vrResource;
            }
            setId(id) {
                this.id = id;
                return this;
            }
            setSceneType(type) {
                this.sceneType = type;
                return this;
            }
            setSceneName(sceneName) {
                this.sceneName = sceneName;
                return this;
            }
            setThumbnailUrl(url) {
                this.thumbnailUrl = url;
                return this;
            }
            setFov(fov) {
                if (!isNumber(fov)) {
                    return this;
                }
                this.fov = fov;
                return this;
            }
            setFovRange(fovRange) {
                if (fovRange.length != 2 || fovRange[0] > fovRange[1]) {
                    console.log("the fovRange array length don't equal 2 or the first number is greater then the second number;");
                    return this;
                }
                this.fovRange = fovRange;
                return this;
            }
            setPitchRange(pitchRange) {
                if (pitchRange.length != 2 || pitchRange[0] > pitchRange[1]) {
                    console.log("the pitchRange array length don't equal 2 or the first number is greater then the second number;");
                    return this;
                }
                this.pitchRange = pitchRange;
                return this;
            }
            setZoomFactory(zoomFactor) {
                if (!isNumber(zoomFactor)) {
                    return this;
                }
                this.zoomFactor = zoomFactor;
                return this;
            }
            setRotation(rotation) {
                this.rotation = rotation;
                return this;
            }
            _validate(vrResource) {
                let valid = false;
                let errorInfo = '';
                switch (vrResource.render_type) {
                    case RenderType.CUBE: {
                        valid = vrResource.resource.source.hasOwnProperty('image');
                        errorInfo = valid
                            ? errorInfo
                            : 'the type of vrResource.resource.source' + 'should be PanoResourceSphereData';
                        break;
                    }
                    case RenderType.SPHERE: {
                        valid = vrResource.resource.source.hasOwnProperty('image');
                        errorInfo = valid
                            ? errorInfo
                            : 'the type vrResource.resource.source' + 'should be PanoResourceCubeData';
                        break;
                    }
                    case RenderType.CUBE_LIST: {
                        valid =
                            vrResource.resource.source.hasOwnProperty('image') &&
                            vrResource.resource.source.hasOwnProperty('order');
                        errorInfo = valid
                            ? errorInfo
                            : 'the type vrResource.resource.source' + 'should be PanoResourceCubeListData';
                        break;
                    }
                    case RenderType.CUBE_MULTI: {
                        valid =
                            vrResource.resource.source.hasOwnProperty('tile_path') &&
                            vrResource.resource.source.hasOwnProperty('tile_file') &&
                            vrResource.resource.source.hasOwnProperty('tile_size');
                        errorInfo = valid
                            ? errorInfo
                            : 'the type vrResource.resource.source' + 'should be PanoResourceCubeMultiData';
                        break;
                    }
                    default:
                        valid = false;
                        errorInfo = 'the value of vrResource.render_type is not supported presently';
                }
                return { valid: valid, errorInfo: errorInfo };
            }
        }

        exports.CHotspotDom = CHotspotDom;
        exports.EVENT = EVENT;
        exports.Euler = Euler;
        exports.Hotspot3D = Hotspot3D;
        exports.Object3DProxy = Object3DProxy;
        exports.PanoConfiguration = PanoConfiguration;
        exports.PanoViewer = PanoViewer;
        exports.Quaternion = Quaternion;
        exports.RafManager = RafManager;
        exports.RenderManager = RenderManager;

        Object.defineProperty(exports, '__esModule', { value: true });

    })));

</script>

<script>



    // id, fovfov(pitch)
    var configuration = new Hydreigon.PanoConfiguration({
        resource_type: 'pano',     // materialType
        render_type: 'sphere', // 
        resource: {               // 
            source: {
                image: 'https://hydreigon-dev.bj.bcebos.com/sdk-dev%2Fdist%2Fassets%2Fpano%2Fpano-test.jpg',
                order: 'fblrud'
            }
        }
    }).setId('scene-01').setSceneType('pano').setSceneName('Cool').setFov(70).setFovRange([1, 179]).setPitchRange([-90, 90]);


    var PanoViewer = Hydreigon.PanoViewer;
    var container = document.getElementById("container");
    var option = {debugLayer: false};

    var renderer = Hydreigon.RenderManager.create(container);
    container.appendChild(renderer.canvas);

    var ak = '36fcd1d85a5f4a8c8d565bac95214f76';
    var sk = '3dddcd75c98e4572b99e0c60a6b00d85';

    var panoViewer = new PanoViewer(container, ak, sk, option);
    panoViewer.init(configuration);
    panoViewer.addEventListener('scene-loaded', () => {
        panoViewer.enablePointEvent(true);
    });

    renderer.setCurrentViewer(panoViewer);
    Hydreigon.RafManager.add(renderer.render);



</script>
</body>
</html>
